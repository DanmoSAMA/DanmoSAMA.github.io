<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020 and Half of 2021</title>
    <url>/2021/05/30/11.2020+2021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="挣扎与彷徨"><a href="#挣扎与彷徨" class="headerlink" title="挣扎与彷徨"></a>挣扎与彷徨</h1><h2 id="高三之前"><a href="#高三之前" class="headerlink" title="高三之前"></a>高三之前</h2><p>高中的往事已回忆数次，无非就是这样的开局：不自信/想要变强→怀抱着不切实际要当科学家的妄想→逼迫自己，强迫症/形体化→后悔，无力改变现状。那个时候，基本是个人我都会感到羡慕，我沉沦于无止境的痛苦之中，每天都感觉过得浑浑噩噩，觉得自己的青春和人生就这么被强迫症给废掉了。不论我怎么努力，都感觉自己被限制住了，就是发挥不出来自己的能力，考试也极少进年级前50，比起我初中玩着考入班级前十，现在的我稳在班级前50%都困难。</p>
<p>现在觉得一切不过都是借口，强迫症也并没有那么可怕，虽然它让我的生活变得不太舒服，形体化的后患仍然存在，但并不影响我掌控自己的人生。当时成绩上不去，是我做了太多琐碎的事，摘抄或总结了很多笔记却很少复习且断断续续，自发刷题只坚持了英语，总之没有高效率地学习。顺带一提，这里提到的有些毛病我现在都还没有改掉。</p>
<p>在高二的时候其实我已经认识到（现在我都不知道这种认识是否正确），<strong>自己或许不能专精于任何一个方向</strong>，因为努力学习后也考不到年级顶尖水平。比起某方面的专精，我可能更适合成为全能型庸才（但其实这样我也做不到），所以当时就买了心理学、计算机、美学、音乐的书来看，还读了《混血豺王》和《比尔盖茨传》等。但是这一切在高三到来的时候就又被我抛掷脑后。</p>
<h2 id="疲于奔命"><a href="#疲于奔命" class="headerlink" title="疲于奔命"></a>疲于奔命</h2><p>高二暑假是我此生最短的暑假，短到只有两天。暑假前半段被迫参加每天200块的“名校通”，暑假后半段又要回去补课，回去前的一周我又自愿交钱补习化竞，顺带一提，后期到开学的这段时间我看完《钢之炼金术师》全套漫画。</p>
<p>那个时候，我看到了北大2020的招生简章，简章十分精美，花花绿绿，我们班上放了几本，于是我便热衷于阅读它。那个时候我被北大所深深吸引，开始幻想能不能考上，并且由于自己心态的困境，我特别想去心理学系。其实去不去心理学也无所谓，那时候我觉得读个考古都可以，反正是北大嘛。这样靠着专项计划，我还是得考到680分才可以，而我只有650分的水平，平时的模考只能考580~620区间。</p>
<p>我开始思考着自己如何达到这种“飞跃”，大概是一定要去找自己的节奏，有针对性地提分。前边还是比较顺利，在11月的一次模考中，我同时取得了语文（128，之后再也没达到过）和化学的双班级第一，年级31名，之后一次考试我坐在第一考场，考理综时心态突然崩溃，结果理综考了190，好状态完全止步于这次考试。于是我开始不听讲，不按着学校的复习进度来，自己整些笔记、刷题、网课，这些全都上了。但是随着时间的不断推移，我没觉得自己有什么进步，后边越来越过分。先是伪造病历去办了走读证，在学校旁边租了个小房间便于每天走读回去多学会，也方便刷网课。因为买的网课太多觉得刷不完，然后又跟班主任协商，翘掉四节晚自习。我开始觉得学校老师讲的啥用没有，平时的作业很多都在抄，觉得极其浪费时间，待在学校我都觉得痛苦，我把自己没有进步的错误都归咎于是学校限制了我。一轮复习结束，二轮复习开始，我觉得自己还是老样子。结果这段时间成绩不断下降，位次连着四五次都在一百名开外，老师也在找我谈话。</p>
<p>最后我还是下定决心回家复习去了，结果没走几天撞上疫情，大家都只能在家学习。在家期间我的神经十分紧绷，每天的平均时长在14个小时以上，基本每天就是6点多起床一直学到晚上11点多，除了过年有两三天偷了个懒，三个月没怎么变过。也算是刷完了学校的二轮资料和几本网课资料。但是我仍然觉得自己的学习没有太大起色，从三月起学校开始让学生印模考卷做，我仍然只能考620左右，此时心态十分炸裂，后悔却又无可奈何，那个时候平均两天就会改一次qq签名，正能量的鸡汤背后是深深的负能量。我反思前面做的这一切，终于承认了自己就是普通人的事实，为何要追求680这一虚无缥缈的目标，就这样舒舒服服地苟着不就好了吗？</p>
<h2 id="回归正常"><a href="#回归正常" class="headerlink" title="回归正常"></a>回归正常</h2><p>4月回到学校后我就开始佛系了，不再想着自己去做些什么，而是按部就班地跟着学校。回来的第一次模考，我在数学113血崩的情况下考了年级36，惊艳了一些同学。接下来的一次考试又到了100多名，然后又考了43名，之后就回到以前的段位，考60名左右的水平。事实证明，回家学习的这段时间我大概就物理有了进步，最头疼的数学还是老样子。进步最明显的是心态，我开始没那么在意高考，而且开始对现状持接纳态度，珍惜毕业前的日子。我会趁着晚上走读便利，和同学去吃华莱士、克莱堡、烧烤，甚至有一天住到他家里。考前两周我为全班同学吹奏《追梦赤子心》，高考完我回去给一位尊敬的老师吹奏《离歌》，弥补了高二的一次遗憾。</p>
<p>那段时间，我也常思考未来，不再去追求一时脑热的化学和心理学专业，觉得作为一个普通人就学个计算机专业，到时候出来工作挣钱就行了。看知乎推荐觉得北邮是一所不错的学校，因为就业率非常高，华科也可以，有“北北邮，南华科”之称。我给自己的计算机专业学校排名是：浙大→北航→华科→北邮→西电/西工。虽然佛系，高考我仍旧全力以赴，最后655收场，语文数学略炸，英语正常，理综略超常，总分是正常水平。周围不少平时一般的同学考到了670+，确实还是有点点不甘心吧。</p>
<p>报志愿的时候，这个分数在我省提前批次确实可以冲一冲华科，往年最高分数是656。但是华科CS给的名额很少，又是热门专业，所以心里没底。就这样，提前批我填了华科（只写了三个专业，还不服从调剂，事后后悔了，因为这不是稳进CS的方案），本一批填了北邮。其实这个分数挺合适的，分低一些我会进入华科非CS专业（光电/能动），分高一点（&gt;660）我说不定会冲进浙大的差专业。最后，事实证明我的担心多余，顺利来到华科CS。从结果上看，我的高考是比较顺利的。</p>
<h2 id="一晃而过的暑假"><a href="#一晃而过的暑假" class="headerlink" title="一晃而过的暑假"></a>一晃而过的暑假</h2><p>暑假开始做一些自己想做的事了，比如说学完标日上下册，还背了一些日语单词；口琴继续练；本来说要做视频，还是没有去学，懂了Pr基本操作，在9月初才剪了一个自己勉强满意的视频；骑车上国道，玩了一天多。</p>
<p>知道自己被华科CS录取后，我又开始“蠢蠢欲动”了，因为本质上我不是一个甘于平庸的人。因为高中的“难忘”经历，我果断地认定卷加权不是适合自己的道路，如何把大学生活过得丰富且有意义，是我最为注重的。早在高考之前，我就听说过华科的“三大团队”，抛开一些功利性的东西不谈，单是出于向往“互联网大学”，我就很想加入。于是我加入了秋招群，在自己并不清楚想要选什么方向的情况下，开始准备冲击联创Lab组，至于为什么是Lab，因为Lab的学习指南里有C，在看到招新信息的时候我已经学了一周的C，不想浪费基础（现在看起来有点可笑）。于是暑假的后半段我每天抽很多时间去看C、Linux，但是都是刷视频且浮光掠影；试着啃了一下黑皮《计算机科学导论》，每天刷个十几二十页，也感觉很难吸收其中的知识，看后就忘。</p>
<p><strong>从这里我开始产生一个矛盾：自己有明确想要学的东西（日语、口琴、视频），但是因为我有别的东西要追求，所以没时间做自己喜欢的事。要做的事多和有限的精力之间产生了不可调和的矛盾。</strong>现在思考一下我想加入团队的原因，无非：①因为高中怎么学都考不进年级前列，对卷加权这件事没有信心，想建立自己在其他方向的优势；②不想继续卷，觉得团队能带来有意义和丰富的生活。其他原因都能归咎于这两点上——想变强/想过不同的生活。</p>
<p>但是要加入团队，又不得不经历一个卷的过程，要努力卷进团队，就没有时间去做自己想做的事了。</p>
<h1 id="步入大学"><a href="#步入大学" class="headerlink" title="步入大学"></a>步入大学</h1><h2 id="确定方向"><a href="#确定方向" class="headerlink" title="确定方向"></a>确定方向</h2><p>来华科以后，新鲜感很快就过去，由于疫情，军训只持续了不到两星期，最后一天坐在潮湿的地面导致我感冒了。这段时间最重要的事就是冲击团队。我同时报名了冰岩、联创和Dian，最开始招新的是冰岩，根据我学习的内容，我选择了程序组。</p>
<p>那个时候我的基础，就是C语言能写<code>printf</code>和<code>if</code>、<code>for</code>循环的程度，连指针和数组都不会用。是的，美其名曰我暑假自学了C语言，其实就是刷视频，而且还没刷到指针，自己的代码能力几乎为0。Linux知道一些如<code>ls</code>、<code>cd</code>、<code>pwd</code>等的常用指令，自己配好了Vmware虚拟机。还稍微看了一点HTML和Python，但是几乎不会用。我还记得自己当时报名信息里吹得天花乱坠，把会的东西全部展开说，达到凑字数的目的，显得这个人很厉害。笔试时拿到题目，我几乎完全懵逼，但是还是硬生生的都编上去了，所有代码题和程序设计题都不会，就强行整个思路上去。最后笔试通过，国庆那天去了1006面试，为了试图作出“努力”的样子，我中午不到1点就到了，然后坐在那里为面试复习，拿起黑皮《计算机科学导论》，但是说实话什么都看不进去。那边有一两个学长学姐，我也不知道怎么跟他们寒暄。我当时思路清奇，走过去跟lyt学长说：“虽然笔试题我都不会，但我还是尽了最大努力去编答案”，似乎是想体现自己的顽强意志，结果得到了“不是给时间学了吗”的回复。然后面试开始，自我介绍，然后谈了自己会的东西，我刻意强调了自己会的都是很简单的皮毛。最后lyt学长问到如何用Python来把一个字符串逆序，我自然是承认自己不会。我最后还不忘补了一刀“我也存在一些同学在群里说的问题，就是像高中一样啃书学习，缺乏实践”。面试自然而然是被挂掉了。我认识到了自己的菜，所以后边的联创和Dian就鸽了（指连笔试题都没有做）。</p>
<p>当时我觉得，程序组的题目这么难，我自学一学期后端应该也进不了组，而且我高中数学就不是很好，编程可能比不过一些大佬，还是选一个大家都是零基础的、好入门的方向吧。那时候就在知乎上搜，发现前端学习路线非常明确，好像比较简单，加之我之前有一点点HTML的基础，觉得努力学一学期应该可以冲一冲团队，于是我就立刻决定学前端。那时真的是特别想去团队，不去想自己到底热爱什么，想的是什么方向适合我冲击团队。</p>
<p><strong>其实大学四年的时间很长，完全可以什么方向都学一些，再看看自己到底喜欢什么方向；或许自己不适合搞开发，那么就应该去读研。但我的决定就是做得这么快。</strong></p>
<h2 id="生活与学习"><a href="#生活与学习" class="headerlink" title="生活与学习"></a>生活与学习</h2><p>我的大学，从一开始就放弃参加内卷游戏，选择冲击团队之路后，我还希望自己的生活过得丰富一些。于是加入了车协，去骑东湖、骑八分山、骑到武大。武大百团的时候，我还加入了樱之音口琴社（虽然加入后从没参加过活动）。</p>
<p>不知怎么，现在的我已经没法沉下心来玩很长时间的游戏了，玩的时间一长就会导致做别的事情的时间变少，内心就会产生焦虑。其实我一点也不喜欢这样，初中那时一日十来个小时的游戏生活已经彻底远去。其他时间，就是看一看动漫，比起新番，我倾向于老的经典番剧，名作之壁。暑假看了凉宫、石头门、强风吹拂、排球、轻音、京吹，开学后继续看巨人、狼辛，后来又看了钢炼03、小圆、天元、Fate…</p>
<p>然后谈谈学习吧，为了抽出来更多时间来学技术，学校排的课我都疯狂水过，还翘了不少课。平时简单自学一下，做作业都是面向答案，考前再突击一下，第一学期除了期中线代挂掉，其他的科目都还能看，总加权也算混进了前50%，自己还是比较满意的。</p>
<p>但是技术学习，我还存在很多问题。首先我学习主要靠看视频（视频比较系统，看完了可以大概知道一个东西怎么做），而且对于100多集的视频，我一天也就看3~6集，所以学起来的速度非常慢，学完了还缺乏实践。于是就这样，我花了三个多月才完三剑客基础+Markdown，这种学习速度让我变得更加自卑，我不停地安慰自己：“不可心急，日积月累”。我想冲团队的愿望也影响了寝室的氛围，大家或多或少都在学习技术上的东西。</p>
<p>还有一件不愿提及但是不得不提的事就是摔牙，那时候我也抑郁了一阵子，觉得自己不能啃东西了什么的，但是时间可以冲淡悲伤，现在的我也逐渐接纳了这件事。</p>
<h2 id="忙碌的寒假"><a href="#忙碌的寒假" class="headerlink" title="忙碌的寒假"></a>忙碌的寒假</h2><p>我把寒假当作自己冲击冰岩的关键期，所以依然努力学习前端技术。我深入了一些JS，照着冰岩往年的笔试题来补充知识点，看了不少博客，最后觉得自己的实践能力不足，所以又复刻了一些页面。</p>
<p>因为团队是鞭策我学习的重要因素，有时候我会上网搜索信息，读完以后我就会动力十足，继续学习。一次在Github上搜索冰岩，找到了以前夏令营开的仓库，以此我了解到了gc学姐，一次问她js问题的时候，她向我发了一篇博客，是xiong35学长的。当时我就觉得学长很强，这激励了我花了三天时间，去搞了一个WP博客。然后我也加了学长的好友，稍微聊了一些后他鼓励了我，说我春招很有希望进入冰岩。当时的我，确实也有了一些进入冰岩的自信。</p>
<h2 id="冲冰岩失败"><a href="#冲冰岩失败" class="headerlink" title="冲冰岩失败"></a>冲冰岩失败</h2><p>开学以后，我一直期盼着冰岩的招新信息。这段时间我继续完成寒假的项目，以及看博客补充新的知识。很快招新就来了，因为心里激动，简历我是改了又改，最后我作了个大死，说自己搜冰岩的信息，想借此体现自己的热爱。殊不知，这是给自己挖了个天大的坑。我以为秋招面试被挂能带来一些教训，结果春招时我情商还是老样子。</p>
<p>就这样我一路杀过简历、面试，实习选题时，我不敢给自己选太难的，就还是老老实实复刻网页。因为实习只能通过很少的人，而实习名单里好像有实力很强的大二学长，我就还是不自信。实习期我疯狂翘课抄作业，硬是把所有Level基本完成了，展示时我想让自己说得更有条理一些，于是准备了稿子（作死*2），展示完后我觉得自己稳了。</p>
<p>然后就到了组面，在门外，我开始在脑海中构思着自我介绍。我一进门气氛就冷到冰点，然后就是我自顾自地说了很多（作死*3），接着被xiong35学长问到查资料的事，我也没有作出很好的解释。之后面试官问我还有没有什么问题，我反向让他们继续问我，结果被问到了答不上来的问题，场面继续尴尬。后面结局基本就注定了，组面没有通过。</p>
<h2 id="继续迷茫"><a href="#继续迷茫" class="headerlink" title="继续迷茫"></a>继续迷茫</h2><p>组面结束后的那个下午，我就不带手机绕着主校区走了一圈，以排解心中的苦闷。后来我的舍友A通过了冰岩程序组的考核，舍友B通过了Dian的考核。当时最想进入团队的我就这样落败，而他们怀着试一试的心态参与，就这样顺利进入了，一点都不羡慕是不可能的。</p>
<p>后来xiong35学长找我谈，说我技术很强，但是因为如上列举的原因没有让我通过，自己的风格和团队不符，让我找到适合自己的组织。后来我又联系了欧阳学姐，她说我“痴迷于技术”，“有种理工男呆呆的感觉”，“像个geek”，“忽略了一些情商方面的东西”（当然，我从来不认为自己像个Geek，因为Geek这个词给我一种很强的感觉，后来HackDay的队友也认为我完全不像是geek）。</p>
<p>我开始迷茫了，竟然在技术过关的情况下，因为别的因素被团队挂掉，我不太能接受这个结局。而且说我技术很强，那个时候我还真的相信了，开始考虑换方向，甚至是读研——毕竟学习能力强嘛，又何必局限于“简单”的前端。但是我技术真的强吗，也不强。学了五六个月还是这么点水平。想想xiong35学长充沛的精力和很强的学习能力，从零开始40天就能写博客的前后端，我就觉得自己什么都算不上。最后我还是继续学前端，不想浪费基础，而且还可以继续冲击团队。</p>
<p>可是说实话，我真的喜欢前端吗？不喜欢也不讨厌吧，遇到Bug会抓耳挠腮十分难受，可是解决问题时也会有巨大的成就感。写出赏心悦目的页面也可以给我带来正向反馈，但是也就仅仅是网页而已。现在我最需要的，大概就是要做出一个产品吧？一直孤立地自学，啃厚厚的书籍却什么也不做，又有何乐趣可言呢？总之，我目前还像是停留在“为了学习而学习，为了团队而学习”，而不是“为了需求而学习，一边实践一边学习”。</p>
<p>这学期的课内学习要比上学期拉跨了，一来是课业明显变得繁重，二是难度开始加大。我的态度也比上学期要松懈了许多，作业中有很多没有搞懂的内容，考试前复习得也不充分，就这样，我的微积分期中考试直接挂科。以后必须要改善学习方法了，不想投入时间又不想挂科的话，必须要依赖网上的“速成课”，或者慕课。</p>
<p>现在的我，还是想先坚持前端的路线，体验一下开发到底是什么感觉，后续作出的决定，很大程度上与我有没有进入团队有关。之前我想的是本科毕业就去投前端岗，去大厂996，但是最好还是读一下研究生，去外企955吧。</p>
<p>希望HackDay和暑假的夏令营能带来一些转变吧。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以下记录HackDay经历和带来的一些转变：</p>
<p>那是一节国际金融公选课，抄完大物答案百无聊赖的我打开了微信，看见了联创的最新推文——HackDay Reboot。其实这种比赛，我一般是不敢去想的——奖金丰厚、大佬云集，既然标榜是“极客狂欢”，和我这样的蒟蒻又有什么关系呢。但最后思量着，6月14日结束后应该来得及备考期末，况且可以学到不少东西，我还是决定报名。</p>
<p>进入FAQ群后，我本来决定报名后到现场组队，令我没有想到的是，一个冰岩的同学邀请我加入他们。最后三个冰岩人和我这个野路子组成了“启明好难队”。既然和冰岩同学组队了，我就不敢掉以轻心，生怕拖了他们的后腿。</p>
<p>我开始做知乎的项目练习前后端交互，开始写移动端，学了swiper插件（用于移动端滑动页面），由于发现原生JS的效率实在不高，在参加比赛的前一晚我入门了JQuery。</p>
<p>6月13日很快到来，我们先是在报告厅举办了开幕式，然后来到12楼，我被满眼的饮料和零食惊到了，没见过这种大场面。我们之前储备的idea押到了今年的关键字“择”，于是每个人就开始各搞各的，详细比赛过程就不多言。白嫖蒸功夫、披萨、小龙虾、K记的感觉真是太爽了，明年还来。</p>
<p>这次比赛印证了一点——我的技术确实存在短板，思维也常常跟不上，很多需求没做出来，设计的图也只用到一张。后端帮助了我很多，包括熬夜一整晚帮忙理清部分JS逻辑（惭愧）。命悬一刻的时候，都是后端救了我。没有我的队友，真的连阉割版产品都拿不出来。<br>一轮筛选的嘉宾有思否CEO高阳，有幸通过一轮筛选进入二轮，虽然最终没有获奖，但是已经很满意了。</p>
<p>顺带一提，同房间的大佬做的游戏实在牛逼（Re0从零开始的HUST生活），现场效果爆炸，拔得头筹。听到他们的商量和激烈的辩论，我发现，原来这就是Geek，他们对编程的热爱，是溢于言表的，即便是旁人也能深受感染，不像我遇到Bug时的萎靡无力。</p>
<p>经过HackDay，我认识到，学习编程是为了兴趣而非为了团队，真正的Geek用编程改变世界。几个月以来，在加入团队的室友和我侃侃而谈，以及和冰岩同学组队参加比赛之后，我愈来愈觉得，<strong>加入团队也并非我以前所以为的那样光鲜亮丽，团队人≠人上人。抬高对方，疯狂自贬的行为是错误的。</strong></p>
<p>看见大佬开发游戏的时候，我对游戏开发也产生了一定的兴趣，遂希望以后可以学一些框架去开发网页游戏。并且我认为，只是写网页确实有些普通，尝试客户端APP的开发也是一条可行之路。前端追求的是炫酷的特效和优秀的用户体验，我觉得也不错。当下先继续打好前端基础，<strong>不要把加入团队当作自己前进的动力</strong>，要因为喜欢，所以才用汗水浇灌它，哪怕最终什么团队都没加入，自己也可以在沁苑一隅发光发热。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>linux笔记</title>
    <url>/2021/08/26/39.Linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="网络连接的三种方式"><a href="#网络连接的三种方式" class="headerlink" title="网络连接的三种方式"></a>网络连接的三种方式</h2><p>同一网段下（如在192.168.0下）的主机可以互相通信</p>
<p>三种方式：</p>
<ul>
<li><p>桥接模式：虚拟系统可以和外部系统相互通讯，但是容易造成IP冲突</p>
</li>
<li><p>NAT模式：网络地址转换模式，虚拟系统可以和外部系统相互通讯（通过代理），不造成IP冲突</p>
</li>
<li><p>主机模式：独立系统，不与外部发生联系</p>
</li>
</ul>
<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>特点：</p>
<ul>
<li>层级式的树状目录结构</li>
<li>linux中一切皆文件（linux会把硬件映射成文件来管理）</li>
</ul>
<p>具体目录结构：</p>
<ul>
<li>/bin ：存放常用命令</li>
<li>/sbin：存放系统管理员使用的系统管理程序</li>
<li>/home：存放普通用户的主目录，目录名以用户账号命名</li>
<li>/root：系统管理员主目录</li>
<li>/lib：系统开机所需要的动态连接共享库</li>
<li>/lost+found：一般是空的，系统非法关机后会存放一些文件</li>
<li>/etc：系统管理所需的<strong>配置文件</strong>(.conf)和子目录</li>
<li>/usr：存放用户的应用程序和文件</li>
<li>/usr/local：给主机额外安装软件所存放的目录，一般通过编译源码方式安装的程序</li>
<li>/opt：给主机额外安装软件所存放的目录</li>
<li>/boot：存放<strong>启动</strong>linux的核心文件</li>
<li>/proc：虚拟目录，是系统内存的映射，访问该目录可获取系统信息</li>
<li>/srv：存放服务启动后需要提取的数据</li>
<li>/sys：该目录安装了文件系统sysfs</li>
<li>/tmp：存放临时文件</li>
<li>/dev：<strong>设备管理器</strong>，把所有硬件用文件形式存储</li>
<li>/media：linux识别U盘、光驱后，把这些<strong>设备挂载</strong>到该目录下</li>
<li>/mnt：该目录可<strong>挂载外部的存储</strong>（临时挂载其他文件系统）</li>
<li>/var：存惯存放经常被修改的目录，包括日志文件</li>
</ul>
<h2 id="远程登陆和文件传输"><a href="#远程登陆和文件传输" class="headerlink" title="远程登陆和文件传输"></a>远程登陆和文件传输</h2><ul>
<li><p>准备工作：下载xshell和xftp</p>
</li>
<li><p>使用<code>ifconfig</code>查看虚拟机ip</p>
</li>
<li><p>cmd ping 以上ip，确保互通</p>
</li>
<li><p>xshell和xftp的操作略，需要时看视频</p>
</li>
</ul>
<h2 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h2><p>常用快捷键（不声明则在标准模式下）：</p>
<ul>
<li><code>yy</code>拷贝当前行，<code>5yy</code>拷贝当前行向下的5行，<code>p</code>粘贴至光标处</li>
<li><code>dd</code>删除当前行，<code>5dd</code>删除当前行向下的5行</li>
<li>查找：<code>/关键字</code>，回车查找，输入<code>n</code>查找下一个</li>
<li>设置行号：<code>:set nu</code>和<code>:set nonu</code></li>
<li><code>G</code>到文档末行，<code>gg</code>到文档首行</li>
<li><code>u</code>撤销</li>
</ul>
<p>tips：</p>
<ul>
<li>写文件名到一半，按<code>tab</code>有代码补全功能</li>
</ul>
<h2 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h2><ul>
<li><code>shutdown -h now</code>：立刻关机</li>
<li><code>shutdown -h 1</code>：1分钟后关机</li>
<li><code>shutdown -r now</code>：立刻重启</li>
<li><code>halt</code>：关机（使用该命令后虚拟机只是提示cpu已禁用，还需要在虚拟机里手动关机）</li>
<li><code>reboot</code>：重启</li>
<li><code>sync</code>：把内存数据同步到磁盘</li>
</ul>
<p>tips：</p>
<ul>
<li>最好在关机和重启前执行<code>sync</code>，避免内存数据丢失，尽管关机重启前会默认执行sync，但小心为妙</li>
</ul>
<h2 id="登录注销"><a href="#登录注销" class="headerlink" title="登录注销"></a>登录注销</h2><ul>
<li><p><code>su - 用户名</code>：切换用户，如 su - root 切换到管理员；从权限高的用户切换到权限低的用户，不需要密码，反之需要</p>
</li>
<li><p>shell（运行级别3，在GUI下不可）下输入<code>logout</code>可以注销用户，使用<code>exit</code>登出的效果类似</p>
<p>假设第一次登录的用户是tom，tom使用 su - root 切换到管理员，此时logout，会从管理员变为tom，再logout，会退出系统</p>
</li>
</ul>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="增删用户"><a href="#增删用户" class="headerlink" title="增删用户"></a>增删用户</h3><ul>
<li><code>useradd 用户名</code>：创建用户，并在/home下生成同名文件夹，作为该用户的文件夹</li>
<li><code>useradd -d 指定目录 用户名</code>：把指定目录作为该用户的文件夹</li>
<li><code>passwd 用户名</code>：设置某一用户的密码，<strong>如果不加用户名，设置的是当前登录用户的密码</strong></li>
<li><code>userdel 用户名</code>：删除用户，但保留家目录</li>
<li><code>userdel -r 用户名</code>：删除用户，同时删除家目录</li>
</ul>
<p>tips：</p>
<ul>
<li>删除用户前，最好使用logout退登，再重新登录root，防止删除普通用户时，这个用户还登陆着（如果从普通用户登录，使用su - root登录管理员，那么该普通用户仍保持着登陆状态）</li>
<li>不要轻易删除家目录</li>
</ul>
<h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><ul>
<li><code>id 用户名</code>：查看用户信息</li>
<li><code>whoami/who am i</code>：查看当前第一次登录的用户信息</li>
</ul>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li><p><code>groupadd 组名</code>：新增组</p>
</li>
<li><p><code>groupdel 组名</code>：删除组</p>
</li>
<li><p><code>useradd -g 用户组 用户名</code>：创建用户，并将其添加至指定用户组</p>
<p>如果直接使用<code>useradd 用户名</code>，会自动创建和该用户同名的组，再把该用户添加至这个组内</p>
</li>
<li><p><code>usermod -g 用户组 用户名</code>：修改用户的组</p>
</li>
<li><p><code>usermod -d 目录 用户名</code>：改变该用户登录的初始目录（该用户必须拥有进入该目录的权限）</p>
</li>
</ul>
<h4 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h4><ol>
<li><p>/etc/passwd</p>
<p>用户的配置文件，记录用户的各种信息</p>
<p>每行的含义：==用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell==</p>
<p>Shell：linux内核是不认识各种指令的，可以认为shell帮助翻译了指令。一般情况下，shell是bash</p>
</li>
<li><p>/etc/shadow</p>
<p>口令的配置文件</p>
<p>每行的含义：==登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志==</p>
</li>
<li><p>/etc/group</p>
<p>组配置文件，记录linux包含的组的信息</p>
<p>每行的含义：==组名:口令:组标识号:组内用户列表==</p>
</li>
</ol>
<h3 id="用户级别"><a href="#用户级别" class="headerlink" title="用户级别"></a>用户级别</h3><p>运行级别说明：</p>
<ul>
<li><p>0：关机</p>
</li>
<li><p>1：单用户（找回丢失密码，视频在下一节，本人跳过）</p>
</li>
<li><p>2：多用户状态，无网络服务</p>
</li>
<li><p><strong>3：多用户状态，有网络服务</strong></p>
</li>
<li><p>4：自定义</p>
</li>
<li><p>5：图形界面</p>
</li>
<li><p>6：重启</p>
</li>
</ul>
<p>指令：</p>
<ul>
<li><p><code>init [0123456]</code>：切换运行级别</p>
<p>init 0可关机，init 6可重启</p>
</li>
<li><p><code>systemctl get-default</code>：查看默认运行级别</p>
</li>
<li><p><code>systemctl set-default target名称</code>：修改默认运行级别</p>
<p>target一般有两种：<code>multi-user.target</code>（级别3）和<code>graphical.target</code></p>
</li>
</ul>
<h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ul>
<li><code>man 指令</code>：获得某指令的帮助信息（按<strong>空格</strong>可以直接跳到下一页）</li>
<li><code>help 指令</code>：获得<strong>shell内置命令</strong>的帮助信息</li>
</ul>
<p>tips：</p>
<ul>
<li>linux下，隐藏文件以 . 开头</li>
<li>指令的选项可以组合使用，如ls -al和ls -la /root</li>
</ul>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="目录增删"><a href="#目录增删" class="headerlink" title="目录增删"></a>目录增删</h3><ul>
<li><code>ls -h</code>：将文件大小以人类可以读懂的方式显示，如433M（不开-h，默认显示字节数）</li>
<li><code>ls -R</code>：递归显示整个目录的内容</li>
<li><code>ll</code>：相当于<code>ls -l</code>，显示详细信息。因此也可以写ll -ah</li>
<li><code>cd ~</code>或<code>cd</code>：回到自己的家目录，比如你是root，那么cd ~到 /root</li>
<li><code>mkdir -p</code>：创建多级目录，如mkdir -p /home/animal/tiger。如果不加-p，linux必须得找到上一级目录才会创建下一级目录，否则会报错</li>
<li><code>cp -r 源目录 目标目录</code>：递归复制整个文件夹，如cp -r /home/bbb /opt（将整个目录拷贝到/opt），如果需要强制覆盖不提示，把cp改为<code>\cp</code></li>
<li><code>rm -r 目录</code>：递归删除整个目录，如果需要强制删除不提示，再加<code>-f</code>选项</li>
</ul>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p>知识补充：</p>
<ul>
<li>管道命令：把前一个命令的结果交给下一个命令处理，类似于命令的组合</li>
</ul>
<ul>
<li><p><code>cat -n 文件名</code>：读文件，带行号。比vm读更安全，因为只能读不能改</p>
</li>
<li><p><code>more 文件名</code>：读文件，并提供了多种交互功能，交互如下：</p>
<ul>
<li>空白：向下翻动一页</li>
<li>q：离开程序</li>
</ul>
</li>
<li><p><code>cat -n 文件名| more</code>：这是一个管道命令，把cat的结果交给more，好处：使用more也可以显示行号</p>
</li>
<li><p><code>less 文件名</code>：交互比more更多，并且<strong>动态读取文本</strong>，而不是一下子把文本全部载入内存，推荐使用</p>
<ul>
<li>PgUp：向上翻动一页</li>
<li>PgDn：向下翻动一页</li>
<li>/字串：向下搜寻【字串】的功能；n：向下查找；N：向上查找（记住它）</li>
<li>?字串：向上搜寻【字串】的功能；n：向上查找；N：向下查找</li>
<li>G：跳转至末尾</li>
<li>g：跳转至开头</li>
</ul>
</li>
<li><p><code>head 文件</code>：查看文件前10行内容，<code>tail</code>查看后10行内容</p>
</li>
<li><p><code>head -n 5 文件</code>：查看文件前5行内容</p>
</li>
</ul>
<h3 id="覆盖追加"><a href="#覆盖追加" class="headerlink" title="覆盖追加"></a>覆盖追加</h3><ul>
<li><p><code>echo 环境变量</code>：查看环境变量，如echo $PATH</p>
</li>
<li><p><code>echo &quot;内容&quot;</code>：将内容打印在屏幕上，如echo “hello”</p>
</li>
<li><p><code>tail -f 文件</code>：实时追踪文档的所有更新</p>
</li>
</ul>
<p>&gt;表示覆盖写，&gt;&gt;表示追加写</p>
<ul>
<li><code>ls -l &gt; 文件</code>：将列表内容写入文件（目标文件不存在就会自动创建，下同）</li>
<li><code>cat 文件1 &gt; 文件2</code>：将文件1的内容覆盖到文件2</li>
<li><code>echo &quot;内容&quot; &gt;&gt; 文件 </code>：将内容追加进文件</li>
<li><code>cal &gt;&gt; 文件</code>：将日历信息追加进文件</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p><code>软链接</code>又称为符号链接，类似于win中的快捷方式，存放了链接其他文件的路径</p>
<ul>
<li><p><code>ln -s 原文件或目录 软链接名</code>：为原文件创建一个软链接</p>
<p>创建好指向某一目录的软链接，并cd进入软链接以后，使用ls，看到的列表 和 在原目录下看到的列表 一致</p>
<p>使用pwd查看目录时，仍然看到的是软链接所在目录</p>
</li>
<li><p><code>rm 软链接名</code>：删除软链接，如rm /home/myroot</p>
</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul>
<li><code>history</code>：显示所有的历史指令</li>
<li><code>history 10</code>：显示最近使用过的10个指令</li>
<li><code>!5</code>：执行历史编号为5的指令</li>
</ul>
<h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><p>字母注意大小写：</p>
<ul>
<li><p><code>date</code>：显示当前时间</p>
</li>
<li><p><code>date +%Y </code>：显示当前年份</p>
</li>
<li><p><code>date +%m</code>：月份</p>
</li>
<li><p><code>date +%d</code>：天</p>
</li>
<li><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月日时分秒</p>
<p>引号内除第一个加号必需，后面的-和空格只是起修改格式的作用，可以任意修改</p>
</li>
</ul>
<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><ul>
<li><p><code>find 搜索范围 选项</code>： 从指定目录向下递归地遍历各个子目录，将满足条件的文件或目录显示在终端</p>
<ul>
<li>-name 按指定文件名查找</li>
<li>-user 查找属于某一用户名的所有文件</li>
<li>-size 按照大小查找，+n大于，-n小于，n等于，如<code>find / -size +200M</code></li>
</ul>
<p>可以组合使用 | less，避免显示内容过长不便于阅读</p>
</li>
<li><p><code>locate 文件名</code>：快速定位文件路径</p>
<p>locate指令利用事先建立的==系统中所有文件名称及路径的locate数据库==实现快速定位给定的文件，无需遍历整个文件系统</p>
<p>使用locate之前，先使用<code>updatedb</code>更新locate数据库</p>
</li>
<li><p><code>which 指令名</code>：查看指令所在的目录</p>
</li>
<li><p><code>gerp 选项 查找内容 文件名</code>：筛选文件的特定内容</p>
<ul>
<li>-n：显示匹配行及行号</li>
<li>-i：忽略字母大小写</li>
</ul>
<p>可以直接用grep，也可以用管道指令，如==grep -n “yes” hello.txt== 等价于 ==cat hello.txt | grep “yes”==</p>
</li>
</ul>
<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><ul>
<li><p><code>gzip 文件</code>：将文件压缩为*.gz文件（将原本的文件变为压缩文件，而不是新生成压缩文件）</p>
</li>
<li><p><code>gunzip 压缩文件</code>：解压缩</p>
</li>
<li><p><code>zip 选项 压缩后的文件名 目录或文件 </code>：压缩文件，选项-r表示递归压缩</p>
<p>在“压缩后的文件名”处还可以提供压缩后文件所在的目录</p>
<p>如zip -r /opt/myhome.zip /home，表示将home目录及其包含的文件和子目录都压缩为/opt目录下的myhome.zip文件，同时原目录/文件被保留，相当于新生成了压缩文件</p>
</li>
<li><p><code>unzip 压缩文件</code>：解压缩</p>
<ul>
<li><code>unzip -d 目录 压缩文件</code>：指定压缩文件解压缩到某个目录下，如unzip -d /tmp /home/myhome.zip，表示将该压缩文件解压到/tmp目录下</li>
</ul>
</li>
<li><p><code>tar 选项 xxx.tar.gz 打包的内容</code>：打包目录，压缩后的文件格式.tar.gz</p>
<p>选项：</p>
<ul>
<li>-c：产生.tar打包文件</li>
<li>-v：显示详细信息</li>
<li>-f：指定压缩后的文件名</li>
<li>-z：打包同时压缩</li>
<li>-x：解包.tar文件</li>
<li>-C：解压到的位置</li>
</ul>
<p>案例：</p>
<ul>
<li>==tar -zcvf test.tar.gz a.txt b.txt==：压缩多个文件（空格分隔文件名）</li>
<li>==tar -zcvf test.tar.gz /dir==：压缩某个目录</li>
<li>==tar -zxvf test.tar.gz==：解压到当前目录</li>
<li>==tar -zxvf test.tar.gz -C /opt==：解压到/opt目录下</li>
</ul>
</li>
</ul>
<h2 id="linux组"><a href="#linux组" class="headerlink" title="linux组"></a>linux组</h2><h3 id="修改所有者和所在组"><a href="#修改所有者和所在组" class="headerlink" title="修改所有者和所在组"></a>修改所有者和所在组</h3><p>linux中的<strong>每个文件</strong>有所有者、所在组、其它组的概念</p>
<ul>
<li><code>chown 用户名 文件名</code>：修改文件/目录的所有者</li>
<li><code>chown 用户名:组名 文件/目录</code>：同时修改文件/目录的所有者和所在组</li>
<li><code>chgrp 组名 文件名</code>：修改文件/目录所在的组</li>
<li><code>-R</code>：添加这个选项后，如果是目录，其下所有子文件或目录递归生效</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>ls -l后，会看到很多信息，如：==-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc==</p>
<p>0-9位说明：</p>
<ul>
<li>第0位确定文件类型：<ul>
<li>-：普通文件</li>
<li>d：目录</li>
<li>l：软链接</li>
<li>c：字符设备文件，如鼠标、键盘</li>
<li>b：块设备文件，如键盘</li>
</ul>
</li>
<li>第1-3位确定所有者的权限，第4-6位确定所属组的权限，第7-9位确定其他用户的权限</li>
</ul>
<p>rwx权限：</p>
<ul>
<li>到文件：<ul>
<li>r：可读取、查看</li>
<li>w：可修改，但不代表可以删除文件，删除文件的前提条件是<strong>用户对文件所在的目录有写权限</strong></li>
<li>x：可执行</li>
</ul>
</li>
<li>到目录：<ul>
<li>r：可以用ls查看目录内容</li>
<li>w：可在目录内创建和删除（也可以删除目录），可以重命名目录</li>
<li>x：可以进入目录</li>
</ul>
</li>
</ul>
<p>其他说明：</p>
<ul>
<li>1：如果只有一个文件，则该数为1；如果是目录，该数 = 子目录数 + 目录下文件数（只用找一层）</li>
</ul>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>第一种方式：u：所有者，g：所属组，o：其它组，a：所有人</p>
<ul>
<li><code>chmod u=rwx,g=rx,o=x 文件/目录名</code>：设置权限</li>
<li><code>chmod o+w o+w 文件/目录名</code>：增加权限</li>
<li><code>chmod a-x 文件/目录名</code>：减少权限</li>
</ul>
<p>第二种方式：r=4，w=2，x=1</p>
<ul>
<li><code>chmod 751 文件/目录名</code>等价于上方的第一条</li>
</ul>
<h1 id="实操篇"><a href="#实操篇" class="headerlink" title="实操篇"></a>实操篇</h1><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="crontab-任务调度"><a href="#crontab-任务调度" class="headerlink" title="crontab 任务调度"></a>crontab 任务调度</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>任务调度：指系统在某个时间执行的特定的命令或程序</p>
<p>分类：</p>
<ul>
<li>系统工作：有些重要的工作必须周而复始地进行，如病毒扫描等</li>
<li>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份（也可以只是执行一条简单指令）</li>
</ul>
<p>指令：</p>
<ul>
<li><code>crontab 选项</code>：<ul>
<li>-e：编辑crontab定时任务</li>
<li>-l：查询crontab任务（列出当前有哪些任务调度）</li>
<li>-r：删除当前用户所有的crontab任务（终止任务调度）</li>
</ul>
</li>
<li><code>service crond restart</code>：重启任务调度</li>
</ul>
<p>操作：</p>
<ul>
<li>设置任务调度：crontab -e</li>
<li>输入任务到调度文件，如：==*/1 * * * * ls -l /etc &gt; /tmp/to.txt==，意思是每分钟执行ls -l /etc…这个指令</li>
</ul>
<p>5个占位符的说明：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个 *</td>
<td>一小时中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个 *</td>
<td>一天中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个 *</td>
<td>一个月中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个 *</td>
<td>一年中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个 *</td>
<td>一周中的星期几</td>
<td>0-7（0和7代表星期日）</td>
</tr>
</tbody></table>
<blockquote>
<p>星期几和几号最好不要同时出现，容易使人混乱</p>
</blockquote>
<p>特殊符号的说明：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间</td>
</tr>
<tr>
<td>,</td>
<td>代表不连续的时间，如”0 8,12,16 * * *”命令，表示在每天8:00，12:00，16:00都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间，如”0 5 * * 1-6”命令，表示在周一到周六的凌晨5点执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次，如”*/10 * * * *”命令，表示每隔10分钟就执行一次命令</td>
</tr>
</tbody></table>
<h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><p>将命令写入脚本，通过执行脚本来执行命令：</p>
<ol>
<li><code>vim xxx.sh</code> 写入内容，如 date &gt;&gt; /home/mycal 和 cal &gt;&gt; /home/mycal</li>
<li>给xxx.sh增加执行权限，<code>chmod u+x xxx.sh</code></li>
<li><code>crontab -e</code>增加 ==*/1 * * * * xxx.sh==</li>
</ol>
<h3 id="at-定时任务"><a href="#at-定时任务" class="headerlink" title="at 定时任务"></a>at 定时任务</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>简介：</p>
<ul>
<li>at命令是<strong>一次性定时计划任务</strong>，at的守护进程atd会以后台模式运行，检查作业队列来运行</li>
<li>默认情况下，atd守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</li>
<li>at命令执行完一个任务后，以后不再执行此任务</li>
<li>使用at命令时需要保证atd进程的启动，可以使用<code>ps -ef | grep atd</code>来检测atd是否在运行（ps -ef 用于检测当前运行的所有进程）</li>
</ul>
<p>at命令格式：</p>
<ul>
<li><code>at 选项 时间</code>：添加at任务</li>
<li><code>atq</code>：查看系统中没有执行的工作任务</li>
<li><code>atrm 编号</code>：从队列中删除指定编号的任务</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-m</td>
<td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td>
</tr>
<tr>
<td>-I</td>
<td>atq的别名</td>
</tr>
<tr>
<td>-d</td>
<td>atrm的别名</td>
</tr>
<tr>
<td>-v</td>
<td>显示任务将被执行的时间</td>
</tr>
<tr>
<td>-c</td>
<td>打印任务的内容到标准输出</td>
</tr>
<tr>
<td>-V</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-q &lt;队列&gt;</td>
<td>使用指定队列</td>
</tr>
<tr>
<td>-f &lt;文件&gt;</td>
<td>从指定文件读入任务，而不是从标准输入读入</td>
</tr>
<tr>
<td>-t &lt;时间参数&gt;</td>
<td>以时间参数的形式提交要运行的任务</td>
</tr>
</tbody></table>
<p>at时间定义：</p>
<img src="https://z3.ax1x.com/2021/08/29/h8QD2t.png" style="zoom: 80%;">

<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>输入at指令开始编辑后，退出时，按两次<code>ctrl + D</code></p>
<ul>
<li><p>案例1：2天后的下午5点执行 ls /home：</p>
<p>at 5pm +2days</p>
<p>ls /home</p>
</li>
<li><p>案例2：2分钟后，输出时间到指定文件内：</p>
<p>at now +2minutes</p>
<p>date &gt; /root/date.log</p>
</li>
</ul>
<h2 id="磁盘分区与挂载"><a href="#磁盘分区与挂载" class="headerlink" title="磁盘分区与挂载"></a>磁盘分区与挂载</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每块硬盘有多个分区，而linux系统中有多个目录，所谓“挂载”，就是把一个分区和一个目录联系起来</p>
<p>真正存放数据的是分区，比如在下图中，如果在/home下创建文件，就会把该文件存入分区1</p>
<img src="https://z3.ax1x.com/2021/08/29/h83RaD.png" style="zoom:80%;">

<p>硬盘说明：</p>
<ul>
<li>linux硬盘分为<code>IDE硬盘</code>和<code>SCSI硬盘</code>，目前以后者为主</li>
<li>IDE硬盘的标识为”hdx~“，SCSI硬盘的标识为”sdx~“</li>
<li>x为盘号，a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘（或简单理解为第一个盘、第二个盘…）</li>
<li>~代表分区，前四个分区用1到4表示，它们是主分区或拓展分区。从5开始是逻辑分区</li>
</ul>
<p>指令：</p>
<ul>
<li><code>lsblk</code>：查看设备挂载情况</li>
<li><code>lsblk -f</code>：信息更详细，显示磁盘每个分区对应的40位唯一标识符（当且仅当分区格式化后，才会生成该UUID）</li>
</ul>
<h3 id="增加磁盘实例"><a href="#增加磁盘实例" class="headerlink" title="增加磁盘实例"></a>增加磁盘实例</h3><p>步骤：虚拟机添加硬盘→分区→格式化→挂载→设置可以自动挂载</p>
<ul>
<li><p>虚拟机添加硬盘：vmware内操作，设置→添加硬盘→一路下一步</p>
<p>reboot 重启系统才能识别新的硬盘</p>
</li>
<li><p>分区：</p>
<ul>
<li><p><code>fdisk /dev/sdb</code>开始对/sdb 分区，具体操作：</p>
<ol>
<li><p>开始分区后输入n，新增分区</p>
</li>
<li><p>然后选择p，分区类型为主分区</p>
</li>
<li><p>两次回车，默认剩余全部空间</p>
</li>
<li><p>输入w</p>
</li>
</ol>
<p>m：显示命令列表</p>
<p>p：显示磁盘分区，同 <code>fdisk -l</code></p>
<p>n：新增分区</p>
<p>d：删除分区</p>
<p>w：写入并退出</p>
<p>q：不保存退出</p>
</li>
</ul>
</li>
<li><p>格式化磁盘：</p>
<ul>
<li><code>mkfs -t ext4 /dev/stb1</code>：格式化命令，其中ext4是分区类型</li>
</ul>
</li>
<li><p>挂载：</p>
<ul>
<li><code>mount 设备名称 挂载目录</code>：如 mount /dev/sdb1 /newdisk</li>
<li><code>umount 设备名称/挂载目录</code>：卸载命令，如 umount /dev/sdb1 或 umount /newdisk</li>
<li>注意：用命令行挂载，<strong>重启后会失效</strong></li>
</ul>
</li>
<li><p>设置自动挂载：修改/etc/fstab，添加完成后，执行mount -a即刻生效（重启也可生效）</p>
<p>最前面的UUID也可以填写设备名称，如/dev/sdb1，最后两个参数写 0 0（目前不懂）</p>
</li>
</ul>
<h3 id="取消挂载的情况"><a href="#取消挂载的情况" class="headerlink" title="取消挂载的情况"></a>取消挂载的情况</h3><p>情景：当取消挂载后，原文件夹里的文件访问不到了，如何解决？</p>
<p>比如说，先创建了dir1，把/dev/sdb1 挂载到dir1上，并在dir1内创建了几个文件。现在取消挂载，再进入dir1，发现找不到这些文件了。</p>
<p>做法：再创建dir2，把/dev/sdb1 挂载到dir2上，就能找回那些文件了</p>
<h3 id="转移硬盘的情况"><a href="#转移硬盘的情况" class="headerlink" title="转移硬盘的情况"></a>转移硬盘的情况</h3><p>（以下内容是自己总结的，未必准确，以后可能修改）</p>
<p>情景：/dev/sdb1此时挂载在dir上，现在我们想让/dev/sdb2挂载到dir上</p>
<p>做法：</p>
<ul>
<li>创建新的目录/new，使用<code>mv /dir/* /new</code>将dir中的内容剪切过去</li>
<li>取消挂载</li>
<li>将另一块硬盘挂载到/new目录下</li>
</ul>
<h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><ul>
<li><p><code>df -h</code>：查询系统整体磁盘使用情况</p>
</li>
<li><p><code>du -h</code>：查询指定目录的磁盘占用情况，默认为当前目录</p>
<p>选项：</p>
<ul>
<li>-h：带计量单位</li>
<li>-a：带文件，而不仅是子目录</li>
<li>–max-depth=1：子目录深度</li>
<li>-c：列出明细的同时，增加汇总值</li>
</ul>
<p>应用：==du -hac –max-depth=1 /opt==可查询/opt目录的磁盘占用情况，深度为1</p>
</li>
</ul>
<h3 id="磁盘实用指令"><a href="#磁盘实用指令" class="headerlink" title="磁盘实用指令"></a>磁盘实用指令</h3><p>grep可以接收一个正则表达式，以下指令如果不加 wc -l，则页面上只显示文件/文件夹：</p>
<ol>
<li><code>ls -l /opt | grep &quot;^-&quot; | wc -l</code>：统计/opt目录下文件的个数</li>
<li><code>ls -l /opt | grep &quot;^d&quot; | wc -l</code>：统计/opt目录下一级子目录的个数</li>
<li><code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code>：统计/opt目录下全部文件的个数，包括子目录里的</li>
<li><code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code>：统计/opt目录下全部目录的个数，包括子目录里的</li>
<li><code>tree 目录</code>：以树状显示目录结构，需要先<code>yum install tree</code>按照tree指令</li>
</ol>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>NAT网络配置原理图：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGeMJx.png" style="zoom:80%;">

<p>可见，linux虚拟机和vmnet8的ip地址是一样的</p>
<p>指令：</p>
<ul>
<li><code>ipconfig</code>：查看windows的网络配置</li>
<li><code>ifconfig</code>：查看linux的网络配置</li>
<li><code>ping 目的主机</code>：测试当前服务器是否可以连接目的主机</li>
</ul>
<h3 id="配置静态ip"><a href="#配置静态ip" class="headerlink" title="配置静态ip"></a>配置静态ip</h3><p>默认情况下，linux的ip是自动获取的，每次获取的ip地址可能不一样，因此我们需要指定ip</p>
<p>指定ip的方法：<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从DHCP修改为static</span></span><br><span class="line">BOOTPROTO=&quot;static&quot; </span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;49034b55-e0a4-4493-a105-50ab889139ad&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">IP地址</span></span><br><span class="line">IPADDR=192.168.200.130</span><br><span class="line"><span class="meta">#</span><span class="bash">网关</span></span><br><span class="line">GATEWAY=192.168.200.2</span><br><span class="line"><span class="meta">#</span><span class="bash">域名解析器</span></span><br><span class="line">DNS1=192.168.200.2</span><br></pre></td></tr></table></figure>

<p>修改后，使用<code>service network restart</code>或<code>reboot</code>生效</p>
<p>同时，还要修改vmware中虚拟网络编辑器中的ip，和xshell的属性（见视频）</p>
<h3 id="主机名和hosts映射"><a href="#主机名和hosts映射" class="headerlink" title="主机名和hosts映射"></a>主机名和hosts映射</h3><p>Hosts：一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p>
<h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><ul>
<li><code>hostname</code>：查看主机名</li>
<li><code>vi /etc/hostname</code>：指定主机名</li>
<li>重启生效</li>
</ul>
<h4 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h4><p>windows→linux：在C:\Windows\System32\drivers\etc\hosts 文件指定即可，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.200.130 centos7.6</span><br></pre></td></tr></table></figure>

<p>linux→windows：在/etc/hosts 文件指定，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.200.1 win10</span><br></pre></td></tr></table></figure>



<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>在linux中，每个执行的程序都称为一个进程，每一个进程都分配一个pid（进程号）</p>
<p>每个进程都可能以<strong>前台</strong>和<strong>后台</strong>两种方式存在，前台是用户目前的屏幕上可以操作的进程，后台是实际在操作，但屏幕上无法看到的进程</p>
<p>一般系统发服务通常以后台进程的方式存在，常驻系统中，直到关机才结束</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>ps：用于查看目前系统中的进程状况</p>
<p>选项：</p>
<ul>
<li>-a：显示<strong>当前终端</strong>的所有进程信息（不是所有进程）</li>
<li>-u：以用户的格式显示进程信息</li>
<li>-x：显示后台进程运行的参数</li>
<li>-e：显示所有进程</li>
<li>-f：全格式</li>
</ul>
<p>查看有无特定服务：<code>ps -aux | grep xxx</code>，比如查看有无sshd服务</p>
<h4 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps -aux"></a>ps -aux</h4><p>使用ps -aux：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGtEZt.png" style="zoom:80%;">



<table>
<thead>
<tr>
<th>USER</th>
<th>PID</th>
<th>%CPU</th>
<th>%MEM</th>
<th>VSZ</th>
<th>RSS</th>
<th>TTY</th>
<th>STAT</th>
<th>START</th>
<th>TIME</th>
<th>COMMAND</th>
</tr>
</thead>
<tbody><tr>
<td>用户名称</td>
<td>进程号</td>
<td>占用CPU百分比</td>
<td>占物理内存百分比</td>
<td>占用虚拟内存大小(KB)</td>
<td>占用物理内存大小(KB)</td>
<td>终端名称(缩写，因此显示?)</td>
<td>进程状态</td>
<td>启动时间</td>
<td>使用CPU的时间</td>
<td>启动进程所用的命令和参数(太长会截断显示)</td>
</tr>
</tbody></table>
<p>关于进程状态STAT：</p>
<ul>
<li>S：睡眠</li>
<li>s：表示该进程是会话的先导进程</li>
<li>N：表示进程比普通优先级更低的优先级</li>
<li>R：正在运行</li>
<li>D：短期等待</li>
<li>Z：僵尸进程</li>
<li>T：被跟踪或被停止</li>
</ul>
<h4 id="ps-ef-与父子进程"><a href="#ps-ef-与父子进程" class="headerlink" title="ps -ef 与父子进程"></a>ps -ef 与父子进程</h4><p><code>ps -ef</code>：以全格式显示当前所有的进程</p>
<img src="https://z3.ax1x.com/2021/08/29/hGawQg.png" style="zoom:80%;">

<table>
<thead>
<tr>
<th>UID</th>
<th>PID</th>
<th>PPID</th>
<th>C</th>
<th>STIME</th>
<th>TTY</th>
<th>TIME</th>
<th>CMD</th>
</tr>
</thead>
<tbody><tr>
<td>用户名称</td>
<td>进程号</td>
<td><strong>父进程ID</strong></td>
<td>见下方</td>
<td>进程启动的时间</td>
<td>终端名称</td>
<td>使用CPU的时间</td>
<td>启动进程所用的命令和参数</td>
</tr>
</tbody></table>
<p>C：CPU用于计算执行优先级的银子。数值越大，表明进程是CPU密集型运算，优先级降低；数值越小，表面进程是I/O密集型运算，优先级升高</p>
<p>父子进程：进程存在父子关系，先有父进程，再由父进程创建子进程，如图所示为sshd（远程登陆服务）的相关进程：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGaUW8.png" style="zoom:80%;">

<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>指令：</p>
<ul>
<li><p><code>kill 选项 进程号</code>：通过进程号杀死/终止进程；-9选项 表示强迫进程立即停止</p>
</li>
<li><p><code>killall 进程名称</code>：通过进程名杀死进程；同时，杀死父进程时也会杀死它的子进程；支持通配符</p>
</li>
</ul>
<p>最佳实践：</p>
<ul>
<li><p>踢掉某个非法登录用户：<code>kill 进程号</code>（查看sshd进程，找到进程号）</p>
</li>
<li><p>终止远程登录服务sshd，在适当的时候再次重启sshd服务：</p>
<p><code>kill sshd 进程号</code></p>
<p>重启：<code>/bin/systemctl start sshd.service</code></p>
</li>
<li><p>终止多个gedit（文本编辑器）：<code>killall gedit</code></p>
</li>
<li><p>强制杀死一个终端：<code>kill -9 bash的进程号</code></p>
</li>
</ul>
<h3 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h3><p><code>pstree 选项</code>可以直观查看进程信息</p>
<p>选项：</p>
<ul>
<li>-p：显示进程的PID</li>
<li>-u：显示进程的所属用户</li>
</ul>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top指令和ps类似，不同之处是它在执行一段时间后可以更新正在运行的进程</p>
<p><code>top -d 秒数</code>：指定top每隔几秒更新，默认3秒</p>
<p>其他选项：</p>
<ul>
<li>-i：使top不显示任何闲置或僵尸进程</li>
<li>-p：通过指定监控进程ID，来仅仅监控某个进程的状态</li>
</ul>
<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p>后台程序 ~ 服务 ~ 守护进程 </p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>service管理指令：</p>
<ul>
<li><code>service 服务名 [start|stop|restart|reload|status]</code></li>
<li>在centos7.0后，很多服务不再使用service，而是使用systemctl</li>
<li>service指令管理的服务在<code>/etc/init.d</code>查看</li>
</ul>
<p>查看服务名：</p>
<ul>
<li><code>setup</code>：查看全部系统服务</li>
</ul>
<h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p>chkconfig指令：可以给服务的各个运行级别设置自启动/关闭（在centos7.0后，很多服务使用systemctl，管理的服务在<code>/etc/init.d</code>查看）</p>
<ul>
<li><p><code>chkconfig --list [|grep xxx]</code>：查看全部服务</p>
</li>
<li><p><code>chkconfig 服务名 --list</code>：查看某项服务</p>
</li>
<li><p><code>chkconfig --level 数字 服务名 on/off</code>：对服务的各个运行级别设置自启动/关闭，需要重启生效</p>
<p>如：chkconfig –level 3 network off</p>
</li>
</ul>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>systemctl管理指令：它管理的服务在<code>/usr/lib/systemd/system</code>查看</p>
<ul>
<li><code>systemctl [start|stop|restart|status] 服务名</code>：如果选择stop，只是临时关闭服务，下次启动还看is-enabled</li>
<li><code>systemctl list-unit-files [|grep 服务名]</code>：查看服务开机启动状态</li>
<li><code>systemctl enable 服务名</code>：设置服务（在3和5级别下）开机启动</li>
<li><code>systemctl disable 服务名</code>：关闭服务（在3和5级别下）开机启动</li>
<li><code>systemctl is-enabled 服务名</code>：查询某个服务是否是自启动的</li>
</ul>
<h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h3><p>防火墙：外界想要访问服务器ip（比如192.168.200.130）下的某个端口（如111），要先经过防火墙。防火墙将一些端口开放，将一些端口关闭，如果外界访问了关闭的端口，则访问失败</p>
<p>比如防火墙未开放111端口，此时在windows <code>telnet 192.168.200.130 111</code>会失败 </p>
<p>防火墙指令：</p>
<p>输入<code>netstat -anp | more</code>，最前面一列可以看到端口对应的协议</p>
<ul>
<li><code>firewall-cmd --permanent --add-port=端口号/协议</code>：打开端口</li>
<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code>：关闭端口</li>
<li><code>firewall-cmd --reload</code>：重新载入，使上方指令生效</li>
<li><code>firewall-cmd --query-port=端口/协议</code>：查询端口是否开放</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>dart + flutter笔记</title>
    <url>/2021/08/26/42.flutter%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>SDK：指一些被软件工程师用于为特定的软件包、软件框架、硬性平台及作业系统等建立应用软件的开发工具之集合。</p>
</blockquote>
<h1 id="dart"><a href="#dart" class="headerlink" title="dart"></a>dart</h1><h2 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h2><p>Hello world程序的两种写法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;hello dart&#x27;</span>); <span class="comment">// 分号不可省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;hello dart&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>可以不预先定义变量类型，用<code>var</code>定义变量，类型会自动推导</li>
<li>也可以定义变量类型</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> str1 = <span class="string">&#x27;hello dart1&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">String</span> str2 = <span class="string">&#x27;hello dart2&#x27;</span>;</span><br><span class="line">  <span class="built_in">int</span> num2 = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dart存在类型校验，类型确定后，再给变量赋值为另一个类型，会报错</li>
</ul>
<h3 id="final和const的区别"><a href="#final和const的区别" class="headerlink" title="final和const的区别"></a>final和const的区别</h3><ul>
<li>final可以开始不赋值，之后只能赋值一次</li>
<li>final不仅有const的编译时常量的特性，最重要的是它是<code>运行时常量</code>，并且final是惰性初始化，即在运行时第一次使用前才初始化</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> a = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<h1 id="flutter"><a href="#flutter" class="headerlink" title="flutter"></a>flutter</h1>]]></content>
      <categories>
        <category>web开发</category>
        <category>dart/flutter</category>
      </categories>
      <tags>
        <tag>dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P3884 [JLOI2009]二叉树问题</title>
    <url>/2021/08/26/38.%E6%B4%9B%E8%B0%B7-P3884%20%5BJLOI2009%5D%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3884">https://www.luogu.com.cn/problem/P3884</a></p>
<p>LCA：最近公共祖先</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, fa[<span class="number">1001</span>], root[<span class="number">1001</span>], son[<span class="number">1001</span>], depth[<span class="number">1001</span>], width[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;       <span class="comment">// 求最近公共祖先</span></span><br><span class="line"> <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x;                 <span class="comment">// 两个点如果相同，那么 LCA 就是它本身</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (depth[x] == depth[y]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lca</span>(fa[x], fa[y]); <span class="comment">// 如果两个点深度相同，就访问它们的父亲结点</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (depth[x] &lt; depth[y]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lca</span>(x, fa[y]);     <span class="comment">// 如果x的深度小于y的深度，就访问y的父亲结点，直到x y 深度相同</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lca</span>(fa[x], y);     <span class="comment">// 同理</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> cin &gt;&gt; n;</span><br><span class="line"> depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  cin &gt;&gt; root[i] &gt;&gt; son[i];</span><br><span class="line">  depth[son[i]] = depth[root[i]] + <span class="number">1</span>;  <span class="comment">// 子结点的深度 = 父亲结点的深度 + 1</span></span><br><span class="line">  fa[son[i]] = root[i];                <span class="comment">// 记录结点的父子关系</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> x, y;</span><br><span class="line"> cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"> <span class="keyword">int</span> max_depth = <span class="number">1</span>;     <span class="comment">// 记录深度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  max_depth = <span class="built_in">max</span>(max_depth, depth[i]);</span><br><span class="line">  width[depth[i]]++; <span class="comment">// 记录不同深度的结点个数</span></span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; max_depth &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">int</span> max_width = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  max_width = <span class="built_in">max</span>(max_width, width[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; max_width &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">int</span> k = <span class="built_in">lca</span>(x, y);     <span class="comment">//求 LCA 的结点序号</span></span><br><span class="line"> cout &lt;&lt; (depth[x] - depth[k]) * <span class="number">2</span> + (depth[y] - depth[k]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li><p>树的深度、宽度不一定要用递归的方式求</p>
<p>可以开depth数组记录每个结点所在的层数，并且子结点深度 = 父结点深度 + 1</p>
<p>之后遍历每个结点就可以得到最大深度</p>
</li>
<li><p>宽度同理，开width数组</p>
<p>遍历每个结点，巧妙的是，根据每个结点的depth值，算出每一层的宽度，并存入width不同的位置</p>
<p>之后遍历width数组就可以得到最大宽度</p>
</li>
<li><p>最后，还需要关注lca（最近公共祖先），根据代码注释来理解</p>
<p>据说这是一个暴力lca，应该可以有优化版本，在此谢过原题解作者</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P1322 logo语言</title>
    <url>/2021/08/26/37.%E6%B4%9B%E8%B0%B7-P1322%20logo%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1322">https://www.luogu.com.cn/problem/P1322</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; k;      <span class="comment">// s是未读完的字符串，k是前进或倒退的值</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            v = <span class="built_in">getchar</span>();  <span class="comment">// 读&#x27;[&#x27;</span></span><br><span class="line">            l += k * <span class="built_in">recursion</span>();</span><br><span class="line">            v = <span class="built_in">getchar</span>();  <span class="comment">// 读&#x27;]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            v = <span class="built_in">getchar</span>();</span><br><span class="line">            l -= k;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            v = <span class="built_in">getchar</span>();</span><br><span class="line">            l += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="built_in"><span class="keyword">int</span></span>(<span class="string">&#x27;]&#x27;</span>)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(<span class="built_in">recursion</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一道递归题，要点：</p>
<ul>
<li><p>使用cin &gt;&gt; s，getchar() 读掉多余的字符串</p>
</li>
<li><p>关键是如何解析字符串，得到想要的值</p>
</li>
<li><p>getchar在头文件<code>cstdio</code>中</p>
</li>
<li><p>绝对值函数<code>abs()</code>的运用</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P1381 单词背诵</title>
    <url>/2021/08/26/40.%E6%B4%9B%E8%B0%B7-P1381%20%E5%8D%95%E8%AF%8D%E8%83%8C%E8%AF%B5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1381">https://www.luogu.com.cn/problem/P1381</a></p>
<p>思路：</p>
<ul>
<li><p>首先，字符串哈希可以把一个字符串变成唯一的值，从而匹配每一个单词</p>
</li>
<li><p>尺取法：<a href="https://www.cnblogs.com/fusiwei/p/11313817.html">https://www.cnblogs.com/fusiwei/p/11313817.html</a></p>
<p>它可以避免暴力枚举左右端点，达到优化区间枚举的作用</p>
<p>本质就是设置l（左端点）和r（右端点），通过移动二者来求出最优解</p>
</li>
<li><p>对于本题，整个区间在不断向右移动，只要当前的区间内包括了所有单词就会退出循环，计算并更新ans的值，最后的ans即为最小值</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, ans = INF, l, r;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxm], appear[mod];</span><br><span class="line"><span class="keyword">char</span> input[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> need[mod], v[mod];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        ret *= p;</span><br><span class="line">        ret += s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        ret %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        a[i] = <span class="built_in">Hash</span>(input);</span><br><span class="line">        need[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        b[i] = <span class="built_in">Hash</span>(input);</span><br><span class="line">        <span class="keyword">if</span> (need[b[i]] &amp;&amp; !v[b[i]]) &#123;</span><br><span class="line">            <span class="comment">// 课文中的单词和要背的单词匹配</span></span><br><span class="line">            cnt++;</span><br><span class="line">            v[b[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);         <span class="comment">// 匹配的单词数</span></span><br><span class="line">    &#125;</span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; m) &#123;             <span class="comment">// 尺取法——右区间</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need[b[r]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!appear[b[r]]) &#123; <span class="comment">// 单词第一次出现</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                appear[b[r]]++;      <span class="comment">// 单词出现次数增加</span></span><br><span class="line">            &#125;</span><br><span class="line">            r++;                     <span class="comment">// 下一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!need[b[l]]) &#123;    <span class="comment">// 目前的单词不是需要背的</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; m) &#123;             <span class="comment">// 尺取法——左区间</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, r - l);   <span class="comment">// 更新ans</span></span><br><span class="line">            <span class="keyword">if</span> (appear[b[l]] == <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;               <span class="comment">// 让右指针继续右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (appear[b[l]] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                appear[b[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);  <span class="comment">//包含最多要背单词的最短的连续段的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>尺取法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P1090 合并果子</title>
    <url>/2021/08/26/41.%E6%B4%9B%E8%B0%B7-P1090%20%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1090">https://www.luogu.com.cn/problem/P1090</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// 第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象</span></span><br><span class="line"><span class="comment">// 优先队列，在入队时会自动作排序</span></span><br><span class="line"><span class="comment">// 使用greater，则容器中最小的元素会排在队列前面</span></span><br><span class="line">priority_queue&lt; <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pri_q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x,b1, b2;</span><br><span class="line"> ll sum = <span class="number">0</span>;</span><br><span class="line"> cin &gt;&gt; n;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  cin &gt;&gt; x;</span><br><span class="line">  pri_q.<span class="built_in">push</span>(x);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  b1 = pri_q.<span class="built_in">top</span>();         <span class="comment">// 返回优先队列中第一个元素的引用</span></span><br><span class="line">  pri_q.<span class="built_in">pop</span>();              <span class="comment">// 出队</span></span><br><span class="line">  b2 = pri_q.<span class="built_in">top</span>();</span><br><span class="line">  pri_q.<span class="built_in">pop</span>();</span><br><span class="line">  sum += (b1 + b2);</span><br><span class="line">  pri_q.<span class="built_in">push</span>(b1 + b2);      <span class="comment">// 把合并的堆放回队列</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本题使用了STL中的优先队列</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——AHOI2017初中组 rexp</title>
    <url>/2021/08/26/36.%E6%B4%9B%E8%B0%B7-AHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84rexp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3719">https://www.luogu.com.cn/problem/P3719</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c &amp;&amp; c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span>) j++;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) j = j + <span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;|&#x27;</span>) <span class="keyword">return</span> <span class="built_in">max</span>(j, <span class="built_in">p</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不应该被“先算带括号的序列”误导，只需把括号里的部分视作一个整体即可。</p>
<p>本题用到了递归调用栈的想法：</p>
<ul>
<li>如果遇到’a’，增加个数。</li>
<li>如果遇到’|’，在调用max的时候也会计算p(0)，这个p(0)是从’|’右侧开始算的，即’|’右侧的’a’的个数。</li>
<li>如果遇到’(‘，会从’(‘的右侧开始计算p(0)；遇到’)’，则返回这个括号内a的个数。如aa(aa)，得到2之后开始算(aa)里a的个数，得到4，再返回。</li>
</ul>
<p>就这样，把复杂的问题拆解成小规模问题，算出结果。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——UVA540 团体队列</title>
    <url>/2021/08/25/35.%E6%B4%9B%E8%B0%B7-UVA540%20%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/UVA540">https://www.luogu.com.cn/problem/UVA540</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1001</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; t &amp;&amp; t) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            cin &gt;&gt; n;</span><br><span class="line">            <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                v[x] = i;     <span class="comment">// 存队列编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Scenario #&quot;</span> &lt;&lt; m++ &lt;&lt; endl;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; team[MAX]; <span class="comment">// MAX支队伍</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; total;     <span class="comment">// 存队号</span></span><br><span class="line">        string op;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; op) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;STOP&quot;</span>)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;ENQUEUE&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                <span class="keyword">int</span> t = v[x]; <span class="comment">// 读取队列编号</span></span><br><span class="line">                <span class="keyword">if</span> (team[t].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    total.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                team[t].<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;DEQUEUE&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!total.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = total.<span class="built_in">front</span>();</span><br><span class="line">                    cout &lt;&lt; team[t].<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">                    team[t].<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (team[t].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 队伍空了，则将队伍编号从total中移除</span></span><br><span class="line">                        total.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>queue&lt;int&gt; team[MAX];</code>可以直接创建多个队列，把不同成员存入不同队列</li>
<li>使用map来建立队员到某队的映射，之后再读出队员的队号，再把他加入对应的队列</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记</title>
    <url>/2021/08/24/34.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>书籍 + 笔记 补充的形式完成计网的学习，不做无用功</p>
<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>运算器：</p>
<ul>
<li>ACC：==累加器==，存放操作数或运算结果</li>
<li>MQ：==乘商寄存器==，在乘除运算时，用于存放操作数和运算结果</li>
<li>X：统一的==操作数寄存器==，用于存放操作数</li>
<li>ALU：==算数逻辑单元==，实现算术运算和逻辑运算</li>
</ul>
<p>控制器：</p>
<ul>
<li>CU：==控制单元==，分析指令，给出控制信号</li>
<li>IR：==指令寄存器==，存放当前执行的指令</li>
<li>PC：==程序计数器==，存放下一条指令地址，有自动加1功能</li>
</ul>
<p>主存：</p>
<ul>
<li>存储体：存放指令和数据</li>
<li>MAR：==地址寄存器==，存放访存地址</li>
<li>MDR：==数据寄存器==，暂存要从存储器中读或写的信息</li>
</ul>
<h3 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h3><blockquote>
<p>(寄存器) 指该寄存器里边的内容，M指主存储器，M(MAR)指主存储器中MAR对应的地址所指明的数据，→MDR指存入MDR</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y = a * b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://z3.ax1x.com/2021/08/24/hA1j6P.png"></p>
<p>第一条指令（取数）：</p>
<p>取指令（#1~#4）：</p>
<ul>
<li><p>指令和变量的数据存放在存储体中</p>
</li>
<li><p>程序运行之前，PC指向0号位置（第一条指令的存储地址）</p>
</li>
<li><p>接下来，我们应当把该位置存放的指令取出来并执行</p>
<ul>
<li>PC存放的内容需要通过==地址总线==把它传送到MAR中 → MAR中的值变为0（即控制器向主存指明了接下来要访问的是0号地址所对应的数据，#1）</li>
<li>控制器通过==控制总线==告诉主存储器：这次进行的是读操作</li>
<li>主存储器根据MAR记录的地址，去存储体里找出0号地址对应的二进制数据，把它们放入MDR（现在MDR里存放的就是我们想要读取的第一条指令，#3）</li>
</ul>
</li>
<li><p>MDR中的指令通过==数据总线==放入IR（#4）</p>
</li>
<li><p>PC的值自动加1</p>
</li>
</ul>
<p>分析指令（#5）：</p>
<ul>
<li>指令的操作码传送至CU，CU分析后得知这是一条“取数”的指令（#5）</li>
</ul>
<p>执行取数指令（#6~#9）：</p>
<ul>
<li>把地址码所指明的内存单元中的数据取出，放入ACC<ul>
<li>把地址码放入主存的MAR中 → MAR = 5（#6）</li>
<li>主存储器根据这个地址去存储体中找出数据，放入MDR中（#8）</li>
<li>在CU指挥下，MDR中的数据被传到ACC（#9）</li>
</ul>
</li>
</ul>
<p>第二条指令（相乘）：</p>
<p>取指令（#1~#4）步骤相同</p>
<p>分析指令（#5）：</p>
<ul>
<li>指令的操作码传送至CU，CU分析后得知这是一条“乘法”的指令（#5）</li>
</ul>
<p>执行乘法指令（#6~#11）：</p>
<ul>
<li>取出b的步骤相同，但不同的是，b会从MDR传到MQ中（#9）</li>
<li>把a的值先放到X中（<strong>cpu执行乘法操作时，会先把被乘数放到X中，把乘数放到MQ中</strong>，#10）</li>
<li>CU通过控制线告诉ALU，让它进行乘法运算</li>
<li>ALU进行相乘操作，把结果放到ACC中（#11），如果数很大导致ACC存不下，就需要MQ的辅助存储：MQ存放乘法运算结果的低位</li>
</ul>
<p>第三条指令（相加）：</p>
<p>取指令（#1~#4）步骤相同</p>
<p>分析指令（#5）：“加法”指令</p>
<ul>
<li>取出c的步骤相同，但不同的是，c会从MDR传到X中（<strong>cpu执行加法操作时，ACC里先存入被加数，X中存放加数</strong>，#9）</li>
<li>CU通过控制线告诉ALU，让它进行加法运算</li>
<li>ALU执行相加操作，把结果再次存入ACC中</li>
</ul>
<p>第四条指令（存数）：</p>
<p>取指令（#1~#4）步骤相同</p>
<p>分析指令（#5）：“存数”指令</p>
<ul>
<li>将指令的地址码送到MAR，指明这次存入哪一个存储单元</li>
<li>把ACC中结果通过==数据总线==传入MDR中，此时MDR中保存了a*b+c的值，并且MAR指明了该值要存到地址为8的地方</li>
<li>CU通过==控制总线==告诉主存储器：这次进行存数操作</li>
<li>主存储器根据MAR指明的地址，把MDR中的数据放到相应位置当中（8号存储单元的值变为2*3+1 = 7）</li>
</ul>
<p>第五条指令（停机）：前边类似，最后执行操作系统相关的指令，停机</p>
]]></content>
      <categories>
        <category>计组</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>《学习JS数据结构与算法》读书笔记</title>
    <url>/2021/08/24/17.%E3%80%8A%E5%AD%A6%E4%B9%A0JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web开发</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器是如何工作的</title>
    <url>/2021/08/22/27.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>参考视频：<a href="https://www.bilibili.com/video/BV1x54y1B7RE">浏览器是如何运作的</a></p>
<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="浏览器的组成部分"><a href="#浏览器的组成部分" class="headerlink" title="浏览器的组成部分"></a>浏览器的组成部分</h2><p>浏览器分为以下几个部分：<code>用户界面</code>，<code>浏览器引擎</code>，<code>渲染引擎</code></p>
<p>其中：</p>
<ul>
<li>用户界面用于展示除标签页窗口之外的其它用户界面内容</li>
<li>渲染引擎负责渲染用户请求的页面内容</li>
<li>浏览器引擎用于在用户界面和渲染引擎之间传递数据</li>
</ul>
<p>渲染器下有很多小的功能模块，如负责网络请求的<code>网络模块</code>，用于解析和执行js的<code>js解释器</code>，，还有<code>数据存储持久层</code>（帮助浏览器存储各种数据，如cookie）</p>
<blockquote>
<p><strong>渲染引擎是浏览器的核心，把它称作浏览器的内核</strong></p>
</blockquote>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><center>
    <img src="https://img-blog.csdnimg.cn/20210311162244195.png" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<p>Blink是基于Webkit改造的</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><center>
    <img src="https://img-blog.csdnimg.cn/20210311164614193.png" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<ul>
<li><p>当我们启动某个程序时，就会创建一个<code>进程</code>来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里</p>
</li>
<li><p>当应用关闭时，该内存空间就会被回收，进程可以启动更多的进程来执行任务</p>
</li>
<li><p>两个进程间相互独立，如果需要两个进程空间需要传递某些数据，则使用<code>进程间通信管道IPC</code>传递</p>
</li>
<li><p>进程可以将任务分成更多细小的任务，然后通过创建多个线程并行执行不同的任务</p>
</li>
<li><p>同一进程下的线程是可以直接通信共享数据的</p>
</li>
</ul>
<h3 id="各进程的作用"><a href="#各进程的作用" class="headerlink" title="各进程的作用"></a>各进程的作用</h3><center>
    <img src="https://img-blog.csdnimg.cn/20210311164620571.jpg" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<ul>
<li><p><code>浏览器进程</code>负责控制chrome浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其它进程协调工作</p>
</li>
<li><p><code>网络进程</code>负责发起接受网络请求</p>
</li>
<li><p><code>GPU进程</code>负责整个浏览器界面的渲染</p>
</li>
<li><p><code>插件进程</code> 负责控制网站使用的所有插件（此处插件是flash等，不是chrome安装的拓展插件）</p>
</li>
<li><p><code>渲染器进程</code>用来控制显示tab标签内的所有内容</p>
</li>
</ul>
<h1 id="从输入网址到加载网页的过程"><a href="#从输入网址到加载网页的过程" class="headerlink" title="从输入网址到加载网页的过程"></a>从输入网址到加载网页的过程</h1><center>
    <img src="https://img-blog.csdnimg.cn/20210311164839647.jpg" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>

<p>浏览器默认情况下，为每个标签页都创建一个进程</p>
<h2 id="输入网址"><a href="#输入网址" class="headerlink" title="输入网址"></a>输入网址</h2><p>在地址栏输入地址时，<code>浏览器进程的UI线程</code>会捕捉你的输入内容</p>
<p>如果访问的是网址，则UI线程会启动一个<code>网络线程</code>来请求DNS进行域名解析，接着开始链接服务器获取数据</p>
<p>如果输入不是网址而是一串关键词，浏览器判断你要搜索，就会使用<code>默认配置的搜索引擎</code>来查询</p>
<p>当网络线程获取到数据后，会通过<code>SafeBrowsing</code>来检查站点是否是恶意站点，如果是，则提示警告页面（可强行继续访问）</p>
<blockquote>
<p>SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全（比如通过查看该站点IP是否在谷歌黑名单之内）</p>
</blockquote>
<p>当返回数据准备完毕并且安全校验通过时，网络线程会通知UI线程:自己已经准备好，然后UI线程会创建一个渲染器进程来渲染页面</p>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="获得DOM树"><a href="#获得DOM树" class="headerlink" title="获得DOM树"></a>获得DOM树</h3><p>浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程</p>
<p>渲染器进程接收到的数据也就是html，<strong>渲染器进程的核心任务就是把html css js image等资源渲染成用户可以交互的web页面</strong></p>
<p>渲染器进程的<code>主线程</code>将html进行解析，构造DOM数据结构（DOM是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API）</p>
<p>html首先经过<code>tokeniser标记化</code>，通过<code>词法分析</code>将输入的html内容解析成多个标记，根据识别后的标记进行<code>DOM树构造</code>，在DOM树构造过程中会创建document对象，然后以document为根节点的DOM树不断进行修改，向其中添加各种元素</p>
<p>html代码中往往会引入一些额外的资源，图片和CSS这些资源需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞html的解析，不会影响DOM的生成</p>
<p>但当HTML解析过程中遇到script标签，将停止html解析流程，转而去加载解析并且执行JS，这是因为浏览器不知道JS执行是否会改变当前页面的HTML结构（JS代码可以用document.write 来修改html），这就是要把script标签放在合适的位置/或者使用async或defer属性来异步加载执行JS 的原因</p>
<p>HTML解析完成之后，获得DOM树，但我们还不知道其上每个结点长什么样子</p>
<h3 id="获得Layout树"><a href="#获得Layout树" class="headerlink" title="获得Layout树"></a>获得Layout树</h3><p>主线程需要解析CSS，并确定每个DOM结点的计算样式，即使没有提供CSS样式，浏览器也会有自己默认的样式表</p>
<p>我们接下来需要知道每个结点需要放在页面上的哪个位置，也就是结点的坐标以及该结点需要占用多大的区域，这个阶段被成为layout布局</p>
<p>主线程通过遍历dom和计算好的样式来生成Layout树，Layout树上的每个结点都记录了x，y坐标和边框尺寸</p>
<blockquote>
<p>注意DOM树和Layout树并不是一一对应的，设置了display:none 的结点不会出现在Layout树上，而在before伪类中添加了content值的元素，content里的内容会出现在Layout树上，而不会出现在DOM树里，这是因为DOM树是通过html解析获得，并不关系样式，而Layout树是根据DOM和计算好的样式来生成的，<strong>Layout树是和最后展示在屏幕上的结点是对应的</strong></p>
</blockquote>
<h3 id="栅格化与合成"><a href="#栅格化与合成" class="headerlink" title="栅格化与合成"></a>栅格化与合成</h3><p>我们还需要知道以什么样的顺序绘制这个结点</p>
<p>举例来说，z-index属性会影响结点绘制的层级关系，如果我们按照dom的层级结构来绘制页面，则会导致错误的渲染，所以为了保证在屏幕上展示正确的层级，主线程遍历Layout树创建一个绘制记录表，该表记录了绘制的顺序，这个阶段被成为<code>绘制（paint）</code></p>
<p>知道绘制顺序后，现在该把这些信息转化成像素点，显示在屏幕上了，这种行为称为<code>栅格化</code>，chrome使用较为复杂的栅格化流程，叫做<code>合成</code></p>
<p>合成是一种将页面上的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独进行合成页面的技术，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可</p>
<p><strong>主线程遍历Layout树生成Layer树</strong>，当Layer树生成完毕和绘制顺序确定后，主线程将这些信息传递给<code>合成器线程</code>，合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，合成器线程将它们切分成许多<code>图块</code>，然后将每个图块发送给栅格化线程，栅格化线程栅格化每个图块，并将它们存储在<code>GPU内存</code>中，当图块栅格化完成后，合成器线程将收集称为<code>draw quads</code>的图块信息，这些信息里记录了图块在内存中的位置，和在页面的哪个位置绘制图块的信息</p>
<p>根据这些信息合成器线程生成了一个<code>合成器帧</code>，然后合成器帧通过IPC传送给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上，当页面发生变化（比如滚动页面），都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上</p>
<h3 id="重排重绘和卡顿现象"><a href="#重排重绘和卡顿现象" class="headerlink" title="重排重绘和卡顿现象"></a>重排重绘和卡顿现象</h3><ul>
<li><p>重排：当改变一个元素的尺寸位置属性时，会重新进行样式计算，布局、绘制以及后面的所有流程</p>
</li>
<li><p>重绘：当改变元素的颜色属性时，不会重新触发布局，但还剩会触发样式计算和绘制</p>
</li>
</ul>
<p>重排和重绘都会占用主线程，JS也运行在主线程</p>
<p>页面的卡顿现象：<br>当页面以每秒60帧的刷新率（每帧16ms）时才不会感到卡顿</p>
<p>重排重绘和JS运行会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作</p>
<p>如果在运行动画时还有大量的JS任务需要执行，由于布局、绘制和JS执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，如果还有剩余时间，JS就会拿到主线程的使用权，如果JS执行时间过长，就会导致在下一帧开始时JS没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面动画的卡顿</p>
<h3 id="卡顿的优化方案"><a href="#卡顿的优化方案" class="headerlink" title="卡顿的优化方案"></a>卡顿的优化方案</h3><ol>
<li><p>requestAnimationFrame()<br>这个方法会在每一帧被调用，通过API的回调，我们可以把JS运行任务分成一些更小的任务块，分到每一帧，在每一帧时间冲完前暂停JS执行，归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制</p>
</li>
<li><p>由于栅格化的整个流程是不占用主线程的，只在合成器线程和栅格线程中运行，这就意味着它无需和JS抢夺主线程，通过transform属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程中，所以不会受到主线程中JS执行的影响</p>
</li>
</ol>
<p>用transform实现的动画由于不需要经过布局绘制，样式计算等操作，所以节省了很多运算时间</p>
]]></content>
      <categories>
        <category>web开发</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>JS继承详解</title>
    <url>/2021/08/22/28.JS%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>虽然ES6的Class继承确实很方便，但是ES5的继承还是要好好了解一下：</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1J54y1y7u9?t=807">详解JS继承（超级详细且附实例）</a></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>构造函数的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//实例引用属性(该属性，强调复用，需要共享)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：数组和方法都属于’实例引用属性’，但是数组强调私有不共享，方法需要复用共享。在构造函数中，很少有数组形式的引用属性，大部分情况都是：基本属性+方法。</p>
<p>在构造函数中，为了属性(实例基本属性)的私有性、方法(实例引用属性)的复用共享，提倡：将属性封装在构造函数中，将方法定义在原型对象上。</p>
<p>修正constructor指向的意义：任何一个prototype对象都有一个constructor属性，指向它的构造函数(它本身)，更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。<br>在new之后，constructor会指向父类构造函数，如果我们要生成子类构造函数的实例，这些实例的constructor属性会指向父类构造函数，然而它们是靠子类构造函数生成的，constructor属性应该指向子类构造函数。因此，不修改constructor指向的话，会导致继承链的紊乱。</p>
<p>(以上来自阮一峰博客，我目前不清楚继承链紊乱会引起什么后果，最起码在我看来，即便不修改constructor指向，好像也没什么影响？)</p>
<p>文档的原作者说：要修复constructor指向，原因是：不能判断子类实例的直接构造函数，到底是子类构造函数还是父类构造函数</p>
<h1 id="JS继承方式"><a href="#JS继承方式" class="headerlink" title="JS继承方式"></a>JS继承方式</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ul>
<li>核心：将父类实例作为子类原型</li>
<li>优点：方法复用<br>方法定义在父类的原型上，可以复用父类构造函数的方法，比如say方法。</li>
<li>缺点：<ul>
<li>创建子类实例时，无法传父类参数</li>
<li>子类实例共享</li>
<li>继承单一，无法实现多继承</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name || <span class="string">&#x27;父亲&#x27;</span>;	实例基本属性(该属性，强调私有，不共享)</span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">like</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();	<span class="comment">//核心，但此时Child.prototype.constructor == Parent;</span></span><br><span class="line">Child.prototype.constructor = Child;	<span class="comment">//修正constructor指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="comment">//优点：共享父类构造函数的say方法</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.say(),boy2.say(),boy1.say === boy2.say);	<span class="comment">//hello,hello,true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点1：不能传入父类的参数(比如name)，只能传子类有的参数like</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.name,boy2.name,boy1.name === boy);	<span class="comment">//父亲，父亲，true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点2：子类实例共享了父类构造函数的引用属性，比如arr属性</span></span><br><span class="line">boy1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boy2.arr);<span class="comment">//[1,2];</span></span><br><span class="line"><span class="comment">//修改了boy1的arr属性，boy2的arr属性也会变化，</span></span><br><span class="line"><span class="comment">//因为两个实例的原型上(Child.prototype)有了父类构造函数的实例属性arr，所以只要修改了boy1.arr，boy2.arr也变化</span></span><br></pre></td></tr></table></figure>

<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><ul>
<li>核心：借用父类构造函数来增强子类实例，等于是复制父类的实例属性给子类</li>
<li>优点：实例之间独立<ul>
<li>创建子类实例，可以向父类构造函数传参</li>
<li>子类实例不共享父类构造函数的引用属性，如arr</li>
<li>可实现多继承（通过多个call或apply继承多个父类）</li>
</ul>
</li>
<li>缺点：<ul>
<li>父类方法不能复用<br>由于方法在父构造函数中定义，导致方法不能复用（每次创建子类实例都要创建一遍方法）</li>
<li>子类实例继承不了父类原型上的属性，因为没有用到原型</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];	(该属性，强调私有)</span><br><span class="line"> <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//实例引用属性(该属性，强调复用，需要共享)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function Child(name,like)&#123;</span></span><br><span class="line"><span class="string">	Parent.call(this,name);	//核心，拷贝了父类的实例属性和方法</span></span><br><span class="line"><span class="string">	this.like = like;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">let boy1 = new Child(&#x27;</span>小刚<span class="string">&#x27;,&#x27;</span>apple<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">let boy2 = new Child(&#x27;</span>小明<span class="string">&#x27;,&#x27;</span>orange<span class="string">&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//优点1：可向父类构造函数传参</span></span><br><span class="line"><span class="string">console.log(boy1.name,boy2.name);	//小刚，小明</span></span><br><span class="line"><span class="string">//优点2：不共享父类构造函数的引用属性</span></span><br><span class="line"><span class="string">boy1.arr.push(2);</span></span><br><span class="line"><span class="string">console.log(boy1.arr,boy2.arr);	//[1,2]，[1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//缺点1：方法不能复用</span></span><br><span class="line"><span class="string">console.log(boy1.say === boy2.say);	//false (说明boy1和boy2的say方法独立，不是共享的)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//缺点2：不能继承父类原型上的方法</span></span><br><span class="line"><span class="string">Parent.prototype.walk = function()&#123;</span></span><br><span class="line"><span class="string">	console.log(&#x27;</span>我会走路<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">boy1.walk;	//undefined(说明实例不能获得父类原型上的方法)</span></span><br></pre></td></tr></table></figure>


<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><ul>
<li>核心：通过调用父类构造函数，继承父类属性并保留传参的优点；然后通过将父类实例作为子类原型，实现函数复用。</li>
<li>优点：<ul>
<li>保留方法1的优点：父类的方法定义在原型对象上，可以实现方法复用</li>
<li>保留方法2的优点：创建子类实例，可以向父类构造函数传参；并且不共享父类的引用属性，如arr</li>
</ul>
</li>
<li>缺点：由于调用了2次父类的构造方法，会存在一份多余的父类实例属性<br>原因：第一次Parent.call(this)从父类拷贝一份父类实例属性，作为子类的实例属性，第二次Child.prototype = new Parent()创建父类实例作为子类原型，(Child.prototype中的父类属性和方法会被第一次拷贝来的实例属性屏蔽掉，所以多余←这句话没理解)<br>我的理解是，第二次new Parent的时候也执行了Parent构造函数，但是因为没有传参，导致子类实例对象的_ <em>proto</em> <em>的</em> <em>proto</em> _中，一部分属性为undefined<center>
  <img src="https://img-blog.csdnimg.cn/20210209190344284.jpg" width=" 50%">
  <br>
  <font size="3" face="楷体" color="#999"><u>注意name：undefined</u></font>
</center></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span><br><span class="line"> Parent.call(<span class="built_in">this</span>,name);	<span class="comment">//核心，第二次</span></span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">//核心，第一次</span></span><br><span class="line">Child.prototype.constructor = Child;	<span class="comment">//修正constructor指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child(<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//优点1：可以复用父类原型上的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.say === boy2.say);	<span class="literal">true</span></span><br><span class="line"><span class="comment">//优点2：可以向父类构造函数传参数，且不共享父类引用属性</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.name,boy1.like);	<span class="comment">//小刚，apple</span></span><br><span class="line"></span><br><span class="line">boy1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boy1.arr,boy2.arr);	<span class="comment">//[1,2]，[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：由于调用了2次父类的构造方法，会存在一份多余的父类实例属性</span></span><br></pre></td></tr></table></figure>

<h2 id="组合继承优化"><a href="#组合继承优化" class="headerlink" title="组合继承优化"></a>组合继承优化</h2><ul>
<li><p>核心：通过这种方式，砍掉父类的实例属性，这样在调用父类的构造函数的时候，就不会初始化两次实例，避免组合继承的缺点</p>
</li>
<li><p>优点：</p>
<ul>
<li>只调用一次父类构造函数</li>
<li>保留组合继承的优点</li>
</ul>
</li>
<li><p>缺点：修正构造函数的指向之后，父类实例的构造函数指向，同时也发生变化(这是我们不希望的)</p>
</li>
</ul>
<p>具体原因：因为是通过原型来实现继承的，Child.prototype上面没有constructor属性，就会往上找，这样就找到了Parent.prototype上面的constructor属性；当修改了子类实例的constructor属性，所有的constructor的指向都会发生变化。（我觉得这个原因说得不对，constructor属性指向自身，Child上有constructor属性，真正原因可能是因为constructor是引用数据类型，所以修改一方才会影响另一方）</p>
<center>
    <img src="https://img-blog.csdnimg.cn/20210209185724235.jpg" width=" 50%">
    <br>
    <font size="3" face="楷体" color="#999"><u>之前的name:undefined 消失了，改进成功</u></font>
</center>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span><br><span class="line"> Parent.call(<span class="built_in">this</span>,name);	<span class="comment">//核心</span></span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = Parent.prototype	<span class="comment">//核心，子类原型和父类原型，实际上是同一个</span></span><br><span class="line">Child.prototype.constructor = Child;<span class="comment">//修复代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child(<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Parent(<span class="string">&#x27;小爸爸&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//优点不演示</span></span><br><span class="line"><span class="comment">//缺点1：当修复子类构造函数的指向后，父类实例的构造函数指向也会跟着变了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(boy1.constructor);<span class="comment">//没修复之前：Parent</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.constructor,p1.constructor);	<span class="comment">//修复之后：Child,Child 这就是问题所在</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>完美的继承方案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span><br><span class="line"> Parent.call(<span class="built_in">this</span>,name);	<span class="comment">//核心</span></span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心 通过创建中间对象，子类原型和父类原型就会隔离开，不再是同一个，有效避免了方式4的缺点</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line"></span><br><span class="line">Child.prototype.constructor = Child;<span class="comment">//修复代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child(<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Parent(<span class="string">&#x27;小爸爸&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(boy1.constructor,p1.constructor);	<span class="comment">//修复之后：Child,Parent</span></span><br></pre></td></tr></table></figure>

<p>其中，Object.create()函数等价为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是中间那段核心代码可改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = object(Parent);</span><br><span class="line"></span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS常见效果实现</title>
    <url>/2021/08/22/33.CSS%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="旋转立方体"><a href="#旋转立方体" class="headerlink" title="旋转立方体"></a>旋转立方体</h1><p>强调：</p>
<ul>
<li>要对外层容器设置 transform-style:preserve-3d;  否则不能显示3d效果。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class=