<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《你不知道的JS》读书笔记</title>
    <url>/2021/05/24/01.%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="最佳实践-原则"><a href="#最佳实践-原则" class="headerlink" title="最佳实践/原则"></a>最佳实践/原则</h1><ul>
<li>最小特权原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计</li>
<li>始终给函数表达式命名</li>
<li>对不再必要的全局变量或全局对象的属性，将其设置为null</li>
</ul>
<h1 id="上卷"><a href="#上卷" class="headerlink" title="上卷"></a>上卷</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><a href="https://blog.csdn.net/weixin_44659458/article/details/109356598">1.Javascript引擎，编译器，作用域三者之间的关系及LHS和RHS的区别</a><br><a href="https://www.jianshu.com/p/36f5bfc6b7e6/">2.聊聊JavaScript 编译器，引擎，作用域</a></p>
<h3 id="JS的编译"><a href="#JS的编译" class="headerlink" title="JS的编译"></a>JS的编译</h3><p>JS代码片在执行前要先编译：它的编译过程（通常）是在实际执行前进行的，而且也不会产生可移植的编译结果。</p>
<p>通常的编译步骤：</p>
<ol>
<li><code>分词与词法分析</code>：把输入的字符串分解为一些对编程语言有意义的代码块（词法单元）。</li>
<li><code>解析与语法分析</code>：将上一步的词法单元集合分析并最终转换为一个由元素逐级嵌套所组成的代表了程序语法结构的树，称为<code>抽象语法树</code>（Abstract Syntax Tree，AST）。</li>
<li><code>代码生成</code>：将上一步的AST转换为可执行代码。</li>
</ol>
<p>由于JS编译的特殊性，编译执行效率就要比一般静态语言敏感的多，故而也非常复杂。JS引擎在这一部分做了非常多的优化，一是针对语法分析和代码生成阶段进行优化（例如针对冗余元素进行优化等），目的是提高编译后的执行效率。二是针对编译过程进行优化（如JIT，延迟编译甚至重编译），目的是缩短编译过程，保证性能最佳。</p>
<h4 id="引擎、编译器和作用域"><a href="#引擎、编译器和作用域" class="headerlink" title="引擎、编译器和作用域"></a>引擎、编译器和作用域</h4><p>引擎：   负责整个Javascript程序的编译及执行过程。<br>编译器：负责语法分析及代码生成。<br>作用域：负责收集并维护有所有声明的标识符组成的一系列查询。</p>
<h4 id="var-a-1的编译过程"><a href="#var-a-1的编译过程" class="headerlink" title="var a=1的编译过程"></a>var a=1的编译过程</h4><ol>
<li><code>编译器</code>首先会将这段代码分解成词法单元，然后将词法单元解析成树结构。</li>
<li>对词法单元进行解析，解析到var a时，<code>编译器</code>会询问作用域是否存在一个变量名为a在同一作用域的集合中。如果有，编译器就忽略此声明。反之，在要求的作用域下声明变量。<br>第三步：生成可以运行代码(=1)给<code>引擎</code>执行，生成代码的这个过程就涉及到LHS和RHS两种赋值概念。<br>第四步：<code>引擎</code>运行编译器生成的代码时，会询问<code>作用域</code>是否存在在当前作用域下变量名为a的集合，如果没有，则在向上一级作用域查找变量名a。如果有，引擎则对变量名为a的集合赋值。</li>
</ol>
<h4 id="LHS和RHS"><a href="#LHS和RHS" class="headerlink" title="LHS和RHS"></a>LHS和RHS</h4><p>LHS（left-hand-side）：找到变量的容器本身，从而可以对其赋值<br>RHS（rigjt-hand-side）：查找某个变量的值</p>
<h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><h4 id="最小特权原则"><a href="#最小特权原则" class="headerlink" title="最小特权原则"></a>最小特权原则</h4><p>最小特权原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计</p>
<h4 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h4><h5 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h5><p>（可以实践）</p>
<p>在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会称为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p>
<h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>把IIFE当作函数调用并传递参数进去，可以改进代码风格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"><span class="built_in">global</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">//3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">global</span>.a);  <span class="comment">//2</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>好处：在代码风格上对全局对象的引用，变得比引用一个没有”全局”字样的变量更加清晰</p>
<p>倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去<br>（思考：这种方式或许能在某处派上用场）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">def</span>) </span>&#123;</span><br><span class="line">  def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"><span class="built_in">global</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">//3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">global</span>.a);  <span class="comment">//2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="with和try-catch（放着）"><a href="#with和try-catch（放着）" class="headerlink" title="with和try/catch（放着）"></a>with和try/catch（放着）</h4><h4 id="垃圾回收（补充）"><a href="#垃圾回收（补充）" class="headerlink" title="垃圾回收（补充）"></a>垃圾回收（补充）</h4><p><a href="https://segmentfault.com/a/1190000018605776">前端面试：谈谈 JS 垃圾回收机制</a><br><a href="https://www.yuque.com/bingyan-studio/isz3cs/up15ft">浏览器垃圾回收与内存管理</a></p>
<p>引用计数法由于循环引用问题而遭到废弃，此处只记录标记清理法：</p>
<ul>
<li>垃圾回收程序运行的时候，会标记内存中存储的所有变量</li>
<li>程序会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的，因为任何在上下文中的变量都访问不到它们了</li>
<li>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存</li>
</ul>
<p>关于垃圾回收更详细的内容，请猛戳第二篇博文</p>
<h5 id="V8垃圾回收"><a href="#V8垃圾回收" class="headerlink" title="V8垃圾回收"></a>V8垃圾回收</h5><p>V8三种回收算法的比较：</p>
<table>
<thead>
<tr>
<th>回收算法</th>
<th>标记清除（Mark-Sweep）</th>
<th>标记整理</th>
<th>Scavange</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（有碎片）</td>
<td>少（无碎片）</td>
<td>双倍空间（无碎片）</td>
</tr>
<tr>
<td>是否移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="模块（放着）"><a href="#模块（放着）" class="headerlink" title="模块（放着）"></a>模块（放着）</h4><p><a href="https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a><br><a href="https://blog.csdn.net/m0_51235736/article/details/116904464">前端模块化详解-笔记</a></p>
<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><ul>
<li>词法作用域：在写代码或者说定义时确定，关注函数在何处声明</li>
<li>动态作用域：在运行时确定，关注函数在何处调用，作用域基于调用栈</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="往日结论"><a href="#往日结论" class="headerlink" title="往日结论"></a>往日结论</h3><p>先说以前记的结论：<br>1.以函数形式调用时，this永远都是window<br>2.以方法的形式调用时，this是调用方法的对象<br>3.以构造函数的形式调用时，this是新创建的那个对象<br>4.使用call和apply调用时，this是指定的那个对象</p>
<h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><ul>
<li>this在运行时进行绑定，它的上下文取决于函数调用时的各种条件。</li>
<li>当一个函数被调用时，会创建一个活动记录（执行上下文），它包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this是执行上下文的一个属性，会在函数执行的过程中用到</li>
</ul>
<h3 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h3><p>显示强制绑定：一旦绑定this后不可以再通过call或apply修改this，比如ES添加的bind</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ol>
<li>new（构造调用）</li>
<li>显示绑定/硬绑定调用（call、apply/bind）</li>
<li>隐式绑定（对象的方法）</li>
<li>默认绑定（全局对象）</li>
</ol>
<p>对默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this会被绑定到全局对象。</p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><h5 id="将null或undefined作为绑定对象"><a href="#将null或undefined作为绑定对象" class="headerlink" title="将null或undefined作为绑定对象"></a>将null或undefined作为绑定对象</h5><p>这些情况下，函数并不关心this是什么，传入的null仅仅作为占位值</p>
<p>情况一：展开数组；情况二：柯里化（减少返回的函数要求传入参数的个数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span> + a + <span class="string">&quot;, b:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数组展开</span></span><br><span class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// a: 2, b: 3</span></span><br><span class="line"><span class="comment">//ES6中可以用...操作符来替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.bind(<span class="literal">null</span>, <span class="number">2</span>);<span class="comment">//对bar，以后就只用传入b这个参数了</span></span><br><span class="line">bar(<span class="number">3</span>);  <span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>

<p>以上的方式有一定安全隐患，并不推荐</p>
<h5 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h5><p>创建空的非委托对象，即DMZ（非军事区）对象</p>
<blockquote>
<p>Object.create(null)和{}很像，但是并不会创建Object.prototype这个委托，因此比{}更空。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span> + a + <span class="string">&quot;, b&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们的DMZ空对象，使用空集符号可以增强可读性</span></span><br><span class="line"><span class="keyword">let</span> Ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数组展开</span></span><br><span class="line">foo.apply(Ø, [<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// a: 2, b: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.bind(Ø, <span class="number">2</span>);<span class="comment">//对bar，以后就只用传入b这个参数了</span></span><br><span class="line">bar(<span class="number">3</span>);  <span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>
<h5 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h5><p>创建函数的间接引用时，调用该函数会应用默认绑定规则，间接引用最容易在赋值时发生</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="keyword">let</span> p = &#123;<span class="attr">a</span>: <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值表达式p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或o.foo() </span></span><br></pre></td></tr></table></figure>
<h4 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h4><p>由以上可知，硬绑定后隐式绑定或显示绑定会无效</p>
<p>软绑定：可以给默认绑定指定一个全局对象和undefined以外的值，同时保留隐式绑定或者显式绑定修改this的能力</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一段代码，暂时不能完全看懂</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 捕获所有curried参数</span></span><br><span class="line">    <span class="keyword">let</span> curried = [].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(</span><br><span class="line">        (!<span class="built_in">this</span> || <span class="built_in">this</span> === (<span class="built_in">window</span> || <span class="built_in">global</span>)) ? </span><br><span class="line">          obj: <span class="built_in">this</span>,</span><br><span class="line">          curried.concat.apply(curried, <span class="built_in">arguments</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">    bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;name: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>&#125;, obj2 = &#123;<span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>&#125;, obj3 = &#123;<span class="attr">name</span>: <span class="string">&quot;obj3&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fooOBJ = foo.softBind(obj); <span class="comment">//软绑定，此时默认绑定了obj对象</span></span><br><span class="line">fooOBJ(); <span class="comment">// name: obj</span></span><br><span class="line">obj2.foo = foo.softBind(obj); <span class="comment">//软绑定，此时默认绑定了obj对象</span></span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2 此时隐式绑定仍然生效</span></span><br><span class="line">fooOBJ.call(obj3); <span class="comment">// name: obj3 此时显示绑定仍然生效</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj2.foo, <span class="number">10</span>); <span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数不使用this的四种标准规则，而是根据外层作用域来决定this</p>
<p>箭头函数的绑定无法被修改，new也不行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = foo.call(obj1); </span><br><span class="line"><span class="comment">//foo的this被绑定为obj1，由this词法，bar的this受到foo的影响，也是obj1</span></span><br><span class="line">bar.call(obj2); <span class="comment">// 2， 一旦绑定，就不可被修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中卷"><a href="#中卷" class="headerlink" title="中卷"></a>中卷</h1><h1 id="下卷"><a href="#下卷" class="headerlink" title="下卷"></a>下卷</h1>]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack笔记</title>
    <url>/2021/05/24/02.webpack%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="简介（P2）"><a href="#简介（P2）" class="headerlink" title="简介（P2）"></a>简介（P2）</h1><ul>
<li>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。</li>
<li>在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。</li>
<li>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</li>
</ul>
<h1 id="五个核心概念（P3）"><a href="#五个核心概念（P3）" class="headerlink" title="五个核心概念（P3）"></a>五个核心概念（P3）</h1><ul>
<li>Entry：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图</li>
<li>Output：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名</li>
<li>Loader： 让 webpack 能够去处理那些非JavaScript文件（翻译）</li>
<li>Plugins：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，<br>一直到重新定义环境中的变量等。</li>
<li>Mode：指示 webpack 使用相应模式的配置，分为development和production</li>
</ul>
<h1 id="初体验（P4）"><a href="#初体验（P4）" class="headerlink" title="初体验（P4）"></a>初体验（P4）</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>新建文件夹：webpack初体验</li>
<li>npm init</li>
<li>npm i webpack webpack-cli -g</li>
<li>npm i webpack webpack-cli -D</li>
</ul>
<h2 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h2><h3 id="设置powershell"><a href="#设置powershell" class="headerlink" title="设置powershell"></a>设置powershell</h3><p>在执行以下指令以前，先设置powershell：<a href="https://blog.csdn.net/Piconjo/article/details/105716451">解决webpack : 无法加载文件 C:\Users\XXX\AppData\Roaming\npm\webpack.ps1因为在此系统上禁止运行脚本</a></p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><img src="https://img-blog.csdnimg.cn/20210509105459275.jpg#pic_center"></p>
<h3 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h3><ul>
<li>开发环境指令：webpack src/index.js -o ./build/built.js –mode=development<br>功能：webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成<br>浏览器能识别的语法。</li>
<li>生产环境指令：webpack src/index.js -o ./build/built.js –mode=production<br>功能：在开发配置功能上多一个功能，压缩代码。</li>
</ul>
<blockquote>
<p>备注：老师执行完开发环境指令后，在build目录下生成了built.js文件，而我执行完指令后，在build目录下生成了built.js目录，在该目录下有main.js文件，我猜测是配置方面的问题，因此我使用的指令是webpack src/index.js -o ./build –mode=development</p>
</blockquote>
<h3 id="实践（js）"><a href="#实践（js）" class="headerlink" title="实践（js）"></a>实践（js）</h3><p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>main.js(development):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ATTENTION: The &quot;eval&quot; devtool has been used (maybe by default in mode: &quot;development&quot;).</span></span><br><span class="line"><span class="comment"> * This devtool is neither made for production nor for readable output files.</span></span><br><span class="line"><span class="comment"> * It uses &quot;eval()&quot; calls to create a separate source file in the browser devtools.</span></span><br><span class="line"><span class="comment"> * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span></span><br><span class="line"><span class="comment"> * or disable the default devtool with &quot;devtool: false&quot;.</span></span><br><span class="line"><span class="comment"> * If you are looking for production-ready output files, see mode: &quot;production&quot; (https://webpack.js.org/configuration/mode/).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span>   <span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function add(x,y)&#123;\r\n  return x+y;\r\n&#125;\r\nconsole.log(add(1,2));\n\n//# sourceURL=webpack://webpack_test/./src/index.js?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span>   &#125;);</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span>   </span><br><span class="line"><span class="comment">/******/</span>   <span class="comment">// startup</span></span><br><span class="line"><span class="comment">/******/</span>   <span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span>   <span class="comment">// This entry module can&#x27;t be inlined because the eval devtool is used.</span></span><br><span class="line"><span class="comment">/******/</span>   <span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span>   __webpack_modules__[<span class="string">&quot;./src/index.js&quot;</span>]();</span><br><span class="line"><span class="comment">/******/</span>   </span><br><span class="line"><span class="comment">/******/</span> &#125;)()</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>main.js(production):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//这里和老师的也不一样</span></span><br></pre></td></tr></table></figure>
<p>无论是开发环境产生的main.js，还是生产环境产生的main.js，都可以运行（node或浏览器内）：<br><img src="https://img-blog.csdnimg.cn/20210509104516739.jpg#pic_center"></p>
<h3 id="实践（json）"><a href="#实践（json）" class="headerlink" title="实践（json）"></a>实践（json）</h3><p>data.json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改index.js，再打包生成main.js文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&#x27;./data.json&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210509105129855.jpg#pic_center"><br>还是可以正常执行，说明webpack可以处理json</p>
<h1 id="打包样式资源（P5）"><a href="#打包样式资源（P5）" class="headerlink" title="打包样式资源（P5）"></a>打包样式资源（P5）</h1><p>注意，所有loader都需要用npm下载</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>webpack.config.js是webpack的配置文件</li>
<li>作用: 指示 webpack 干哪些活（当运行 webpack 指令时，会加载里面的配置）</li>
</ul>
<p>所有构建工具都是基于nodejs平台运行的，模块化默认采用commonjs。<br>（模块化分为ES6模块和commonjs）</p>
<p><img src="https://img-blog.csdnimg.cn/20210509163511553.jpg#pic_center"><br>配置文件和src目录在同一层级</p>
<p>配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法（不懂照做，以后深入学node）</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="comment">// __dirname nodejs的变量，代表当前文件的目录绝对路径（不懂照做）</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader的配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 匹配哪些文件（正则表达式）</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上 依次执行（很重要）</span></span><br><span class="line">          <span class="comment">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将less文件编译成css文件</span></span><br><span class="line">          <span class="comment">// 需要下载 less-loader和less</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugins的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 详细plugins的配置</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// mode: &#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h2><p>此处以css为主，就不写less文件了</p>
<p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入样式资源</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.less&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><ul>
<li>首先通过entry加载index.js</li>
<li>加载index.js后，发现它依赖了index.css</li>
<li>现在有js和css两个资源，每个资源都要经过rules中的loader处理</li>
<li>根据test，css资源匹配，会使用其中的loader对css资源进行处理</li>
<li>loader从下往上进行处理</li>
<li>css-loader将css文件变成commonjs模块加载js中，里面内容是样式字符串，可以在输出的built.js文件中检查到</li>
<li>style-loader在页面打开时，创建style标签，将js中的样式资源插入style标签，再添加到head中生效</li>
</ul>
<p>想要查看效果，只需把built.js文件引入html即可</p>
<h1 id="打包html资源"><a href="#打包html资源" class="headerlink" title="打包html资源"></a>打包html资源</h1><p>重点是配置plugins，记得下载和引用plugins</p>
<p>下载：npm i html-webpack-plugin -D</p>
<p>config:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  loader: 1. 下载   2. 使用（配置loader）</span></span><br><span class="line"><span class="comment">  plugins: 1. 下载  2. 引入  3. 使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// loader的配置</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// plugins的配置</span></span><br><span class="line">    <span class="comment">// html-webpack-plugin</span></span><br><span class="line">    <span class="comment">// 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">// 需求：需要有结构的HTML文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 复制 &#x27;./src/index.html&#x27; 文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.html:（没有引入index.js）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>hello html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包后，在build目录下生成了index.html:<br>（这里老师直接在终端输入webpack就可以打包了，我也不知道为什么）</p>
]]></content>
      <categories>
        <category>web开发</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端和PC端设置不同页面</title>
    <url>/2021/05/28/04.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%92%8CPC%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>在服务端添加以下代码（以express为例）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMachine</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deviceAgent = req.headers[<span class="string">&quot;user-agent&quot;</span>].toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> agentID = deviceAgent.match(<span class="regexp">/(iphone|ipod|ipad|android)/</span>);</span><br><span class="line">  <span class="keyword">if</span> (agentID) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 移动端</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// PC端</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> machine = getMachine(req);</span><br><span class="line">  <span class="keyword">if</span> (machine) &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./pe-views/index.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./pc-views/index.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>css</category>
        <category>自适应/响应式</category>
      </categories>
      <tags>
        <tag>自适应/响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化详解笔记</title>
    <url>/2021/05/24/03.%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="ES6模块化笔记"><a href="#ES6模块化笔记" class="headerlink" title="ES6模块化笔记"></a>ES6模块化笔记</h1><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>esport命令用于规定模块的对外接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分别暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> school = <span class="string">&#x27;尚硅谷&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">teach</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我们可以教给你开发技能!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一暴露</span></span><br><span class="line"><span class="keyword">let</span> school = <span class="string">&#x27;尚硅谷&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findJob</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我们可以帮助你找工作!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;school, findJob&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认暴露</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">school</span>: <span class="string">&#x27;ATGUIGU&#x27;</span>,</span><br><span class="line">    <span class="attr">change</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我们可以改变你!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于默认暴露，使用属性或方法时要用xxx.default.xxx</span></span><br></pre></td></tr></table></figure>



<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>import命令用于输入其他模块提供的功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">// 1. 通用的导入方式</span></span><br><span class="line">    <span class="comment">// 引入 m1.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&quot;./src/js/m1.js&quot;</span>;</span><br><span class="line">    <span class="comment">// 引入 m2.js 模块内容</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m2 <span class="keyword">from</span> <span class="string">&quot;./src/js/m2.js&quot;</span>;</span><br><span class="line">    <span class="comment">// 引入 m3.js </span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m3 <span class="keyword">from</span> <span class="string">&quot;./src/js/m3.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 解构赋值形式</span></span><br><span class="line">    <span class="keyword">import</span> &#123;school, teach&#125; <span class="keyword">from</span> <span class="string">&quot;./src/js/m1.js&quot;</span>;</span><br><span class="line">    <span class="keyword">import</span> &#123;school <span class="keyword">as</span> guigu, findJob&#125; <span class="keyword">from</span> <span class="string">&quot;./src/js/m2.js&quot;</span>;  <span class="comment">// as 起别名，防止重名冲突</span></span><br><span class="line">    <span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m3&#125; <span class="keyword">from</span> <span class="string">&quot;./src/js/m3.js&quot;</span>;  <span class="comment">// default 必须起别名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 简便形式  针对默认暴露</span></span><br><span class="line">    <span class="keyword">import</span> m3 <span class="keyword">from</span> <span class="string">&quot;./src/js/m3.js&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(m3);  <span class="comment">// default: Object</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>设置app.js作为入口文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入口文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模块引入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&quot;./m1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m2 <span class="keyword">from</span> <span class="string">&quot;./m2.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m3 <span class="keyword">from</span> <span class="string">&quot;./m3.js&quot;</span>;</span><br><span class="line"></span><br><span class="line">m1.teach();</span><br><span class="line">m2.findJob();</span><br><span class="line">m3.default.change();</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改背景颜色为粉色</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;<span class="comment">// const $ = require(&quot;jquery&quot;);</span></span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在index.html中引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./src/js/app.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h1 id="模块化理解"><a href="#模块化理解" class="headerlink" title="模块化理解"></a>模块化理解</h1><h2 id="IIFE模式"><a href="#IIFE模式" class="headerlink" title="IIFE模式"></a>IIFE模式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//操作数据的函数</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//用于暴露有函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//用于暴露有函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">        otherFun() <span class="comment">//内部调用</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//内部私有的函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//暴露行为</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.myModule = &#123;foo,bar&#125; <span class="comment">//ES6写法</span></span></span><br><span class="line"><span class="javascript">    &#125;)(<span class="built_in">window</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    myModule.foo()</span></span><br><span class="line"><span class="javascript">    myModule.bar()</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span></span><br><span class="line"><span class="javascript">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span><br><span class="line"><span class="javascript">    myModule.foo() <span class="comment">//没有改变</span></span></span><br><span class="line"><span class="javascript">    myModule.foo = <span class="string">&#x27;xxxx&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    myModule.foo(); <span class="comment">//myModule.foo is not a function</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>起初看到这一段代码，不理解为什么修改data后再调用myModule.foo()，输出没有改变，以下是心路历程：</p>
<ul>
<li>应该是在return中没有暴露data吧，我暴露试试</li>
<li>暴露data之后，console.log(myModule.data)可以正确输出了，不是undefined，但是myModule.foo()的输出依然没有改变，为什么？</li>
<li>修改myModule.data后再console.log没有问题，修改myModule.foo后也可以修改成功，为什么会出现上一条的状况？</li>
<li>因为IIFE只执行一次，执行的时候闭包（foo和bar）就已经确定好了对原始的data（即’<a href="http://www.baidu.com&/#39;%EF%BC%89%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E6%89%80%E4%BB%A5%E8%B0%83myModule.foo()%E5%B0%B1%E4%BC%9A%E8%BE%93%E5%87%BA%E5%8E%9Fdata%EF%BC%8C%E5%86%8D%E6%94%B9data%E4%B9%9F%E6%97%A0%E7%94%A8">www.baidu.com&#39;）的引用，所以调myModule.foo()就会输出原data，再改data也无用</a></li>
<li>以上的实践表明，使用该方法，由于闭包的特性，外部不可以直接修改内部的数据</li>
</ul>
<h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦把模块内的一个值赋值给一个变量，模块内部的变化就影响不到这个变量的值，除非写成一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node1.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(counter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">  <span class="attr">printCounter</span>: printCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node2.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).counter;</span><br><span class="line"><span class="comment">// 从赋值之后开始 counter 变量的任何变化都与导出对象的 counter 属性毫无关系</span></span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).incCounter;</span><br><span class="line"><span class="keyword">var</span> printCounter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).printCounter;</span><br><span class="line"></span><br><span class="line">printCounter(); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line">printCounter(); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>超出后省略剩余部分</title>
    <url>/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>效果如下：</p>
<img src="/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/1.jpg" style="zoom: 80%;">

<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>美国顶级传染病专家福奇称「不确信新冠病毒来自大自然，应该继续调查中国」，他为何突然改口？<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>环球时报 ：我们都知道，自去年新冠肺炎疫情在美国暴发<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2.02rem</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0.16rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0.04rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.14rem</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*这三个需要一起用*/</span></span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/2.jpg" style="zoom:80%;">

]]></content>
      <categories>
        <category>web开发</category>
        <category>css</category>
        <category>css特性</category>
      </categories>
      <tags>
        <tag>css实践</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的rem布局</title>
    <url>/2021/05/28/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84rem%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> designWidth = <span class="number">375</span>;         <span class="comment">// 设计稿宽度</span></span><br><span class="line"><span class="keyword">const</span> remPx = <span class="number">100</span>;               <span class="comment">// 在屏幕宽度375px的时候，设置根元素字体大小 100px</span></span><br><span class="line"><span class="keyword">let</span> scale = <span class="built_in">window</span>.innerWidth / designWidth; <span class="comment">// 计算当前屏幕的宽度与设计稿比例</span></span><br><span class="line"><span class="comment">// 根据屏幕宽度动态计算根元素的字体大小</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = scale * remPx + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我为了保险，还在css中设置了根元素字体大小是100px，为了不因为字体太大而影响布局，我又设置了body字体大小为16px</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，其他元素都用rem即可</p>
]]></content>
      <categories>
        <category>web开发</category>
        <category>css</category>
        <category>自适应/响应式</category>
      </categories>
      <tags>
        <tag>自适应/响应式</tag>
      </tags>
  </entry>
  <entry>
    <title>返回回调函数中的变量</title>
    <url>/2021/05/30/07.%E8%BF%94%E5%9B%9E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findJson</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// str参数表示用户的账号（手机号）</span></span><br><span class="line">  fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">    allUser = <span class="built_in">JSON</span>.parse(allUser);</span><br><span class="line">    user = allUser.find(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> user.id === str;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 我希望findJson函数可以把user给return出来</span></span><br><span class="line">    <span class="comment">// 直接在这里return是没用的</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>promise改进版：</p>
<p>findJson函数写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findJson</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          rejected(err)</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">        allUser = <span class="built_in">JSON</span>.parse(allUser);</span><br><span class="line">        user = allUser.find(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> user.id === str;</span><br><span class="line">        &#125;)</span><br><span class="line">        resolved(user);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调的时候可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">findJson(<span class="string">&#x27;11111111111&#x27;</span>).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(user)</span><br><span class="line"> &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.error(err)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>传入参数’11111111111’后，函数已经在index.json中找到了user（或者是undefined），执行resolved(user)，可以把user传入接下来的函数，可以得到user，这样就相当于return出来了。</p>
<p>在我的函数中是这样写的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/login&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  findJson(req.body.id).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端交互初尝试</title>
    <url>/2021/05/30/09.%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<p>一图归纳我到目前的理解程度：</p>
<p><img src="/2021/05/30/09.%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%88%9D%E5%B0%9D%E8%AF%95/1.jpg"></p>
<p>前端：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">  xhr.send(<span class="string">`id=<span class="subst">$&#123;input3.value&#125;</span>&amp;password=<span class="subst">$&#123;input4.value&#125;</span>`</span>);</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">        <span class="keyword">if</span> (data.status == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="built_in">window</span>.location.href = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data.status == <span class="number">499</span>) &#123;</span><br><span class="line">          alert(<span class="string">&#x27;该用户已注册！&#x27;</span>);</span><br><span class="line">          location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后端：get请求页面资源，post处理ajax</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/login&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;./pc-views/login.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;/login&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  findJson(req.body.id).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user);</span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      writeJson(req.body);</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="number">499</span>,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;user already registered&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>前后端交互</tag>
      </tags>
  </entry>
  <entry>
    <title>原生ajax的req.body为空</title>
    <url>/2021/05/30/08.%E5%8E%9F%E7%94%9Fajax%E7%9A%84req.body%E4%B8%BA%E7%A9%BA/</url>
    <content><![CDATA[<p>一开始的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> userjson = &#123;</span><br><span class="line">     <span class="comment">// 这里的数据格式不对</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: input3.value,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: input4.value</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">  xhr.send(userjson);</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">        <span class="comment">//之后要根据不同的response进行不同的操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要修改两个地方：</p>
<ul>
<li>请求头</li>
<li>数据格式</li>
</ul>
<p>修改后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    </span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">  xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">  <span class="comment">// 修改请求头（没有深入理解）</span></span><br><span class="line">    </span><br><span class="line">  xhr.send(<span class="string">`id=<span class="subst">$&#123;input3.value&#125;</span>&amp;password=<span class="subst">$&#123;input4.value&#125;</span>`</span>);  </span><br><span class="line">  <span class="comment">// 在不配置的情况下，原生ajax发送post请求必须用这个数据格式：&#x27;a=xxx&amp;b=xxx&amp;c=xxx&#x27;</span></span><br><span class="line">    </span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">        <span class="keyword">if</span> (data.status == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data.status == <span class="number">499</span>) &#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>json的crud</title>
    <url>/2021/05/30/10.json%E7%9A%84crud/</url>
    <content><![CDATA[<p>写：data是index.json中的所有数据，由于data一开始是二进制buffer，先用toString方法转化为字符串，再用JSON.parse转化为对象，把新的数据加入数组（allUser转为对象后是一个数组），把数组转化为字符串，再写入index.json文件</p>
<p>查：用ES6的find方法就好</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeJson</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">    allUser = <span class="built_in">JSON</span>.parse(allUser);  <span class="comment">// 对空字符串不能使用该方法，所以初始情况下json文件不能为空</span></span><br><span class="line">    allUser.push(params);</span><br><span class="line">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(allUser);</span><br><span class="line">    fs.writeFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>, str, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;index.json：新增用户数据成功&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findJson</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          rejected(err)</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">        allUser = <span class="built_in">JSON</span>.parse(allUser);</span><br><span class="line">        user = allUser.find(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> user.id === str;</span><br><span class="line">        &#125;)</span><br><span class="line">        resolved(user);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>前后端交互</category>
      </categories>
      <tags>
        <tag>前后端交互</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>视频制作教程笔记(影视飓风)</title>
    <url>/2021/06/05/13.%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0(%E5%BD%B1%E8%A7%86%E9%A3%93%E9%A3%8E)/</url>
    <content><![CDATA[<p>AV25783076：高画质的背后——视频的封装与编码</p>
<p>AV20450727：超级转场的核心——变速 ⭐️</p>
<p>AV18747023：Pr和Ae的无缝衔接大法</p>
<p>AV7301488：小技巧：Pr被低估的10个快捷键</p>
<p>AV7855737：小技巧：LUTS ⭐️</p>
<p>AV7045442：Premiere小技巧：秘传技</p>
<p>AV6936344：无缝转场与轨道蒙版 ⭐️</p>
<p>AV6746166：小技巧：超级转场的制作 ⭐️</p>
<h1 id="视频的封装与编码"><a href="#视频的封装与编码" class="headerlink" title="视频的封装与编码"></a>视频的封装与编码</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>编码分为：剪辑编码、输出编码、拍摄编码</p>
</li>
<li><p>mov、mp4是封装格式（format），不是编码</p>
</li>
<li><p>常见编码有H.264（帧间编码）和Prores（帧内编码）</p>
</li>
</ul>
<h2 id="帧内-帧间编码的对比"><a href="#帧内-帧间编码的对比" class="headerlink" title="帧内/帧间编码的对比"></a>帧内/帧间编码的对比</h2><h3 id="帧内编码"><a href="#帧内编码" class="headerlink" title="帧内编码"></a>帧内编码</h3><p>特点：针对每一帧的画面，进行单独的分析，就好比压缩一张照片。</p>
<p>优点：</p>
<ul>
<li>电脑在回放的时候比较轻松。</li>
</ul>
<p>缺点：</p>
<ul>
<li>能压缩的大小有限，体积会受到限制（比如说背景没有变化的时候，每一针都会被记录一次，产生了数据上的冗余）。</li>
</ul>
<h3 id="帧间编码"><a href="#帧间编码" class="headerlink" title="帧间编码"></a>帧间编码</h3><p>特点：记录两张完整的画面，只记录中间像素产生的变化，在后期解码时再重新运算出中间的帧，恢复出当时画面。</p>
<p>优点：</p>
<ul>
<li>有效压缩了素材体积。</li>
</ul>
<p>缺点：</p>
<ul>
<li>大了电脑的处理压力。</li>
</ul>
<h2 id="代理和输出编码"><a href="#代理和输出编码" class="headerlink" title="代理和输出编码"></a>代理和输出编码</h2><p>假如相机记录了4k的画面，又正好是帧间编码， 电脑又不够强大，应该选择使用<code>代理</code>，从而可以重新编码出一个分辨率更低，帧内编码的视频文件，使得在剪辑时更加流畅，剪辑完之后可以把它替换成原素材做进一步的处理（以后讲）。</p>
<p>剪辑完成之后，需要输出编码，这直接影响了上传到网上的视频质量，<strong>最佳的网络传播的编码，应该是h264编码，MP4封装。</strong></p>
<h2 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h2><p>码率也会影响画面和文件大小，编码决定了这个大小之下保留着最好的图像。</p>
<p>码率分为<code>恒定码率</code>和<code>可变码率</code>，通常可变码率会更实用一些，因为编码器会分析画面，之后对复杂的画面提供更多的码率，对于更容易压缩的地方，总会减少码率，这样即便文件大小不变，整体画质也会获得提升。</p>
<p>网络视频通常会在上传视频文件后进行二次压缩，可能造成码率降低，更低的码率很容易导致画面翻车，在面对具有大量随机移动的像素的时候，比如下雪或者灰尘，画面质量会迅速下降，因为编码器难以预测像素的运动，而码率不足以支撑画面。</p>
<p><strong>可以通过将视频压到B站限定的码率之下，来规避二次压缩，这样可以针对自己的视频进行编码上的优化，来获得更好的画质</strong>。</p>
<h1 id="变速"><a href="#变速" class="headerlink" title="变速"></a>变速</h1><h2 id="升格"><a href="#升格" class="headerlink" title="升格"></a>升格</h2><p><code>升格</code>是对慢动作比较专业的叫法，很多人直接把素材拖到时间线上，然后Ctrl+R，这个快捷键可以呼出速度控制窗口，然后可以输入25%或者50%，这样就可以实现升格，但是假如变速不是整除，就会遇到<code>跳帧</code>，所以应该使用<code>解释素材</code>来进行慢放，而不是纯粹的速度控制。</p>
<blockquote>
<p>升格：电影摄影中的一种技术手段，电影摄影拍摄标准是每秒24帧，也就是每秒拍摄24张，这样在放映时才能是正常速度的连续性画面，但为了实现一些简单的技巧，比如慢镜头效果，就要改变正常的拍摄速度，比如高于60帧/秒，这就是升格，放映效果就是慢动作。如果降低拍摄速度（低于24帧/秒），就是降格，放映效果就是快动作。</p>
</blockquote>
<blockquote>
<p>跳帧（frameskip），假如显示器设定的刷新率是80Hz，显卡以100FPS循环显示0-9数字，那么，在开始的0.1秒内，显卡显示了10个数字而显示器只刷新了8次，最终你看到的图像很可能是这样的：由于显示器刷新率跟不上游戏的FPS，只能舍弃一部分画面，这种现象表现在游戏里就是跳帧。</p>
</blockquote>
<h2 id="解释素材"><a href="#解释素材" class="headerlink" title="解释素材"></a>解释素材</h2><p>使用解释素材就是，在素材箱右键你的素材→Modify →Interpret footage，然后只需要把帧率修改成想要回放的帧率（比如25），这样就可以一次性处理所有的素材，实现慢放。</p>
<p>不存在整除的问题，因为可以理解成一卷胶片换了一个速度播放，就像以前升格一样，只是把每一帧映射到和之前不同的位置上。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>当有了升格后，通常需要使用变速来强化效果，很多人喜欢直接切一刀画面，然后按一下R键，激活变速工具进行变速，没有渐变，所以看起来会很突兀。</p>
<p>正确做法是右键素材的fx标记，然后选择time remapping（<code>时间重映射</code>），然后按住Ctrl+ALT键，这个键可以帮助快速添加关键帧（任何需要添加关键帧的地方都可以使用这个快捷键），打上关键帧之后可以上下拖动这根线来实现变速，随后可以分开这两个小的关键帧，这样就会有一个具有渐变的变速。也可以拖动拉杆来进一步改变速度曲线，来实现最好的效果。</p>
<p>但是也有一个弊端，PR的速度上限是十倍，假如要突破这个限制，通常会在速度最大值处切一刀，然后单独按R键加速中间这一段，再把三段衔接起来。</p>
<p>如果想要流畅的过渡镜头与镜头之间的连接，就很需要这种变速，通常就是快对快、慢对慢，如果前一个素材的尾部被加速了，那么后一个素材的起始部分也应该要被加速，这样的话，动势就能够被匹配，画面就会比较连贯。</p>
<p><strong>此处需要练习</strong></p>
<h2 id="帧采样、帧混合、光流"><a href="#帧采样、帧混合、光流" class="headerlink" title="帧采样、帧混合、光流"></a>帧采样、帧混合、光流</h2><p>如果画面不连贯，或者想要实现比相机拍摄帧率更高的慢动作，就需要使用不同的时间控制，在Pr的速度窗口里，最下方有三个选项，帧采样、帧混合、光流。</p>
<ul>
<li>帧采样，只是把同一帧展现两次或者更多次。</li>
<li>帧混合也是重复出现同样的画面，但是添加了一点渐变和叠加，在视觉上稍微顺畅一点。</li>
<li>光流是真正意义上添加了新的帧，它通过预测两帧之间的像素运动轨迹，重新运算出了中间的针帧，画面总的帧数增加，比较流畅，但是必须要对比非常大的画面，才能够实现最佳的光流效果，否则会出现畸变。</li>
</ul>
<p>通常在加速之后，突然实现短暂的光流升格，可以实现非常酷炫的画面；帧混合一般用于快放，可以实现类似于动态模糊的感觉。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用带有渐变的变速，选择合适的时间控制模式，能够大大提升整体剪辑的节奏感，也能实现更好的转场，同时也要注意音频。</p>
]]></content>
      <categories>
        <category>视频制作</category>
      </categories>
      <tags>
        <tag>视频制作</tag>
      </tags>
  </entry>
  <entry>
    <title>Some ideas</title>
    <url>/2021/06/15/14.Some%20ideas/</url>
    <content><![CDATA[<h1 id="长远计划"><a href="#长远计划" class="headerlink" title="长远计划"></a>长远计划</h1><ul>
<li>网页游戏/微信小程序游戏开发</li>
<li>APP开发</li>
</ul>
<h1 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h1><h2 id="补充技术"><a href="#补充技术" class="headerlink" title="补充技术"></a>补充技术</h2><ul>
<li>TypeScript</li>
<li>ES6没学完的部分</li>
<li>webpack</li>
<li>Vue</li>
<li>flutter</li>
<li>Nginx</li>
<li>Axios</li>
<li>打通Git</li>
<li>系统学习Github的使用</li>
<li>熟悉node（npm）</li>
<li>Linux（未来学习）</li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li>完善Lofter，登录/搜索/细节完善/部署上线</li>
<li>完善cMind，修改UI/更多功能</li>
<li>尝试把cMind变成套壳APP，而非只是网页</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li>阅读《你不知道的JS》</li>
<li>阅读《学习JS数据结构和算法》</li>
<li>阅读《JS设计模式和开发实践》</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>完成洛谷题目，数据结构进阶</li>
</ul>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript笔记</title>
    <url>/2021/06/18/15.TS%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>如果在声明变量时赋值，TS可以自动对变量进行<code>类型检测</code>。</p>
<h2 id="any和unknown"><a href="#any和unknown" class="headerlink" title="any和unknown"></a>any和unknown</h2><p>都表示不确定的类型，但unknown比any更安全：</p>
<ul>
<li>any类型的变量可以直接赋给其他值，被赋的变量也会关闭类型检测</li>
<li>unknown类型的变量不能直接被赋给其他变量</li>
</ul>
<p>如果要把它赋值给其他变量，使用断言：</p>
<h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// never 表示永远不会返回结果</span><br><span class="line">function fn(): never&#123;</span><br><span class="line">    throw new Error(&#x27;报错了！&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>对于字面量，如果直接用<code>let a: 1</code>这样的形式，则相当于常量。</p>
<p>使用联合类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 | 来连接多个类型（联合类型）</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;female&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">boolean</span> | <span class="built_in">string</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line">c = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125; 用来指定对象中可以包含哪些属性</span></span><br><span class="line"><span class="comment">// 语法：&#123;属性名:属性值,属性名:属性值&#125;</span></span><br><span class="line"><span class="comment">// 在属性名后边加上?，表示属性是可选的</span></span><br><span class="line"><span class="keyword">let</span> b: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, age?: <span class="built_in">number</span>&#125;;</span><br><span class="line">b = &#123;<span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [propName: string]: any 表示任意类型的属性</span></span><br><span class="line"><span class="comment">// propName可以改成其他字符串</span></span><br><span class="line"><span class="keyword">let</span> c: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</span><br><span class="line">c = &#123;<span class="attr">name</span>: <span class="string">&#x27;猪八戒&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;表示同时</span></span><br><span class="line"><span class="keyword">let</span> j: &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// j = &#123;name: &#x27;孙悟空&#x27;, age: 18&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的类型声明：</p>
<ul>
<li><pre><code>  类型[]
</code></pre>
</li>
<li><pre><code>  Array&lt;类型&gt;
</code></pre>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string[] 表示字符串数组</span></span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">string</span>[];</span><br><span class="line">e = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// number[] 表示数值数组</span></span><br><span class="line"><span class="keyword">let</span> f: <span class="built_in">number</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">g = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组，元组就是固定长度的数组</p>
<ul>
<li><pre><code>  语法：[类型, 类型, 类型]
</code></pre>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> h: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">h = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">123</span>];</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Gender&#123;</span><br><span class="line">    Male,</span><br><span class="line">    Female</span><br><span class="line">&#125; <span class="comment">// 实际上Male值为0，Female值为1；也可以自己赋不同值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">gender</span>: Gender&#125;;</span><br><span class="line">i = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: Gender.Male <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型的别名</span></span><br><span class="line"><span class="keyword">type</span> myType = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> k: myType;</span><br><span class="line"><span class="keyword">let</span> l: myType;</span><br><span class="line"><span class="keyword">let</span> m: myType;</span><br><span class="line"></span><br><span class="line">k = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><p>监视模式的开启：<code>tsc -w</code>，include的部分都会被监视，文件修改后自动编译</p>
<h2 id="include、exclude"><a href="#include、exclude" class="headerlink" title="include、exclude"></a>include、exclude</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  tsconfig.json是ts编译器的配置文件，ts编译器可以根据它的信息来对代码进行编译</span></span><br><span class="line"><span class="comment">    &quot;include&quot; 用来指定哪些ts文件需要被编译</span></span><br><span class="line"><span class="comment">      路径：** 表示任意目录</span></span><br><span class="line"><span class="comment">            * 表示任意文件</span></span><br><span class="line"><span class="comment">    &quot;exclude&quot; 不需要被编译的文件目录</span></span><br><span class="line"><span class="comment">        默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;./src/**/*&quot;</span> </span><br><span class="line">    <span class="comment">//可以加逗号，继续写</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;./src/hello/**/*&quot;</span> </span><br><span class="line">    <span class="comment">//一般不用写exclude</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<h2 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target 用来指定ts被编译为的ES的版本</span></span><br><span class="line">    <span class="comment">// &#x27;es3&#x27;, &#x27;es5&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es2016&#x27;, &#x27;es2017&#x27;, &#x27;es2018&#x27;, &#x27;es2019&#x27;, &#x27;es2020&#x27;, &#x27;esnext&#x27;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// module 指定要使用的模块化的规范</span></span><br><span class="line">    <span class="comment">// &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, &#x27;esnext&#x27;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// lib用来指定项目中要使用的库</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#x27;es5&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es7&#x27;, &#x27;es2016&#x27;, &#x27;es2017&#x27;, &#x27;es2018&#x27;, &#x27;es2019&#x27;, &#x27;es2020&#x27;, &#x27;esnext&#x27;, &#x27;dom&#x27;, &#x27;dom.iterable&#x27;,&#x27;webworker&#x27;,&#x27;webworker.importscripts&#x27;,&#x27;webworker.iterable&#x27;,&#x27;scripthost&#x27;,&#x27;es2015.core&#x27;,&#x27;es2015.collection&#x27;,&#x27;es2015.generator&#x27;,&#x27;es2015.iterable&#x27;, &#x27;es2015.promise&#x27;,&#x27;es2015.proxy&#x27;,&#x27;es2015.reflect&#x27;, &#x27;es2015.symbol&#x27;, &#x27;es2015.symbol.wellknown&#x27;,&#x27;es2016.array.include&#x27;,&#x27;es2017.object&#x27;,&#x27;es2017.sharedmemory&#x27;, &#x27;es2017.string&#x27;, &#x27;es2017.intl&#x27;, &#x27;es2017.typedarrays&#x27;, &#x27;es2018.asyncgenerator&#x27;, &#x27;es2018.asynciterable&#x27;, &#x27;es2018.intl&#x27;, &#x27;es2018.promise&#x27;, &#x27;es2018.regexp&#x27;, &#x27;es2019.array&#x27;, &#x27;es2019.object&#x27;, &#x27;es2019.string&#x27;, &#x27;es2019.symbol&#x27;, &#x27;es2020.bigint&#x27;, &#x27;es2020.promise&#x27;, &#x27;es2020.sharedmemory&#x27;, &#x27;es2020.string&#x27;, &#x27;es2020.symbol.wellknown&#x27;, &#x27;es2020.intl&#x27;, &#x27;esnext.array&#x27;, &#x27;esnext.symbol&#x27;, &#x27;esnext.asynciterable&#x27;, &#x27;esnext.intl&#x27;, &#x27;esnext.bigint&#x27;, &#x27;esnext.string&#x27;, &#x27;esnext.promise&#x27;, &#x27;esnext.weakref&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;es6&quot;</span>, <span class="string">&quot;dom&quot;</span>] <span class="comment">//浏览器运行环境下，一般不作指定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// outDir 用来指定编译后文件所在的目录</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将代码合并为一个文件</span></span><br><span class="line">    <span class="comment">// 设置outFile后，所有的全局作用域中的代码会合并到同一个文件中</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;./dist/app.js&quot;</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 是否对js文件进行编译，默认是false</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 是否检查js代码是否符合语法规范，默认是false</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 是否移除注释</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 不生成编译后的文件</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有错误时不生成编译后的文件</span></span><br><span class="line">    <span class="attr">&quot;noEmitOnError&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有严格检查的总开关（设为true时，以下四项都会设为true）</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来设置编译后的文件是否使用严格模式，默认false</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许隐式的any类型</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许不明确类型的this</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严格的检查空值</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TS与webpack"><a href="#TS与webpack" class="headerlink" title="TS与webpack"></a>TS与webpack</h1><ol>
<li><p><code>npm init -y</code> 生成package.json</p>
</li>
<li><p><code>npm i -D webpack webpack-cli typescript ts-loader html-webpack-plugin webpack-dev-server clean-webpack-plugin</code></p>
<ul>
<li><p>-D 表示开发依赖</p>
</li>
<li><p><code>webpack-cli</code>是webpack的命令行工具</p>
</li>
<li><p><code>html-webpack-plugin</code>用来自动创建html文件</p>
</li>
<li><p><code>webpack-dev-server</code>是webpack的开发服务器</p>
</li>
<li><p><code>clean-webpack-plugin</code>是webpack中的清除插件，每次构建都会先清除目录</p>
</li>
</ul>
</li>
<li><p>编写webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入一个包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入html插件</span></span><br><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入clean插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack中的所有的配置信息都应该写在module.exports中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/index.ts&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件所在目录</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="comment">// 打包后文件的文件</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定webpack打包时要使用模块</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定要加载的规则</span></span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="comment">// 要使用的loader</span></span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">// 要排除的文件</span></span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Webpack插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">//设置html文件的标题</span></span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;这是一个自定义的title&quot;</span></span><br><span class="line">            <span class="comment">//指定模板</span></span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来设置引用模块，不设置.ts</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>配置tsconfig.json</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...略...</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open chrome.exe&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>用class关键字来定义一个类。</p>
<p>注：static和readonly都比较少用。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   直接定义的属性是实例属性，需要通过对象的实例去访问：</span></span><br><span class="line"><span class="comment">*       const per = new Person();</span></span><br><span class="line"><span class="comment">*       per.name</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   使用static开头的属性是静态属性（类属性），可以直接通过类去访问</span></span><br><span class="line"><span class="comment">*       Person.age</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   readonly开头的属性表示一个只读的属性无法修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">&#x27;孙悟空&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在属性前使用static关键字可以定义类属性（静态属性）</span></span><br><span class="line">    <span class="keyword">static</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果方法以static开头则方法就是类方法，直接通过类去调用</span></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello 大家好！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(per.name + <span class="string">&#x27; &#x27;</span> +Person.age); <span class="comment">//孙悟空 18</span></span><br><span class="line">per.sayHello();</span><br><span class="line"><span class="comment">// Person.sayHello();</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数、this"><a href="#构造函数、this" class="headerlink" title="构造函数、this"></a>构造函数、this</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor 被称为构造函数</span></span><br><span class="line">    <span class="comment">//  构造函数会在对象创建时调用</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;小黑&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">&#x27;小白&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">dog2.bark();</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>OCP（Open Close Principle ）原则：对变更关闭，对扩展开放。</p>
<p>即：可以添加新的属性和方法，但不要修改他人已有的类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;动物在叫~&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123; <span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>在跑~~~`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪汪！&#x27;</span>); <span class="comment">// 方法重写</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;喵喵喵喵！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;咪咪&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br><span class="line">dog.sayHello();</span><br><span class="line">dog.run();</span><br><span class="line"><span class="built_in">console</span>.log(cat);</span><br><span class="line">cat.sayHello();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>在类的方法中，super就表示当前类的父类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;动物在叫~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用</span></span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪汪！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">dog.sayHello();</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类就是专门用来被继承的类，以abstract开头</p>
<ul>
<li><pre><code>  抽象类不能用来创建对象
</code></pre>
</li>
<li><pre><code>  抽象类中可以添加抽象方法
</code></pre>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法使用 abstract开头，没有方法体</span></span><br><span class="line">    <span class="comment">// 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写</span></span><br><span class="line">    <span class="keyword">abstract</span> sayHello():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪汪！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;喵喵喵喵！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>);</span><br><span class="line">dog.sayHello();</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口用来定义一个类结构，用来定义一个类中应该包含哪些属性和方法，同时接口也可以当成类型声明去使用</p>
<h3 id="interface和type"><a href="#interface和type" class="headerlink" title="interface和type"></a>interface和type</h3><p>二者都可以当作类型声明来使用，不同点：</p>
<ul>
<li>可以声明相同名称的interface，ts会把它们加在一起；而声明相同名称的type会报错。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: myInterface = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj_: myType = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口与类"><a href="#接口与类" class="headerlink" title="接口与类"></a>接口与类</h3><ul>
<li>接口可以在定义类的时候去限制类的结构</li>
<li>接口中的所有的属性都不能有实际的值</li>
<li>接口只定义对象的结构，而不考虑实际值</li>
<li>在接口中所有的方法都是抽象方法</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInter&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    sayHello():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类时，可以使类去实现一个接口（使类满足接口的要求）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="title">implements</span> <span class="title">myInter</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;大家好~~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性的封装"><a href="#属性的封装" class="headerlink" title="属性的封装"></a>属性的封装</h2><p>目前现在属性是在对象中设置的，属性可以被任意修改，这导致对象中的数据变得不安全，为了避免这种现象，需要对属性进行封装。</p>
<h3 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h3><p>TS可以在属性前添加属性的修饰符</p>
<ul>
<li>  public 修饰的属性可以在任意位置访问（修改） 默认值</li>
<li>  private 私有属性，私有属性只能在类内部进行访问（修改），通过在类中添加方法使得私有属性可以被外部访问</li>
<li>  protected 受保护的属性，只能在当前类和当前类的子类中访问（修改）</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> num: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">num: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.num); <span class="comment">// protected修饰符：在子类中可以访问num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B(<span class="number">123</span>);</span><br><span class="line">b.num = <span class="number">321</span>; <span class="comment">// 报错，不能在外部修改num属性</span></span><br></pre></td></tr></table></figure>

<h3 id="get、set"><a href="#get、set" class="headerlink" title="get、set"></a>get、set</h3><p>get方法用来读取属性，set方法用来设置属性，它们被称为属性的存取器。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时_name和_age都是私有属性，想要访问/修改必须通过get和set</span></span><br><span class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._name = name;</span><br><span class="line">        <span class="built_in">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>._name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">age</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="comment">// 使用属性存取器，增强代码健壮性</span></span><br><span class="line">        <span class="keyword">if</span>(value &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>._age = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用get/set后，还是可以用.的方式，符合我们的习惯</span></span><br><span class="line"></span><br><span class="line">per.name = <span class="string">&#x27;猪八戒&#x27;</span>;</span><br><span class="line">per.age = -<span class="number">33</span>; <span class="comment">// 不满足value &gt;=0，修改不会成功</span></span><br></pre></td></tr></table></figure>

<h3 id="简化写法"><a href="#简化写法" class="headerlink" title="简化写法"></a>简化写法</h3><p>这两种写法是等价的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可以直接将属性定义在构造函数中</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在定义函数或类时，如果遇到类型不明确就可以使用泛型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接调用具有泛型的函数</span></span><br><span class="line"><span class="keyword">let</span> result = fn(<span class="number">10</span>);  <span class="comment">// 不指定泛型，TS可以自动对类型进行推断</span></span><br><span class="line"><span class="keyword">let</span> result2 = fn&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 指定泛型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型可以同时指定多个</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">a: T, b: K</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">fn2&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">123</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Inter&#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T extends Inter 表示泛型T必须是Inter实现类（子类）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Inter</span>&gt;(<span class="params">a: T</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: T;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: T</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mc = <span class="keyword">new</span> MyClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;孙悟空&#x27;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>ts</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>未来の思考</title>
    <url>/2021/06/04/12.%E6%9C%AA%E6%9D%A5%E3%81%AE%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>考研与工作的抉择：<br><img src="/2021/06/04/12.%E6%9C%AA%E6%9D%A5%E3%81%AE%E6%80%9D%E8%80%83/1.jpg"></p>
<p>未来的打算：<br><img src="/2021/06/04/12.%E6%9C%AA%E6%9D%A5%E3%81%AE%E6%80%9D%E8%80%83/2.jpg"></p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《学习JS数据结构与算法》读书笔记</title>
    <url>/2021/08/24/17.%E3%80%8A%E5%AD%A6%E4%B9%A0JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>web开发</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>koa笔记</title>
    <url>/2021/07/19/20.koa%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="koa"><a href="#koa" class="headerlink" title="koa"></a>koa</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>不同于express，koa需要安装对应的koa-router路由模块：<code>npm i koa-router </code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)();</span><br><span class="line"><span class="comment">// const Router = require(&#x27;koa-router&#x27;); const router = Router();</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx是上下文，包含req和res等信息</span></span><br><span class="line">router</span><br><span class="line">    .get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;  </span><br><span class="line">    ctx.body = <span class="string">&quot;首页&quot;</span>;  <span class="comment">// 返回数据</span></span><br><span class="line">&#125;)</span><br><span class="line">    .get(<span class="string">&#x27;/news&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;新闻&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());  <span class="comment">// 启动路由</span></span><br><span class="line">app.use(router.allowedMethods());  <span class="comment">// 官方推荐加，最后调用，此时根据ctx.status设置response响应头</span></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at 127.0.0.1:3000&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="get传值"><a href="#get传值" class="headerlink" title="get传值"></a>get传值</h3><p>三种常用方式：</p>
<ul>
<li><p><code>ctx.query</code>：获取的是对象（最常用）</p>
</li>
<li><p><code>ctx.querystring</code>：获取的是字符串</p>
</li>
<li><p><code>ctx.request.url</code>：获取的是完整的url字符串</p>
</li>
</ul>
<p>例：当url为：<code>127.0.0.1:3000/?a=5&amp;b=7</code>时，三者的值分别为：</p>
<ul>
<li><code>&#123; a: &#39;5&#39;, b: &#39;7&#39; &#125;</code></li>
<li><code>a=5&amp;b=7</code></li>
<li><code>/?a=5&amp;b=7</code></li>
</ul>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>获取动态路由的传值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.get(<span class="string">&#x27;/news/:aid&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;  <span class="comment">//此处:aid的aid可以换名</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.query);          <span class="comment">// &#123; c: &#x27;7&#x27; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.params);         <span class="comment">// &#123; aid: &#x27;a&#x27; &#125;</span></span><br><span class="line">    ctx.body = <span class="string">&quot;新闻&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次给动态路由传多值</span></span><br><span class="line">router.get(<span class="string">&#x27;/news/:aid/:cid&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.query);          <span class="comment">// &#123; d: &#x27;8&#x27; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(ctx.params);         <span class="comment">// &#123; &#123; aid: &#x27;a&#x27;, cid: &#x27;b&#x27; &#125;: &#x27;a&#x27; &#125;</span></span><br><span class="line">    ctx.body = <span class="string">&quot;新闻&quot;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>例：当url为<code>http://127.0.0.1:3000/news/a?c=7</code>和<code>http://127.0.0.1:3000/news/a/b?d=8</code>时，结果如注释</p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="应用级中间件"><a href="#应用级中间件" class="headerlink" title="应用级中间件"></a>应用级中间件</h3><p>匹配路由前进行一系列操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用级中间件</span></span><br><span class="line"><span class="comment">// 匹配路由之前打印日期</span></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  <span class="keyword">await</span> next(); <span class="comment">// 当前路由匹配完成以后继续向下匹配</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router</span><br><span class="line">  .get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;  </span><br><span class="line">    ctx.body = <span class="string">&quot;首页&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">  .get(<span class="string">&#x27;/news&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;新闻&quot;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>不同于express的顺序执行，无论app.use是放在router.get/post前边还是后边，都会优先执行</p>
<h3 id="路由级中间件"><a href="#路由级中间件" class="headerlink" title="路由级中间件"></a>路由级中间件</h3><p>匹配到一个路由后，继续向下匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router</span><br><span class="line">  .get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;  </span><br><span class="line">    ctx.body = <span class="string">&quot;首页&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">  .get(<span class="string">&#x27;/news&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;新闻&#x27;</span>);</span><br><span class="line">    <span class="comment">// 若不加这一行，则控制台输出404后路由匹配结束，页面上显示404</span></span><br><span class="line">    <span class="keyword">await</span> next();  </span><br><span class="line">&#125;)</span><br><span class="line">  .get(<span class="string">&#x27;/news&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;新闻&quot;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a>错误处理中间件</h3><p>先进入app.use，进入next()，匹配结束后，再回到next()下边这一行，如果匹配成功则什么也不做，匹配失败就显示404</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> next();</span><br><span class="line">    <span class="keyword">if</span>(ctx.status === <span class="number">404</span>)&#123;</span><br><span class="line">        ctx.body = <span class="string">&quot;404 Not Found！&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h3><p>此处略，可以参考下方内容</p>
<h2 id="配置模板引擎"><a href="#配置模板引擎" class="headerlink" title="配置模板引擎"></a>配置模板引擎</h2><ol>
<li>安装koa-views和ejs：<code>npm i koa-views</code>，<code>npm i ejs</code></li>
<li>引入koa-views配置中间件</li>
<li>Koa中使用ejs</li>
</ol>
<p>app.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">&#x27;koa-views&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(views(<span class="string">&#x27;views&#x27;</span>, &#123;<span class="attr">extension</span>: <span class="string">&#x27;ejs&#x27;</span>&#125;));</span><br><span class="line"></span><br><span class="line">router</span><br><span class="line">  .get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王五&#x27;</span>];</span><br><span class="line">    <span class="keyword">await</span> ctx.render(<span class="string">&#x27;index&#x27;</span>, &#123;</span><br><span class="line">      arr</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at 127.0.0.1:3000&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>index.ejs：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;这是一个ejs的模板引擎&lt;/p&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;% for(let i = 0; i &lt; arr.length; i++) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;&lt;%= arr[i] %&gt;&lt;/li&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h2 id="post提交数据"><a href="#post提交数据" class="headerlink" title="post提交数据"></a>post提交数据</h2><ol>
<li>安装：<code>npm i koa-bodyparser</code></li>
<li>引入</li>
<li>app.use配置中间件</li>
<li>用ctx.request.body获取表单提交的数据</li>
</ol>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2>]]></content>
      <categories>
        <category>web开发</category>
        <category>node</category>
        <category>koa</category>
      </categories>
      <tags>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title>async、await</title>
    <url>/2021/07/07/19.async%E3%80%81await/</url>
    <content><![CDATA[<p>参考博客：<a href="https://segmentfault.com/a/1190000007535316">理解 JavaScript 的 async/await</a></p>
<p>async/await 是Generator的语法糖，异步编程更加直观且易于理解。</p>
<p>async/await 的优势在于处理 then 链。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数 n，表示这个函数执行的时间（毫秒）</span></span><br><span class="line"><span class="comment">//执行的结果是 n + 200，这个值将用于下一步骤</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async前缀的作用：使函数返回Promise</span></span><br><span class="line"><span class="comment">// 该函数的返回值已经是Promise，故不需要加async前缀</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise的写法：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function doIt() &#123;</span></span><br><span class="line"><span class="comment">//   console.time(&quot;doIt&quot;);</span></span><br><span class="line"><span class="comment">//   const time1 = 300;</span></span><br><span class="line"><span class="comment">//   step1(time1)</span></span><br><span class="line"><span class="comment">//     .then(time2 =&gt; step2(time2))</span></span><br><span class="line"><span class="comment">//     .then(time3 =&gt; step3(time3))</span></span><br><span class="line"><span class="comment">//     .then(result =&gt; &#123;</span></span><br><span class="line"><span class="comment">//       console.log(`result is $&#123;result&#125;`);</span></span><br><span class="line"><span class="comment">//       console.timeEnd(&quot;doIt&quot;);</span></span><br><span class="line"><span class="comment">//     &#125;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doIt();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// await后边加一个表达式</span></span><br><span class="line"><span class="comment">// 如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西</span></span><br><span class="line"><span class="comment">// 如果它等到的是一个Promise对象，需要等待Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Promise的状态为reject，使用try/catch来处理错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    	<span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    	<span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);  <span class="comment">// step1(time1)返回一个Promise，需拿到它resolve的值，再赋值给time2</span></span><br><span class="line">    	<span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time2);  <span class="comment">// step2(time1)返回一个Promise，需拿到它resolve的值，再赋值给time3</span></span><br><span class="line">    	<span class="keyword">const</span> result = <span class="keyword">await</span> step3(time3); <span class="comment">// step3(time1)返回一个Promise，需拿到它resolve的值，再赋值给result</span></span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    	<span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输出结果：</span></span><br><span class="line"><span class="comment">    step1 with 300</span></span><br><span class="line"><span class="comment">    step2 with 500</span></span><br><span class="line"><span class="comment">    step3 with 700</span></span><br><span class="line"><span class="comment">    result is 900</span></span><br><span class="line"><span class="comment">    doIt: 1502.43701171875 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>修改业务，每一个步骤都需要之前每个步骤的结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(n + <span class="number">200</span>), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">k, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;m&#125;</span> and <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doIt</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.time(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    	<span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    	<span class="keyword">const</span> time2 = <span class="keyword">await</span> step1(time1);</span><br><span class="line">    	<span class="keyword">const</span> time3 = <span class="keyword">await</span> step2(time1, time2);</span><br><span class="line">    	<span class="keyword">const</span> result = <span class="keyword">await</span> step3(time1, time2, time3);</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    	<span class="built_in">console</span>.timeEnd(<span class="string">&quot;doIt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    step1 with 300</span></span><br><span class="line"><span class="comment">    step2 with 300 and 500 （300 + 200 == 500）</span></span><br><span class="line"><span class="comment">    step3 with 300, 500 and 1000 （300 + 500 + 200 == 1000）</span></span><br><span class="line"><span class="comment">    result is 2000 （300 + 500 + 1000 + 200 == 2000）</span></span><br><span class="line"><span class="comment">    doIt: 3764.155029296875 ms</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
        <category>async/await</category>
      </categories>
      <tags>
        <tag>async/await</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise笔记</title>
    <url>/2021/07/07/18.Promise%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="阮一峰文档"><a href="#阮一峰文档" class="headerlink" title="阮一峰文档"></a>阮一峰文档</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test01</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strFun</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length &gt; <span class="number">5</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str);</span><br><span class="line">            anotherStr = <span class="string">&#x27;Good!&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> resolve(anotherStr); <span class="comment">// 异步操作成功时调用，将异步操作的结果作为参数传递出去</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;after resolve&#x27;</span>) </span><br><span class="line">            <span class="comment">// resolve只是修改状态，它之后的代码依然会执行，并且由于是同步代码，会在promise的then之前执行</span></span><br><span class="line">            <span class="comment">// 推荐在resolve前加return，这样确保resolve之后的代码不执行，避免意外</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(str + <span class="string">&#x27;: This string is too short!&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> reject(<span class="string">&#x27;Bad!&#x27;</span>); <span class="comment">// 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strFun(<span class="string">&#x27;Hello World!&#x27;</span>).then(<span class="function">(<span class="params">anotherStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(anotherStr); <span class="comment">// &#x27;Good!&#x27;</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">strFun(<span class="string">&#x27;Hi!&#x27;</span>).then(<span class="function">(<span class="params">anotherStr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(anotherStr);</span><br><span class="line">&#125;,<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err); <span class="comment">// &#x27;Bad!&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// test02</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeOut</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, ms, <span class="string">&#x27;Done!&#x27;</span>); <span class="comment">// 第三个参数是向回调函数(第一个参数)中传入的参数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeOut(<span class="number">2000</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//test03</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Fail!&#x27;</span>))</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(p1); </span><br><span class="line">        <span class="comment">// 由于p2的resolve的参数是promise，导致自己的状态无效化</span></span><br><span class="line">        <span class="comment">// p2的真实状态由p1决定，而p1在3s后状态变为reject，因此p2的状态在3s后变为reject</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">    .then(<span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;) </span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err); <span class="comment">// Fail!</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// test04</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 很普通的的链式调用</span></span><br><span class="line"><span class="keyword">const</span> strArr = [<span class="string">&#x27;How are you&#x27;</span>, <span class="string">&#x27;Fine thank you&#x27;</span>, <span class="string">&#x27;Nice to meet you&#x27;</span>]; </span><br><span class="line">strFun(strArr[<span class="number">0</span>]).then(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        strFun(strArr[<span class="number">1</span>]);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        strFun(strArr[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">114514</span>; <span class="comment">// 返回结果会作为参数，传入下一个回调函数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg); <span class="comment">// 114514</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，</span></span><br><span class="line"><span class="comment">// 有可能返回的还是一个Promise对象（即有异步操作），</span></span><br><span class="line"><span class="comment">// 这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于Promise.catch</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。</span></span><br><span class="line"><span class="comment">// 也就是说，错误总是会被下一个catch语句捕获。</span></span><br><span class="line"><span class="comment">// 一般来说，不要在then()方法里面定义 Reject 状态的回调函数，总是使用catch方法。</span></span><br><span class="line"><span class="comment">// 原因：可以捕获前边then方法执行中的错误，也更接近同步的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test05</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// finally方法的回调函数不接受任何参数</span></span><br><span class="line"><span class="comment">// finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果</span></span><br><span class="line">strFun(<span class="string">&#x27;I love u, u love me, mexue ice-cream and tea~&#x27;</span>).finally(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;OK&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">strFun(<span class="string">&#x27;lmao&#x27;</span>).finally(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;OK&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="尚硅谷视频"><a href="#尚硅谷视频" class="headerlink" title="尚硅谷视频"></a>尚硅谷视频</h1><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><ul>
<li>如果传入的参数为非Promise对象，则返回的结果为成功Promise对象</li>
<li>如果传入的参数为Promise对象，则参数的结果决定了返回的结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">111</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="keyword">new</span> <span class="built_in">Promise</span>((res, rej)) =&gt; &#123;</span><br><span class="line">  <span class="comment">// res(&#x27;OK&#x27;)</span></span><br><span class="line">  rej(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h2><p>和Promise.resolve相比，无论传入什么类型的数据，返回结果都为失败Promise对象，传入什么，失败的内容就是什么</p>
<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h2><p>传入包含n个Promise的数组，返回一个新的Promise，只有所有的Promise都成功才成功，否则失败</p>
<p>若成功，将成功值保存在一个数组中；若失败，只将第一个失败的值保存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">  res(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Success&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Oh Yeah&#x27;</span>)</span><br><span class="line"><span class="comment">// let p3 = Promise.reject(&#x27;Oh Yeah&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line"></span><br><span class="line">result.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)  <span class="comment">//  [&quot;OK&quot;, &quot;Success&quot;, &quot;Oh Yeah&quot;]</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">result.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h2><p>和all类似，不同之处：第一个执行完毕的Promise的结果决定了Promise.race返回值的结果</p>
]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
        <category>promise</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>口琴谱</title>
    <url>/2021/08/04/23.%E5%8F%A3%E7%90%B4%E8%B0%B1/</url>
    <content><![CDATA[<p>谱子来源于b站/je吧</p>
<h1 id="美丽之物"><a href="#美丽之物" class="headerlink" title="美丽之物"></a>美丽之物</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#4  7  #【1】</span><br><span class="line">【2】  #【1】  7  6 #4</span><br><span class="line">#4  3  2  3  6 #4</span><br><span class="line">7  #【1】  【2】  #【1】  7  6 #4</span><br><span class="line">#4  3  2  3  2  2</span><br><span class="line">7  #【1】  【2】  #【1】  7  6  #4</span><br><span class="line">#4  3  2  3  6  #4</span><br><span class="line">#4  3  2  3  6  #4</span><br><span class="line">#4  3  2  3  2  2</span><br><span class="line"></span><br><span class="line">【4 3 2 1】6 </span><br><span class="line">5 4 5 【1】  6</span><br><span class="line">【2 3 4 3 2 1】6</span><br><span class="line">5 4 5 4  4</span><br><span class="line">【2 3 4 3 2 1】6</span><br><span class="line">5 4 5 【1】  6</span><br><span class="line">5 4 5 【1】  6</span><br><span class="line">5 4 5 4  4</span><br><span class="line">【2  1  】 #66 #66#6【12  1  】</span><br><span class="line">【2 1】#6 655 6</span><br><span class="line"></span><br><span class="line">6  6 6 6 7 5  #4  3</span><br><span class="line">3 3  #4  5 #4  3  2</span><br><span class="line">(7) #1  2  #4 3  2  3</span><br><span class="line">2  3  #4  5  6</span><br><span class="line">6  6  7 5  #4  3</span><br><span class="line">3  #4  6 3  2  2</span><br><span class="line">(7) #1  2  #4 3  2  3</span><br><span class="line">6  6 6  7 5  #4  3</span><br><span class="line">3  #4  5 #4  3  2</span><br><span class="line">(7) #1  2  #4 3  2  3</span><br><span class="line">2  3  #4  5  6</span><br><span class="line">6  6  7 5  #4  3</span><br><span class="line">3  #4  【2】 #【1】  6  #4</span><br><span class="line">2  3  #4</span><br><span class="line">5  #4  3 3</span><br><span class="line">2  3  4  5  6</span><br><span class="line">5  6  【1】  【1】  5  5</span><br><span class="line">6  5  4</span><br><span class="line">4  5  4  3  2  2  1</span><br><span class="line">7 7  7  6 7  #【1】  【2】</span><br><span class="line">#【1】 #【1】  #【1】  7 #【1】  7 6</span><br><span class="line">(7)  1  2  3  #4  5  6</span><br><span class="line">#4  #6  7  #【1】</span><br><span class="line">【2】  #【1】  7  6 #4</span><br><span class="line">#4  3  2  3  6  #4</span><br><span class="line">#4  7  #【1】  【2】  #【1】  7  6 #4</span><br><span class="line">#4  3  2  3  2  2</span><br><span class="line">7  #【1】  【2】  #【1】  7  6 #4</span><br><span class="line">#4  3  2  3  6  #4</span><br><span class="line">#4  3  2  3  6  #4</span><br><span class="line">#4  3  2  3  2  2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)(#5)(#4#1)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6) (#5)(#6)(#5)(#4)(#5)</span><br><span class="line">(#5)(#4)(#5)(#4)(#5)(#6)#1(#6) (#5)(#6)(#5)(#4#2)</span><br><span class="line">(#6)(#5)(#4)(#5)(#4) (#6)(#5)(#4)(#5)(#4)</span><br><span class="line">(#6)(#5)(#4)(#5)(#4)</span><br><span class="line"></span><br><span class="line">(#4)(#5)(#6)(#4) #2#1#2（#4）#3#2#3</span><br><span class="line">#3#2#3 (#6)#4#5#4#3#2#1</span><br><span class="line">#1#2#1#2#1#2#1(#5)#1(#6)</span><br><span class="line">(#4)(#5)(#6)(#4) #2#1#2（#4）#3#2#3</span><br><span class="line">#3#2#3 (#6)#4#5#4#3#2#1</span><br><span class="line">#1#2#6#6 #1#2#6#6#1#2#2</span><br><span class="line"></span><br><span class="line">#4#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】</span><br><span class="line">#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】#6</span><br><span class="line">#5#4#2#4 #4#5#4#2#4#67#6#5#6#5</span><br><span class="line">#4#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】</span><br><span class="line">#5#6 【#2】【#1】 【#2】【#1】 【#2】【#1】#6</span><br><span class="line">#5#4#2#6 #5#4#2#4#4</span><br><span class="line">#2#6 #5#4#2 #6#5#4#2 #4#4</span><br><span class="line"></span><br><span class="line">间奏：</span><br><span class="line">#1 #4 #5 #6 #1【#1】  #6</span><br><span class="line"> #3#4 #5 #6  #1【#1】  #6</span><br><span class="line"> #6【#1】 #5 6 #5#4#2#4</span><br><span class="line">(#6)(7)(#6) #1 #2(#6)(#5) &#123;#4&#125; &#123;#2&#125; &#123;#4&#125;(#6)</span><br><span class="line">(#6)(#6) (#2) (#6)(#6) (#2)</span><br><span class="line">(#6)(#6)#2#1#2</span><br><span class="line">【#1 】#6 #5#4#2#1(#6)(#5) (#4) (#2) (#1) (#2) (#4)</span><br><span class="line"> (#3) (#4)(#5)(#6)#2#1(7)(#6) (#3) (#4) #1</span><br><span class="line"> </span><br><span class="line">尾音：</span><br><span class="line">#2#1(#6)   #2#1(#6)#1   #2#1(#6)</span><br></pre></td></tr></table></figure>

<h1 id="to-the-beginning"><a href="#to-the-beginning" class="headerlink" title="to the beginning"></a>to the beginning</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#4#4#3#4 #2#5#6 [#1#1#1#1]</span><br><span class="line"></span><br><span class="line">12#25 [#22#22]#6 </span><br><span class="line">#6#55#2#3#6#55 7[12]</span><br><span class="line">[12#2]#7[#3#22]#6 </span><br><span class="line">#6#5#6#7[2]#6[431]5</span><br><span class="line">-------------------------------------- </span><br><span class="line">11123(77) 1(76) 121233 </span><br><span class="line">11123(77) 1(76) 12(7)2#1#1  </span><br><span class="line">23444 6677 333 5566  </span><br><span class="line">432 436#54433 5435 </span><br><span class="line">666[1122] 55577[11]</span><br><span class="line">4323 6456 #567</span><br><span class="line"></span><br><span class="line">66#566 #4#56[#1#122] </span><br><span class="line">[#1]6[#1#122] [#1]7[2#1#1] 676#576</span><br><span class="line">6#56 #4#56[#1#122] </span><br><span class="line">[#1]6[#1#122] [#1]7[2#1#1] </span><br><span class="line">76#57766 [3]#5#5 </span><br><span class="line"></span><br><span class="line">11123(77) (6) 12 24 43 </span><br><span class="line">11123(77) 1(76) 12(7)23#1  </span><br><span class="line">444 6677 333 5566 </span><br><span class="line">432 436#54433 5435 </span><br><span class="line">666[1122] 55577[11] </span><br><span class="line">4466#5676</span><br><span class="line"></span><br><span class="line">332#133  676#5766  </span><br><span class="line">332#132  (7)#122#1#1 </span><br><span class="line">33(66)36 33(66)36  </span><br><span class="line">#5#5#4#3#4#5 6[#1]#53</span><br><span class="line">55115[111]76  7[122]66 677</span><br><span class="line">66#56 #4#56[#1#122] </span><br><span class="line">[#1]6[#1#122] [#1]7[2#1#1] 676#576  </span><br><span class="line">6#56 #4#56[#1#122] [#1]6[#1#122] </span><br><span class="line">[#1]7[2#1#1] 76#5766 </span><br><span class="line">#5#43#5#4#4 #4#4#5#5 #6#6</span><br></pre></td></tr></table></figure>

<h1 id="king"><a href="#king" class="headerlink" title="king"></a>king</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 5#44#221 12#24#4 5</span><br><span class="line">1 5#44#221 （7）1（7）1（7）</span><br><span class="line">1 5#44#221 12#24#4 5</span><br><span class="line">1 5#44#221 （7）1（7）1（7）</span><br><span class="line"></span><br><span class="line">5#755 4#2#55</span><br><span class="line">#2#3（#6#6 #6#65#6#7）</span><br><span class="line">5【1】 5【#2】 #3#2#55</span><br><span class="line">#2#3（#6#6  #6#65#6#7）</span><br><span class="line"></span><br><span class="line">#25#2 555#2555#554#2</span><br><span class="line">#25#2 555#25554#22（#6）</span><br><span class="line">#25#2 555#2555#554#2</span><br><span class="line">#25#25#25#5  757【21】</span><br><span class="line"></span><br><span class="line">5#2555#2555#554#2</span><br><span class="line">5#2555#2555#5#6545</span><br><span class="line">5#2555#2555#554#2</span><br><span class="line">5#2555#5 757【2】</span><br><span class="line"></span><br><span class="line">【#21#21 #3#2#35#3#21】</span><br><span class="line">【111】#6【12#221】</span><br><span class="line">【#21#21 #3#2#35#3#21 111】</span><br><span class="line">77</span><br><span class="line">【#221】</span><br><span class="line">【#221】</span><br></pre></td></tr></table></figure>

<h1 id="夜に駆ける"><a href="#夜に駆ける" class="headerlink" title="夜に駆ける"></a>夜に駆ける</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5#6#7#554 #2#3#7#6【1】5#3#2</span><br><span class="line">5#6#7#554 【2】#7#6#6#7【2#2】 5#3#2</span><br><span class="line"></span><br><span class="line">(#7)2#22 (#65#6#7)</span><br><span class="line">(#6#6#7)#2#35(#6#7)54#6#5#55</span><br><span class="line">5#7#654 #2(#7)#2(#7)#24 #2252(#6#7)</span><br><span class="line">(#7)2#2454 #222(#7#7)</span><br><span class="line">(#6#7)2#22 (#65#6#7)</span><br><span class="line">(#6#6#7)#2#6545#6#7#6545</span><br><span class="line">5#7#654 #2(#7)#2(#7)#24 #2252(#6#7)</span><br><span class="line">(#7)2#2454 #222(#7)</span><br><span class="line"></span><br><span class="line">(#6#6#6#7) #2(#7)#2(#7)#2</span><br><span class="line">15545 42(#6#6#7)</span><br><span class="line">5555#5#65 #2(#7)#2445 #2(#7)#2(#7)#245</span><br><span class="line">5#5#654#2</span><br><span class="line">(#7)#254#2#245754#2</span><br><span class="line">2(#6#7#6#7)2#245#55</span><br><span class="line"></span><br><span class="line">【#22】#6#6#754 #2#3#7#6#354#2</span><br><span class="line">#2#6#554#22#24#5545#7#6</span><br><span class="line">5#6#7#554 #2#3#7#6#75#3#2</span><br><span class="line">(#7)2#2(#7)#245#25#77</span><br><span class="line">#2#2【#22】#6#6#754  #2#3#7#6【1】5#3#2</span><br><span class="line">#2#6#554#22#24#5545#7#6</span><br><span class="line">5#6#7#554 【2】#7#6#6#7【2#2】 5#3#2</span><br><span class="line">1#2#55 #24#2</span><br><span class="line"></span><br><span class="line">(#7)2#22 (#65#6#7)</span><br><span class="line">(#6#6#7)#2#6545#6#7#6545</span><br><span class="line">5#7#654 #2(#7)#2(#7)#24 #2252(#6#7)</span><br><span class="line">(#7)2#2454 (#6#6#7)</span><br><span class="line"></span><br><span class="line">(#7#7#7)#2#2#2 #2#2#2#2</span><br><span class="line">#2#2#2#2#2 #2#2#2(#7)#2(#7)</span><br><span class="line">(#7#7#7#7)#2#2 #2#2#2#2</span><br><span class="line">#2#2 #2#2#2#2 #2#7#2(#7)#7#6</span><br><span class="line">#25#5#64#2 5#5#64#2</span><br><span class="line">5#5#64#2</span><br><span class="line">5#6#7#654#2 (#7)#2#5514#2</span><br><span class="line"></span><br><span class="line">#6#6#6#6#6 #6#6#5544#2</span><br><span class="line">(#7)#2#7#65#6511 545【#22】#65#6#7#654#2</span><br><span class="line">#6#6#6#6#6 #6#6#55#64#2</span><br><span class="line">(#7)#2#7#654#2(#7)#2#55#2(#7)#2</span><br><span class="line"></span><br><span class="line">(#5#6#6#7#7) #2(#7)#2(#7)#2</span><br><span class="line">15545 42(#6#6#7)</span><br><span class="line">5555#5#65 #2(#7)#2445 #2(#7)#2(#7)#245</span><br><span class="line">5#7#654#2(#7)#2(#7)#3</span><br><span class="line">#3#7#7#6#6#7#7#6545#2</span><br><span class="line">#245#215#2(#7)#2#7754#55</span><br><span class="line"></span><br><span class="line">【2#1】667#4323763#432</span><br><span class="line">265#432#1235#4 #4#476</span><br><span class="line">#4675#4323767#432</span><br><span class="line">(7)#12(7)23#42#47#67【#1】</span><br><span class="line"></span><br><span class="line">【43112】6545【212】654</span><br><span class="line">4【1】#6654345#6656【21】</span><br><span class="line">6【12】#66545【212】654</span><br><span class="line">234245646【2#1】</span><br><span class="line">44【43112】6545【212】654</span><br><span class="line">4【1】#6654345#6656【21】</span><br><span class="line">6【12】#665【3211234】#554</span><br><span class="line">24#66424</span><br><span class="line">1234【1】#66541454</span><br><span class="line">6【121】65424【21】624</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>生活</category>
        <category>口琴</category>
      </categories>
      <tags>
        <tag>口琴</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode文本编辑和快捷键</title>
    <url>/2021/08/08/24.vscode%E5%9F%BA%E6%9C%AC%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%92%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<p><strong>多行注释：</strong>[alt+shift+A]</p>
<p><strong>移动行：</strong>alt+up/down</p>
<p><strong>复制当前行：</strong>shift + alt +up/down</p>
<p><strong>删除当前行：</strong>shift + ctrl + k</p>
<p><strong>控制台终端显示与隐藏：</strong>ctrl + ~</p>
<p><strong>代码格式化：</strong>shift + alt +f</p>
<p><strong>行增加缩进:</strong> ctrl + [</p>
<p><strong>行减少缩进:</strong> ctrl + ]</p>
<p><strong>拆分编辑器 :</strong> ctrl + 1/2/3（不是小键盘）</p>
<p><strong>选择多列：</strong>alt+shift+鼠标拖动 || Ctrl+Shift+Alt+方向键</p>
<p><strong>打开新的命令窗：</strong>ctrl + shift + c</p>
]]></content>
      <categories>
        <category>环境配置</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器是如何工作的</title>
    <url>/2021/08/22/27.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>参考视频：<a href="https://www.bilibili.com/video/BV1x54y1B7RE">浏览器是如何运作的</a></p>
<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="浏览器的组成部分"><a href="#浏览器的组成部分" class="headerlink" title="浏览器的组成部分"></a>浏览器的组成部分</h2><p>浏览器分为以下几个部分：<code>用户界面</code>，<code>浏览器引擎</code>，<code>渲染引擎</code></p>
<p>其中：</p>
<ul>
<li>用户界面用于展示除标签页窗口之外的其它用户界面内容</li>
<li>渲染引擎负责渲染用户请求的页面内容</li>
<li>浏览器引擎用于在用户界面和渲染引擎之间传递数据</li>
</ul>
<p>渲染器下有很多小的功能模块，如负责网络请求的<code>网络模块</code>，用于解析和执行js的<code>js解释器</code>，，还有<code>数据存储持久层</code>（帮助浏览器存储各种数据，如cookie）</p>
<blockquote>
<p><strong>渲染引擎是浏览器的核心，把它称作浏览器的内核</strong></p>
</blockquote>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><center>
    <img src="https://img-blog.csdnimg.cn/20210311162244195.png" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<p>Blink是基于Webkit改造的</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><center>
    <img src="https://img-blog.csdnimg.cn/20210311164614193.png" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<ul>
<li><p>当我们启动某个程序时，就会创建一个<code>进程</code>来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里</p>
</li>
<li><p>当应用关闭时，该内存空间就会被回收，进程可以启动更多的进程来执行任务</p>
</li>
<li><p>两个进程间相互独立，如果需要两个进程空间需要传递某些数据，则使用<code>进程间通信管道IPC</code>传递</p>
</li>
<li><p>进程可以将任务分成更多细小的任务，然后通过创建多个线程并行执行不同的任务</p>
</li>
<li><p>同一进程下的线程是可以直接通信共享数据的</p>
</li>
</ul>
<h3 id="各进程的作用"><a href="#各进程的作用" class="headerlink" title="各进程的作用"></a>各进程的作用</h3><center>
    <img src="https://img-blog.csdnimg.cn/20210311164620571.jpg" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<ul>
<li><p><code>浏览器进程</code>负责控制chrome浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其它进程协调工作</p>
</li>
<li><p><code>网络进程</code>负责发起接受网络请求</p>
</li>
<li><p><code>GPU进程</code>负责整个浏览器界面的渲染</p>
</li>
<li><p><code>插件进程</code> 负责控制网站使用的所有插件（此处插件是flash等，不是chrome安装的拓展插件）</p>
</li>
<li><p><code>渲染器进程</code>用来控制显示tab标签内的所有内容</p>
</li>
</ul>
<h1 id="从输入网址到加载网页的过程"><a href="#从输入网址到加载网页的过程" class="headerlink" title="从输入网址到加载网页的过程"></a>从输入网址到加载网页的过程</h1><center>
    <img src="https://img-blog.csdnimg.cn/20210311164839647.jpg" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>

<p>浏览器默认情况下，为每个标签页都创建一个进程</p>
<h2 id="输入网址"><a href="#输入网址" class="headerlink" title="输入网址"></a>输入网址</h2><p>在地址栏输入地址时，<code>浏览器进程的UI线程</code>会捕捉你的输入内容</p>
<p>如果访问的是网址，则UI线程会启动一个<code>网络线程</code>来请求DNS进行域名解析，接着开始链接服务器获取数据</p>
<p>如果输入不是网址而是一串关键词，浏览器判断你要搜索，就会使用<code>默认配置的搜索引擎</code>来查询</p>
<p>当网络线程获取到数据后，会通过<code>SafeBrowsing</code>来检查站点是否是恶意站点，如果是，则提示警告页面（可强行继续访问）</p>
<blockquote>
<p>SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全（比如通过查看该站点IP是否在谷歌黑名单之内）</p>
</blockquote>
<p>当返回数据准备完毕并且安全校验通过时，网络线程会通知UI线程:自己已经准备好，然后UI线程会创建一个渲染器进程来渲染页面</p>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="获得DOM树"><a href="#获得DOM树" class="headerlink" title="获得DOM树"></a>获得DOM树</h3><p>浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程</p>
<p>渲染器进程接收到的数据也就是html，<strong>渲染器进程的核心任务就是把html css js image等资源渲染成用户可以交互的web页面</strong></p>
<p>渲染器进程的<code>主线程</code>将html进行解析，构造DOM数据结构（DOM是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API）</p>
<p>html首先经过<code>tokeniser标记化</code>，通过<code>词法分析</code>将输入的html内容解析成多个标记，根据识别后的标记进行<code>DOM树构造</code>，在DOM树构造过程中会创建document对象，然后以document为根节点的DOM树不断进行修改，向其中添加各种元素</p>
<p>html代码中往往会引入一些额外的资源，图片和CSS这些资源需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞html的解析，不会影响DOM的生成</p>
<p>但当HTML解析过程中遇到script标签，将停止html解析流程，转而去加载解析并且执行JS，这是因为浏览器不知道JS执行是否会改变当前页面的HTML结构（JS代码可以用document.write 来修改html），这就是要把script标签放在合适的位置/或者使用async或defer属性来异步加载执行JS 的原因</p>
<p>HTML解析完成之后，获得DOM树，但我们还不知道其上每个结点长什么样子</p>
<h3 id="获得Layout树"><a href="#获得Layout树" class="headerlink" title="获得Layout树"></a>获得Layout树</h3><p>主线程需要解析CSS，并确定每个DOM结点的计算样式，即使没有提供CSS样式，浏览器也会有自己默认的样式表</p>
<p>我们接下来需要知道每个结点需要放在页面上的哪个位置，也就是结点的坐标以及该结点需要占用多大的区域，这个阶段被成为layout布局</p>
<p>主线程通过遍历dom和计算好的样式来生成Layout树，Layout树上的每个结点都记录了x，y坐标和边框尺寸</p>
<blockquote>
<p>注意DOM树和Layout树并不是一一对应的，设置了display:none 的结点不会出现在Layout树上，而在before伪类中添加了content值的元素，content里的内容会出现在Layout树上，而不会出现在DOM树里，这是因为DOM树是通过html解析获得，并不关系样式，而Layout树是根据DOM和计算好的样式来生成的，<strong>Layout树是和最后展示在屏幕上的结点是对应的</strong></p>
</blockquote>
<h3 id="栅格化与合成"><a href="#栅格化与合成" class="headerlink" title="栅格化与合成"></a>栅格化与合成</h3><p>我们还需要知道以什么样的顺序绘制这个结点</p>
<p>举例来说，z-index属性会影响结点绘制的层级关系，如果我们按照dom的层级结构来绘制页面，则会导致错误的渲染，所以为了保证在屏幕上展示正确的层级，主线程遍历Layout树创建一个绘制记录表，该表记录了绘制的顺序，这个阶段被成为<code>绘制（paint）</code></p>
<p>知道绘制顺序后，现在该把这些信息转化成像素点，显示在屏幕上了，这种行为称为<code>栅格化</code>，chrome使用较为复杂的栅格化流程，叫做<code>合成</code></p>
<p>合成是一种将页面上的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独进行合成页面的技术，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可</p>
<p><strong>主线程遍历Layout树生成Layer树</strong>，当Layer树生成完毕和绘制顺序确定后，主线程将这些信息传递给<code>合成器线程</code>，合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，合成器线程将它们切分成许多<code>图块</code>，然后将每个图块发送给栅格化线程，栅格化线程栅格化每个图块，并将它们存储在<code>GPU内存</code>中，当图块栅格化完成后，合成器线程将收集称为<code>draw quads</code>的图块信息，这些信息里记录了图块在内存中的位置，和在页面的哪个位置绘制图块的信息</p>
<p>根据这些信息合成器线程生成了一个<code>合成器帧</code>，然后合成器帧通过IPC传送给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上，当页面发生变化（比如滚动页面），都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上</p>
<h3 id="重排重绘和卡顿现象"><a href="#重排重绘和卡顿现象" class="headerlink" title="重排重绘和卡顿现象"></a>重排重绘和卡顿现象</h3><ul>
<li><p>重排：当改变一个元素的尺寸位置属性时，会重新进行样式计算，布局、绘制以及后面的所有流程</p>
</li>
<li><p>重绘：当改变元素的颜色属性时，不会重新触发布局，但还剩会触发样式计算和绘制</p>
</li>
</ul>
<p>重排和重绘都会占用主线程，JS也运行在主线程</p>
<p>页面的卡顿现象：<br>当页面以每秒60帧的刷新率（每帧16ms）时才不会感到卡顿</p>
<p>重排重绘和JS运行会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作</p>
<p>如果在运行动画时还有大量的JS任务需要执行，由于布局、绘制和JS执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，如果还有剩余时间，JS就会拿到主线程的使用权，如果JS执行时间过长，就会导致在下一帧开始时JS没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面动画的卡顿</p>
<h3 id="卡顿的优化方案"><a href="#卡顿的优化方案" class="headerlink" title="卡顿的优化方案"></a>卡顿的优化方案</h3><ol>
<li><p>requestAnimationFrame()<br>这个方法会在每一帧被调用，通过API的回调，我们可以把JS运行任务分成一些更小的任务块，分到每一帧，在每一帧时间冲完前暂停JS执行，归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制</p>
</li>
<li><p>由于栅格化的整个流程是不占用主线程的，只在合成器线程和栅格线程中运行，这就意味着它无需和JS抢夺主线程，通过transform属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程中，所以不会受到主线程中JS执行的影响</p>
</li>
</ol>
<p>用transform实现的动画由于不需要经过布局绘制，样式计算等操作，所以节省了很多运算时间</p>
]]></content>
      <categories>
        <category>web开发</category>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>JS继承详解</title>
    <url>/2021/08/22/28.JS%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>虽然ES6的Class继承确实很方便，但是ES5的继承还是要好好了解一下：</p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1J54y1y7u9?t=807">详解JS继承（超级详细且附实例）</a></p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>构造函数的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//实例引用属性(该属性，强调复用，需要共享)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：数组和方法都属于’实例引用属性’，但是数组强调私有不共享，方法需要复用共享。在构造函数中，很少有数组形式的引用属性，大部分情况都是：基本属性+方法。</p>
<p>在构造函数中，为了属性(实例基本属性)的私有性、方法(实例引用属性)的复用共享，提倡：将属性封装在构造函数中，将方法定义在原型对象上。</p>
<p>修正constructor指向的意义：任何一个prototype对象都有一个constructor属性，指向它的构造函数(它本身)，更重要的是，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性。<br>在new之后，constructor会指向父类构造函数，如果我们要生成子类构造函数的实例，这些实例的constructor属性会指向父类构造函数，然而它们是靠子类构造函数生成的，constructor属性应该指向子类构造函数。因此，不修改constructor指向的话，会导致继承链的紊乱。</p>
<p>(以上来自阮一峰博客，我目前不清楚继承链紊乱会引起什么后果，最起码在我看来，即便不修改constructor指向，好像也没什么影响？)</p>
<p>文档的原作者说：要修复constructor指向，原因是：不能判断子类实例的直接构造函数，到底是子类构造函数还是父类构造函数</p>
<h1 id="JS继承方式"><a href="#JS继承方式" class="headerlink" title="JS继承方式"></a>JS继承方式</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><ul>
<li>核心：将父类实例作为子类原型</li>
<li>优点：方法复用<br>方法定义在父类的原型上，可以复用父类构造函数的方法，比如say方法。</li>
<li>缺点：<ul>
<li>创建子类实例时，无法传父类参数</li>
<li>子类实例共享</li>
<li>继承单一，无法实现多继承</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name || <span class="string">&#x27;父亲&#x27;</span>;	实例基本属性(该属性，强调私有，不共享)</span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">like</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();	<span class="comment">//核心，但此时Child.prototype.constructor == Parent;</span></span><br><span class="line">Child.prototype.constructor = Child;	<span class="comment">//修正constructor指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line"><span class="comment">//优点：共享父类构造函数的say方法</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.say(),boy2.say(),boy1.say === boy2.say);	<span class="comment">//hello,hello,true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点1：不能传入父类的参数(比如name)，只能传子类有的参数like</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.name,boy2.name,boy1.name === boy);	<span class="comment">//父亲，父亲，true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点2：子类实例共享了父类构造函数的引用属性，比如arr属性</span></span><br><span class="line">boy1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boy2.arr);<span class="comment">//[1,2];</span></span><br><span class="line"><span class="comment">//修改了boy1的arr属性，boy2的arr属性也会变化，</span></span><br><span class="line"><span class="comment">//因为两个实例的原型上(Child.prototype)有了父类构造函数的实例属性arr，所以只要修改了boy1.arr，boy2.arr也变化</span></span><br></pre></td></tr></table></figure>

<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><ul>
<li>核心：借用父类构造函数来增强子类实例，等于是复制父类的实例属性给子类</li>
<li>优点：实例之间独立<ul>
<li>创建子类实例，可以向父类构造函数传参</li>
<li>子类实例不共享父类构造函数的引用属性，如arr</li>
<li>可实现多继承（通过多个call或apply继承多个父类）</li>
</ul>
</li>
<li>缺点：<ul>
<li>父类方法不能复用<br>由于方法在父构造函数中定义，导致方法不能复用（每次创建子类实例都要创建一遍方法）</li>
<li>子类实例继承不了父类原型上的属性，因为没有用到原型</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];	(该属性，强调私有)</span><br><span class="line"> <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//实例引用属性(该属性，强调复用，需要共享)</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function Child(name,like)&#123;</span></span><br><span class="line"><span class="string">	Parent.call(this,name);	//核心，拷贝了父类的实例属性和方法</span></span><br><span class="line"><span class="string">	this.like = like;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">let boy1 = new Child(&#x27;</span>小刚<span class="string">&#x27;,&#x27;</span>apple<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">let boy2 = new Child(&#x27;</span>小明<span class="string">&#x27;,&#x27;</span>orange<span class="string">&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//优点1：可向父类构造函数传参</span></span><br><span class="line"><span class="string">console.log(boy1.name,boy2.name);	//小刚，小明</span></span><br><span class="line"><span class="string">//优点2：不共享父类构造函数的引用属性</span></span><br><span class="line"><span class="string">boy1.arr.push(2);</span></span><br><span class="line"><span class="string">console.log(boy1.arr,boy2.arr);	//[1,2]，[1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//缺点1：方法不能复用</span></span><br><span class="line"><span class="string">console.log(boy1.say === boy2.say);	//false (说明boy1和boy2的say方法独立，不是共享的)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//缺点2：不能继承父类原型上的方法</span></span><br><span class="line"><span class="string">Parent.prototype.walk = function()&#123;</span></span><br><span class="line"><span class="string">	console.log(&#x27;</span>我会走路<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">boy1.walk;	//undefined(说明实例不能获得父类原型上的方法)</span></span><br></pre></td></tr></table></figure>


<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><ul>
<li>核心：通过调用父类构造函数，继承父类属性并保留传参的优点；然后通过将父类实例作为子类原型，实现函数复用。</li>
<li>优点：<ul>
<li>保留方法1的优点：父类的方法定义在原型对象上，可以实现方法复用</li>
<li>保留方法2的优点：创建子类实例，可以向父类构造函数传参；并且不共享父类的引用属性，如arr</li>
</ul>
</li>
<li>缺点：由于调用了2次父类的构造方法，会存在一份多余的父类实例属性<br>原因：第一次Parent.call(this)从父类拷贝一份父类实例属性，作为子类的实例属性，第二次Child.prototype = new Parent()创建父类实例作为子类原型，(Child.prototype中的父类属性和方法会被第一次拷贝来的实例属性屏蔽掉，所以多余←这句话没理解)<br>我的理解是，第二次new Parent的时候也执行了Parent构造函数，但是因为没有传参，导致子类实例对象的_ <em>proto</em> <em>的</em> <em>proto</em> _中，一部分属性为undefined<center>
  <img src="https://img-blog.csdnimg.cn/20210209190344284.jpg" width=" 50%">
  <br>
  <font size="3" face="楷体" color="#999"><u>注意name：undefined</u></font>
</center></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span><br><span class="line"> Parent.call(<span class="built_in">this</span>,name);	<span class="comment">//核心，第二次</span></span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); <span class="comment">//核心，第一次</span></span><br><span class="line">Child.prototype.constructor = Child;	<span class="comment">//修正constructor指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child(<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//优点1：可以复用父类原型上的方法</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.say === boy2.say);	<span class="literal">true</span></span><br><span class="line"><span class="comment">//优点2：可以向父类构造函数传参数，且不共享父类引用属性</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.name,boy1.like);	<span class="comment">//小刚，apple</span></span><br><span class="line"></span><br><span class="line">boy1.arr.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boy1.arr,boy2.arr);	<span class="comment">//[1,2]，[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缺点：由于调用了2次父类的构造方法，会存在一份多余的父类实例属性</span></span><br></pre></td></tr></table></figure>

<h2 id="组合继承优化"><a href="#组合继承优化" class="headerlink" title="组合继承优化"></a>组合继承优化</h2><ul>
<li><p>核心：通过这种方式，砍掉父类的实例属性，这样在调用父类的构造函数的时候，就不会初始化两次实例，避免组合继承的缺点</p>
</li>
<li><p>优点：</p>
<ul>
<li>只调用一次父类构造函数</li>
<li>保留组合继承的优点</li>
</ul>
</li>
<li><p>缺点：修正构造函数的指向之后，父类实例的构造函数指向，同时也发生变化(这是我们不希望的)</p>
</li>
</ul>
<p>具体原因：因为是通过原型来实现继承的，Child.prototype上面没有constructor属性，就会往上找，这样就找到了Parent.prototype上面的constructor属性；当修改了子类实例的constructor属性，所有的constructor的指向都会发生变化。（我觉得这个原因说得不对，constructor属性指向自身，Child上有constructor属性，真正原因可能是因为constructor是引用数据类型，所以修改一方才会影响另一方）</p>
<center>
    <img src="https://img-blog.csdnimg.cn/20210209185724235.jpg" width=" 50%">
    <br>
    <font size="3" face="楷体" color="#999"><u>之前的name:undefined 消失了，改进成功</u></font>
</center>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span><br><span class="line"> Parent.call(<span class="built_in">this</span>,name);	<span class="comment">//核心</span></span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = Parent.prototype	<span class="comment">//核心，子类原型和父类原型，实际上是同一个</span></span><br><span class="line">Child.prototype.constructor = Child;<span class="comment">//修复代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child(<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Parent(<span class="string">&#x27;小爸爸&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//优点不演示</span></span><br><span class="line"><span class="comment">//缺点1：当修复子类构造函数的指向后，父类实例的构造函数指向也会跟着变了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(boy1.constructor);<span class="comment">//没修复之前：Parent</span></span><br><span class="line"><span class="built_in">console</span>.log(boy1.constructor,p1.constructor);	<span class="comment">//修复之后：Child,Child 这就是问题所在</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>完美的继承方案</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">this</span>.name = name;	<span class="comment">//实例基本属性(该属性，强调私有，不共享)</span></span><br><span class="line"> <span class="built_in">this</span>.arr = [<span class="number">1</span>];		<span class="comment">//实例引用属性(该属性，强调私用，不共享)</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//将需要复用、共享的方法定义在父类原型上</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,like</span>)</span>&#123;</span><br><span class="line"> Parent.call(<span class="built_in">this</span>,name);	<span class="comment">//核心</span></span><br><span class="line"> <span class="built_in">this</span>.like = like;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//核心 通过创建中间对象，子类原型和父类原型就会隔离开，不再是同一个，有效避免了方式4的缺点</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line"></span><br><span class="line">Child.prototype.constructor = Child;<span class="comment">//修复代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> boy1 = <span class="keyword">new</span> Child(<span class="string">&#x27;小刚&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> boy2 = <span class="keyword">new</span> Child(<span class="string">&#x27;小明&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Parent(<span class="string">&#x27;小爸爸&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(boy1.constructor,p1.constructor);	<span class="comment">//修复之后：Child,Parent</span></span><br></pre></td></tr></table></figure>

<p>其中，Object.create()函数等价为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是中间那段核心代码可改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = object(Parent);</span><br><span class="line"></span><br><span class="line">Child.prototype.constructor = Child;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS常见效果实现</title>
    <url>/2021/08/22/33.CSS%E7%89%B9%E6%95%88%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="旋转立方体"><a href="#旋转立方体" class="headerlink" title="旋转立方体"></a>旋转立方体</h1><p>强调：</p>
<ul>
<li>要对外层容器设置 transform-style:preserve-3d;  否则不能显示3d效果。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">perspective</span>: <span class="number">800px</span></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.cube</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/* background-color: #bfa; */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span></span><br><span class="line"><span class="css">            <span class="comment">/* 设置3d变形效果 */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">transform-style</span>:preserve-<span class="number">3</span>d;</span></span><br><span class="line"><span class="css">            <span class="comment">/* transform: rotateX(45deg) rotateZ(45deg); */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: rotate <span class="number">20s</span> infinite linear;</span></span><br><span class="line"><span class="css">            <span class="comment">/* transform:rotateY(45deg) scaleZ(2); */</span></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.cube</span>&gt;<span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="css">            为元素设置透明效果</span></span></span><br><span class="line"><span class="comment"><span class="css">            opacity作用于元素，以及元素内的所有内容元素</span></span></span><br><span class="line"><span class="comment"><span class="css">            rgba()只作用于元素的颜色或其背景色，元素的子元素不会继承透明效果 </span></span></span><br><span class="line"><span class="comment"><span class="css">            */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">opacity</span>: .<span class="number">8</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">vertical-align</span>: top;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(-<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box3</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box4</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">rotateX</span>(-<span class="number">90deg</span>) <span class="built_in">translateZ</span>(<span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box5</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(-<span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.box6</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">100px</span>);</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">        这是之前的代码，但我发现可以不用旋转。</span></span></span><br><span class="line"><span class="comment"><span class="css">         .box5 &#123;</span></span></span><br><span class="line"><span class="comment"><span class="css">            transform:rotateY(180deg) translateZ(100px);</span></span></span><br><span class="line"><span class="comment"><span class="css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">        .box6 &#123;</span></span></span><br><span class="line"><span class="comment"><span class="css">            transform: rotateY(0deg) translateZ(100px);</span></span></span><br><span class="line"><span class="comment"><span class="css">        &#125;</span></span></span><br><span class="line"><span class="comment"><span class="css">        */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> rotate &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">form</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>:<span class="built_in">rotateX</span>(<span class="number">0</span>) <span class="built_in">rotateZ</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">to</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>:<span class="built_in">rotateX</span>(<span class="number">1turn</span>) <span class="built_in">rotateZ</span>(<span class="number">1turn</span>)</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 创建一个外部的容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cube&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 引入图片 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/14/1.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/14/2.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/14/3.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/14/4.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/14/5.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box6&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./img/14/6.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="钟表"><a href="#钟表" class="headerlink" title="钟表"></a>钟表</h1><blockquote>
<p>关键在于：不要设置指针的旋转，应该把指针放进wrapper内，让wrapper旋转，同时指针跟着转，设置容器无背景颜色，即可以做出正确的指针旋转效果。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        * &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="comment">/* 设置表的样式 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.clock</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/* border: 10px solid black; */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            </span></span><br><span class="line"><span class="css">            <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">./img/13/bg3.jpg</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">background-size</span>: cover;</span></span><br><span class="line"><span class="css">            <span class="comment">/*也可以不用背景图片，用边框*/</span></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.clock</span>&gt;<span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">          <span class="comment">/*钟表内的元素都要居中，故一起设置*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">            <span class="attribute">top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="comment">/* 设置时针 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.hour-wrapper</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: run <span class="number">7200s</span> linear infinite;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.hour</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">6px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="comment">/* 设置分针 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.min-wrapper</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: run <span class="number">600s</span> <span class="built_in">steps</span>(<span class="number">60</span>) infinite;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.min</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">         <span class="comment">/* 设置秒针 */</span></span></span><br><span class="line"><span class="css">         <span class="selector-class">.sec-wrapper</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">90%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">90%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: run <span class="number">10s</span> <span class="built_in">steps</span>(<span class="number">60</span>) infinite;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.sec</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css"><span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="css">        旋转的关键帧</span></span></span><br><span class="line"><span class="comment"><span class="css">*/</span></span></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> run &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">from</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">to</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 创建表的容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clock&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 创建时针 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hour-wrapper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hour&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 创建分针 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;min-wrapper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;min&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 创建秒针 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sec-wrapper&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sec&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>改进： transform-origin</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">6px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">            <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">            <span class="attribute">animation</span>: rotate <span class="number">10s</span> infinite linear;</span><br><span class="line"></span><br><span class="line">            <span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">300px</span>;</span><br><span class="line">            <span class="comment">/*设置变形的原点，应该写在外部，不要写在关键帧内*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">            <span class="selector-tag">from</span>&#123;</span><br><span class="line">                <span class="attribute">transform</span>:<span class="built_in">rotateZ</span>(<span class="number">0deg</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="selector-tag">to</span>&#123;</span><br><span class="line">                <span class="attribute">transform</span>:<span class="built_in">rotateZ</span>(<span class="number">360deg</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="鼠标移入后浮起的效果"><a href="#鼠标移入后浮起的效果" class="headerlink" title="鼠标移入后浮起的效果"></a>鼠标移入后浮起的效果</h1><p><img src="https://img-blog.csdnimg.cn/20201119084720387.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMjM1NzM2,size_16,color_FFFFFF,t_70#pic_center" alt="实现鼠标移入后“浮起来”的效果，如图所示"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">230px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:<span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">transition</span>:all .<span class="number">3s</span></span><br><span class="line">  (同时对平移和影子设置过渡效果)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">transform</span>:<span class="built_in">translateY</span>(-<span class="number">4px</span>);</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小球下落动画"><a href="#小球下落动画" class="headerlink" title="小球下落动画"></a>小球下落动画</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.outer</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-bottom</span>: <span class="number">10px</span> black solid;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.outer</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation</span>: ball .<span class="number">5s</span> forwards linear infinite alternate;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">1s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box3</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">2s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box4</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">3s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box5</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">4s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box6</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">5s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box7</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: tomato;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">6s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box8</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">7s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">div</span><span class="selector-class">.box9</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: chocolate;</span></span><br><span class="line"><span class="css">            <span class="attribute">animation-delay</span>: .<span class="number">8s</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="comment">/* 创建小球下落的动画 */</span></span></span><br><span class="line"><span class="css">        <span class="keyword">@keyframes</span> ball &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">from</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">margin-top</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">            <span class="selector-tag">to</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">margin-top</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">            <span class="comment">/* 2                                    to&#123;</span></span></span><br><span class="line"><span class="comment"><span class="css">                margin-top: 400px;</span></span></span><br><span class="line"><span class="comment"><span class="css">                animation-timing-function: ease-in;</span></span></span><br><span class="line"><span class="comment"><span class="css">            &#125;</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">            40%&#123;</span></span></span><br><span class="line"><span class="comment"><span class="css">                margin-top: 100px;</span></span></span><br><span class="line"><span class="comment"><span class="css">            &#125;</span></span></span><br><span class="line"><span class="comment"><span class="css"></span></span></span><br><span class="line"><span class="comment"><span class="css">            80%&#123;</span></span></span><br><span class="line"><span class="comment"><span class="css">                margin-top: 200px;</span></span></span><br><span class="line"><span class="comment"><span class="css">            &#125; */</span></span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box9&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="鼠标移入后图片放大"><a href="#鼠标移入后图片放大" class="headerlink" title="鼠标移入后图片放大"></a>鼠标移入后图片放大</h1><p>网易新闻的效果：<br><img src="https://img-blog.csdnimg.cn/20201119170416658.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMjM1NzM2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img-wrapper</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">           <span class="attribute">border</span>: <span class="number">1px</span> red solid;</span><br><span class="line">           <span class="attribute">overflow</span>: hidden;</span><br><span class="line">           <span class="comment">/*不能让图片大小超过容器*/</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="selector-tag">img</span>&#123;</span><br><span class="line">           <span class="attribute">transition</span>: .<span class="number">2s</span>;</span><br><span class="line">           <span class="comment">/*添加过渡，更自然*/</span></span><br><span class="line">           <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">           <span class="comment">/*将图片大小设置为100%以填满容器*/</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="selector-class">.img-wrapper</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">           <span class="attribute">transform</span>:<span class="built_in">scale</span>(<span class="number">1.2</span>);</span><br><span class="line">           <span class="comment">/*将图片适当放大*/</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h1 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h1><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p>思路：用边框实现三角形效果。<br>原理：边框交界处是斜的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box1</span>&#123;</span><br><span class="line">          <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">          <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">          <span class="comment">/*设置一个宽高都为0的盒子，只剩边框*/</span></span><br><span class="line">          <span class="attribute">border</span>: <span class="number">100px</span>/*此值改变三角形大小*/ red solid;</span><br><span class="line">          <span class="attribute">border-top</span>: none;</span><br><span class="line">          <span class="comment">/*上边框可以没有*/</span></span><br><span class="line">          <span class="attribute">border-left-width</span>: <span class="number">50px</span>;</span><br><span class="line">          <span class="attribute">border-right-width</span>: <span class="number">50px</span>;</span><br><span class="line">          <span class="comment">/*自由调整这两个值，可以改变三角形形状*/</span></span><br><span class="line">          <span class="attribute">border-color</span>: transparent transparent blue transparent;</span><br><span class="line">          <span class="comment">/*设置transparent，使得左右边框不可见*/</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h1><h3 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.circle</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">clip-path</span>:<span class="built_in">circle</span>(<span class="number">50%</span>);</span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任意多边形"><a href="#任意多边形" class="headerlink" title="任意多边形"></a>任意多边形</h3><p>以三角形为例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span>&#123;</span><br><span class="line"><span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line"><span class="attribute">clip-path</span>:<span class="built_in">polygon</span>(<span class="number">0%</span> <span class="number">0%</span>,<span class="number">100%</span> <span class="number">0%</span>,<span class="number">50%</span> <span class="number">50%</span>);</span><br><span class="line"><span class="comment">/*取几个点围成的区域，如图所示*/</span></span><br><span class="line"><span class="comment">/*几个点是按顺序连的，点的顺序非常重要！顺序不同形状也会不同！*/</span></span><br><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/20201216223805111.jpg" width="10%">
]]></content>
      <categories>
        <category>web开发</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>计组笔记</title>
    <url>/2021/08/24/34.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>书籍 + 笔记 补充的形式完成计网的学习，不做无用功</p>
<h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>运算器：</p>
<ul>
<li>ACC：==累加器==，存放操作数或运算结果</li>
<li>MQ：==乘商寄存器==，在乘除运算时，用于存放操作数和运算结果</li>
<li>X：统一的==操作数寄存器==，用于存放操作数</li>
<li>ALU：==算数逻辑单元==，实现算术运算和逻辑运算</li>
</ul>
<p>控制器：</p>
<ul>
<li>CU：==控制单元==，分析指令，给出控制信号</li>
<li>IR：==指令寄存器==，存放当前执行的指令</li>
<li>PC：==程序计数器==，存放下一条指令地址，有自动加1功能</li>
</ul>
<p>主存：</p>
<ul>
<li>存储体：存放指令和数据</li>
<li>MAR：==地址寄存器==，存放访存地址</li>
<li>MDR：==数据寄存器==，暂存要从存储器中读或写的信息</li>
</ul>
<h3 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h3><blockquote>
<p>(寄存器) 指该寄存器里边的内容，M指主存储器，M(MAR)指主存储器中MAR对应的地址所指明的数据，→MDR指存入MDR</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  y = a * b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://z3.ax1x.com/2021/08/24/hA1j6P.png"></p>
<p>第一条指令（取数）：</p>
<p>取指令（#1~#4）：</p>
<ul>
<li><p>指令和变量的数据存放在存储体中</p>
</li>
<li><p>程序运行之前，PC指向0号位置（第一条指令的存储地址）</p>
</li>
<li><p>接下来，我们应当把该位置存放的指令取出来并执行</p>
<ul>
<li>PC存放的内容需要通过==地址总线==把它传送到MAR中 → MAR中的值变为0（即控制器向主存指明了接下来要访问的是0号地址所对应的数据，#1）</li>
<li>控制器通过==控制总线==告诉主存储器：这次进行的是读操作</li>
<li>主存储器根据MAR记录的地址，去存储体里找出0号地址对应的二进制数据，把它们放入MDR（现在MDR里存放的就是我们想要读取的第一条指令，#3）</li>
</ul>
</li>
<li><p>MDR中的指令通过==数据总线==放入IR（#4）</p>
</li>
<li><p>PC的值自动加1</p>
</li>
</ul>
<p>分析指令（#5）：</p>
<ul>
<li>指令的操作码传送至CU，CU分析后得知这是一条“取数”的指令（#5）</li>
</ul>
<p>执行取数指令（#6~#9）：</p>
<ul>
<li>把地址码所指明的内存单元中的数据取出，放入ACC<ul>
<li>把地址码放入主存的MAR中 → MAR = 5（#6）</li>
<li>主存储器根据这个地址去存储体中找出数据，放入MDR中（#8）</li>
<li>在CU指挥下，MDR中的数据被传到ACC（#9）</li>
</ul>
</li>
</ul>
<p>第二条指令（相乘）：</p>
<p>取指令（#1~#4）步骤相同</p>
<p>分析指令（#5）：</p>
<ul>
<li>指令的操作码传送至CU，CU分析后得知这是一条“乘法”的指令（#5）</li>
</ul>
<p>执行乘法指令（#6~#11）：</p>
<ul>
<li>取出b的步骤相同，但不同的是，b会从MDR传到MQ中（#9）</li>
<li>把a的值先放到X中（<strong>cpu执行乘法操作时，会先把被乘数放到X中，把乘数放到MQ中</strong>，#10）</li>
<li>CU通过控制线告诉ALU，让它进行乘法运算</li>
<li>ALU进行相乘操作，把结果放到ACC中（#11），如果数很大导致ACC存不下，就需要MQ的辅助存储：MQ存放乘法运算结果的低位</li>
</ul>
<p>第三条指令（相加）：</p>
<p>取指令（#1~#4）步骤相同</p>
<p>分析指令（#5）：“加法”指令</p>
<ul>
<li>取出c的步骤相同，但不同的是，c会从MDR传到X中（<strong>cpu执行加法操作时，ACC里先存入被加数，X中存放加数</strong>，#9）</li>
<li>CU通过控制线告诉ALU，让它进行加法运算</li>
<li>ALU执行相加操作，把结果再次存入ACC中</li>
</ul>
<p>第四条指令（存数）：</p>
<p>取指令（#1~#4）步骤相同</p>
<p>分析指令（#5）：“存数”指令</p>
<ul>
<li>将指令的地址码送到MAR，指明这次存入哪一个存储单元</li>
<li>把ACC中结果通过==数据总线==传入MDR中，此时MDR中保存了a*b+c的值，并且MAR指明了该值要存到地址为8的地方</li>
<li>CU通过==控制总线==告诉主存储器：这次进行存数操作</li>
<li>主存储器根据MAR指明的地址，把MDR中的数据放到相应位置当中（8号存储单元的值变为2*3+1 = 7）</li>
</ul>
<p>第五条指令（停机）：前边类似，最后执行操作系统相关的指令，停机</p>
]]></content>
      <categories>
        <category>计组</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——UVA540 团体队列</title>
    <url>/2021/08/25/35.%E6%B4%9B%E8%B0%B7-UVA540%20%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/UVA540">https://www.luogu.com.cn/problem/UVA540</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1001</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; t &amp;&amp; t) &#123;</span><br><span class="line">        map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            cin &gt;&gt; n;</span><br><span class="line">            <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                v[x] = i;     <span class="comment">// 存队列编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Scenario #&quot;</span> &lt;&lt; m++ &lt;&lt; endl;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; team[MAX]; <span class="comment">// MAX支队伍</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; total;     <span class="comment">// 存队号</span></span><br><span class="line">        string op;</span><br><span class="line">        <span class="keyword">while</span> (cin &gt;&gt; op) &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;STOP&quot;</span>)  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;ENQUEUE&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x;</span><br><span class="line">                cin &gt;&gt; x;</span><br><span class="line">                <span class="keyword">int</span> t = v[x]; <span class="comment">// 读取队列编号</span></span><br><span class="line">                <span class="keyword">if</span> (team[t].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    total.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                team[t].<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">&quot;DEQUEUE&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!total.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = total.<span class="built_in">front</span>();</span><br><span class="line">                    cout &lt;&lt; team[t].<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">                    team[t].<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (team[t].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 队伍空了，则将队伍编号从total中移除</span></span><br><span class="line">                        total.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>queue&lt;int&gt; team[MAX];</code>可以直接创建多个队列，把不同成员存入不同队列</li>
<li>使用map来建立队员到某队的映射，之后再读出队员的队号，再把他加入对应的队列</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P1322 logo语言</title>
    <url>/2021/08/26/37.%E6%B4%9B%E8%B0%B7-P1322%20logo%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1322">https://www.luogu.com.cn/problem/P1322</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, l = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; k;      <span class="comment">// s是未读完的字符串，k是前进或倒退的值</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">            v = <span class="built_in">getchar</span>();  <span class="comment">// 读&#x27;[&#x27;</span></span><br><span class="line">            l += k * <span class="built_in">recursion</span>();</span><br><span class="line">            v = <span class="built_in">getchar</span>();  <span class="comment">// 读&#x27;]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            v = <span class="built_in">getchar</span>();</span><br><span class="line">            l -= k;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">            v = <span class="built_in">getchar</span>();</span><br><span class="line">            l += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="built_in"><span class="keyword">int</span></span>(<span class="string">&#x27;]&#x27;</span>)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(<span class="built_in">recursion</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一道递归题，要点：</p>
<ul>
<li><p>使用cin &gt;&gt; s，getchar() 读掉多余的字符串</p>
</li>
<li><p>关键是如何解析字符串，得到想要的值</p>
</li>
<li><p>getchar在头文件<code>cstdio</code>中</p>
</li>
<li><p>绝对值函数<code>abs()</code>的运用</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——AHOI2017初中组 rexp</title>
    <url>/2021/08/26/36.%E6%B4%9B%E8%B0%B7-AHOI2017%E5%88%9D%E4%B8%AD%E7%BB%84rexp/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3719">https://www.luogu.com.cn/problem/P3719</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; c &amp;&amp; c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;a&#x27;</span>) j++;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) j = j + <span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;|&#x27;</span>) <span class="keyword">return</span> <span class="built_in">max</span>(j, <span class="built_in">p</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不应该被“先算带括号的序列”误导，只需把括号里的部分视作一个整体即可。</p>
<p>本题用到了递归调用栈的想法：</p>
<ul>
<li>如果遇到’a’，增加个数。</li>
<li>如果遇到’|’，在调用max的时候也会计算p(0)，这个p(0)是从’|’右侧开始算的，即’|’右侧的’a’的个数。</li>
<li>如果遇到’(‘，会从’(‘的右侧开始计算p(0)；遇到’)’，则返回这个括号内a的个数。如aa(aa)，得到2之后开始算(aa)里a的个数，得到4，再返回。</li>
</ul>
<p>就这样，把复杂的问题拆解成小规模问题，算出结果。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P3884 [JLOI2009]二叉树问题</title>
    <url>/2021/08/26/38.%E6%B4%9B%E8%B0%B7-P3884%20%5BJLOI2009%5D%E4%BA%8C%E5%8F%89%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3884">https://www.luogu.com.cn/problem/P3884</a></p>
<p>LCA：最近公共祖先</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, fa[<span class="number">1001</span>], root[<span class="number">1001</span>], son[<span class="number">1001</span>], depth[<span class="number">1001</span>], width[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;       <span class="comment">// 求最近公共祖先</span></span><br><span class="line"> <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x;                 <span class="comment">// 两个点如果相同，那么 LCA 就是它本身</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (depth[x] == depth[y]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lca</span>(fa[x], fa[y]); <span class="comment">// 如果两个点深度相同，就访问它们的父亲结点</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (depth[x] &lt; depth[y]) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lca</span>(x, fa[y]);     <span class="comment">// 如果x的深度小于y的深度，就访问y的父亲结点，直到x y 深度相同</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lca</span>(fa[x], y);     <span class="comment">// 同理</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> cin &gt;&gt; n;</span><br><span class="line"> depth[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  cin &gt;&gt; root[i] &gt;&gt; son[i];</span><br><span class="line">  depth[son[i]] = depth[root[i]] + <span class="number">1</span>;  <span class="comment">// 子结点的深度 = 父亲结点的深度 + 1</span></span><br><span class="line">  fa[son[i]] = root[i];                <span class="comment">// 记录结点的父子关系</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">int</span> x, y;</span><br><span class="line"> cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"> <span class="keyword">int</span> max_depth = <span class="number">1</span>;     <span class="comment">// 记录深度</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  max_depth = <span class="built_in">max</span>(max_depth, depth[i]);</span><br><span class="line">  width[depth[i]]++; <span class="comment">// 记录不同深度的结点个数</span></span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; max_depth &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">int</span> max_width = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  max_width = <span class="built_in">max</span>(max_width, width[i]);</span><br><span class="line"> &#125;</span><br><span class="line"> cout &lt;&lt; max_width &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">int</span> k = <span class="built_in">lca</span>(x, y);     <span class="comment">//求 LCA 的结点序号</span></span><br><span class="line"> cout &lt;&lt; (depth[x] - depth[k]) * <span class="number">2</span> + (depth[y] - depth[k]);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要点：</p>
<ul>
<li><p>树的深度、宽度不一定要用递归的方式求</p>
<p>可以开depth数组记录每个结点所在的层数，并且子结点深度 = 父结点深度 + 1</p>
<p>之后遍历每个结点就可以得到最大深度</p>
</li>
<li><p>宽度同理，开width数组</p>
<p>遍历每个结点，巧妙的是，根据每个结点的depth值，算出每一层的宽度，并存入width不同的位置</p>
<p>之后遍历width数组就可以得到最大宽度</p>
</li>
<li><p>最后，还需要关注lca（最近公共祖先），根据代码注释来理解</p>
<p>据说这是一个暴力lca，应该可以有优化版本，在此谢过原题解作者</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>LCA</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>linux笔记</title>
    <url>/2021/08/26/39.Linux%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="网络连接的三种方式"><a href="#网络连接的三种方式" class="headerlink" title="网络连接的三种方式"></a>网络连接的三种方式</h2><p>同一网段下（如在192.168.0下）的主机可以互相通信</p>
<p>三种方式：</p>
<ul>
<li><p>桥接模式：虚拟系统可以和外部系统相互通讯，但是容易造成IP冲突</p>
</li>
<li><p>NAT模式：网络地址转换模式，虚拟系统可以和外部系统相互通讯（通过代理），不造成IP冲突</p>
</li>
<li><p>主机模式：独立系统，不与外部发生联系</p>
</li>
</ul>
<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>特点：</p>
<ul>
<li>层级式的树状目录结构</li>
<li>linux中一切皆文件（linux会把硬件映射成文件来管理）</li>
</ul>
<p>具体目录结构：</p>
<ul>
<li>/bin ：存放常用命令</li>
<li>/sbin：存放系统管理员使用的系统管理程序</li>
<li>/home：存放普通用户的主目录，目录名以用户账号命名</li>
<li>/root：系统管理员主目录</li>
<li>/lib：系统开机所需要的动态连接共享库</li>
<li>/lost+found：一般是空的，系统非法关机后会存放一些文件</li>
<li>/etc：系统管理所需的<strong>配置文件</strong>(.conf)和子目录</li>
<li>/usr：存放用户的应用程序和文件</li>
<li>/usr/local：给主机额外安装软件所存放的目录，一般通过编译源码方式安装的程序</li>
<li>/opt：给主机额外安装软件所存放的目录</li>
<li>/boot：存放<strong>启动</strong>linux的核心文件</li>
<li>/proc：虚拟目录，是系统内存的映射，访问该目录可获取系统信息</li>
<li>/srv：存放服务启动后需要提取的数据</li>
<li>/sys：该目录安装了文件系统sysfs</li>
<li>/tmp：存放临时文件</li>
<li>/dev：<strong>设备管理器</strong>，把所有硬件用文件形式存储</li>
<li>/media：linux识别U盘、光驱后，把这些<strong>设备挂载</strong>到该目录下</li>
<li>/mnt：该目录可<strong>挂载外部的存储</strong>（临时挂载其他文件系统）</li>
<li>/var：存惯存放经常被修改的目录，包括日志文件</li>
</ul>
<h2 id="远程登陆和文件传输"><a href="#远程登陆和文件传输" class="headerlink" title="远程登陆和文件传输"></a>远程登陆和文件传输</h2><ul>
<li><p>准备工作：下载xshell和xftp</p>
</li>
<li><p>使用<code>ifconfig</code>查看虚拟机ip</p>
</li>
<li><p>cmd ping 以上ip，确保互通</p>
</li>
<li><p>xshell和xftp的操作略，需要时看视频</p>
</li>
</ul>
<h2 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h2><p>常用快捷键（不声明则在标准模式下）：</p>
<ul>
<li><code>yy</code>拷贝当前行，<code>5yy</code>拷贝当前行向下的5行，<code>p</code>粘贴至光标处</li>
<li><code>dd</code>删除当前行，<code>5dd</code>删除当前行向下的5行</li>
<li>查找：<code>/关键字</code>，回车查找，输入<code>n</code>查找下一个</li>
<li>设置行号：<code>:set nu</code>和<code>:set nonu</code></li>
<li><code>G</code>到文档末行，<code>gg</code>到文档首行</li>
<li><code>u</code>撤销</li>
</ul>
<p>tips：</p>
<ul>
<li>写文件名到一半，按<code>tab</code>有代码补全功能</li>
</ul>
<h2 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h2><ul>
<li><code>shutdown -h now</code>：立刻关机</li>
<li><code>shutdown -h 1</code>：1分钟后关机</li>
<li><code>shutdown -r now</code>：立刻重启</li>
<li><code>halt</code>：关机（使用该命令后虚拟机只是提示cpu已禁用，还需要在虚拟机里手动关机）</li>
<li><code>reboot</code>：重启</li>
<li><code>sync</code>：把内存数据同步到磁盘</li>
</ul>
<p>tips：</p>
<ul>
<li>最好在关机和重启前执行<code>sync</code>，避免内存数据丢失，尽管关机重启前会默认执行sync，但小心为妙</li>
</ul>
<h2 id="登录注销"><a href="#登录注销" class="headerlink" title="登录注销"></a>登录注销</h2><ul>
<li><p><code>su - 用户名</code>：切换用户，如 su - root 切换到管理员；从权限高的用户切换到权限低的用户，不需要密码，反之需要</p>
</li>
<li><p>shell（运行级别3，在GUI下不可）下输入<code>logout</code>可以注销用户，使用<code>exit</code>登出的效果类似</p>
<p>假设第一次登录的用户是tom，tom使用 su - root 切换到管理员，此时logout，会从管理员变为tom，再logout，会退出系统</p>
</li>
</ul>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="增删用户"><a href="#增删用户" class="headerlink" title="增删用户"></a>增删用户</h3><ul>
<li><code>useradd 用户名</code>：创建用户，并在/home下生成同名文件夹，作为该用户的文件夹</li>
<li><code>useradd -d 指定目录 用户名</code>：把指定目录作为该用户的文件夹</li>
<li><code>passwd 用户名</code>：设置某一用户的密码，<strong>如果不加用户名，设置的是当前登录用户的密码</strong></li>
<li><code>userdel 用户名</code>：删除用户，但保留家目录</li>
<li><code>userdel -r 用户名</code>：删除用户，同时删除家目录</li>
</ul>
<p>tips：</p>
<ul>
<li>删除用户前，最好使用logout退登，再重新登录root，防止删除普通用户时，这个用户还登陆着（如果从普通用户登录，使用su - root登录管理员，那么该普通用户仍保持着登陆状态）</li>
<li>不要轻易删除家目录</li>
</ul>
<h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><ul>
<li><code>id 用户名</code>：查看用户信息</li>
<li><code>whoami/who am i</code>：查看当前第一次登录的用户信息</li>
</ul>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li><p><code>groupadd 组名</code>：新增组</p>
</li>
<li><p><code>groupdel 组名</code>：删除组</p>
</li>
<li><p><code>useradd -g 用户组 用户名</code>：创建用户，并将其添加至指定用户组</p>
<p>如果直接使用<code>useradd 用户名</code>，会自动创建和该用户同名的组，再把该用户添加至这个组内</p>
</li>
<li><p><code>usermod -g 用户组 用户名</code>：修改用户的组</p>
</li>
<li><p><code>usermod -d 目录 用户名</code>：改变该用户登录的初始目录（该用户必须拥有进入该目录的权限）</p>
</li>
</ul>
<h4 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h4><ol>
<li><p>/etc/passwd</p>
<p>用户的配置文件，记录用户的各种信息</p>
<p>每行的含义：==用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell==</p>
<p>Shell：linux内核是不认识各种指令的，可以认为shell帮助翻译了指令。一般情况下，shell是bash</p>
</li>
<li><p>/etc/shadow</p>
<p>口令的配置文件</p>
<p>每行的含义：==登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志==</p>
</li>
<li><p>/etc/group</p>
<p>组配置文件，记录linux包含的组的信息</p>
<p>每行的含义：==组名:口令:组标识号:组内用户列表==</p>
</li>
</ol>
<h3 id="用户级别"><a href="#用户级别" class="headerlink" title="用户级别"></a>用户级别</h3><p>运行级别说明：</p>
<ul>
<li><p>0：关机</p>
</li>
<li><p>1：单用户（找回丢失密码，视频在下一节，本人跳过）</p>
</li>
<li><p>2：多用户状态，无网络服务</p>
</li>
<li><p><strong>3：多用户状态，有网络服务</strong></p>
</li>
<li><p>4：自定义</p>
</li>
<li><p>5：图形界面</p>
</li>
<li><p>6：重启</p>
</li>
</ul>
<p>指令：</p>
<ul>
<li><p><code>init [0123456]</code>：切换运行级别</p>
<p>init 0可关机，init 6可重启</p>
</li>
<li><p><code>systemctl get-default</code>：查看默认运行级别</p>
</li>
<li><p><code>systemctl set-default target名称</code>：修改默认运行级别</p>
<p>target一般有两种：<code>multi-user.target</code>（级别3）和<code>graphical.target</code></p>
</li>
</ul>
<h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ul>
<li><code>man 指令</code>：获得某指令的帮助信息（按<strong>空格</strong>可以直接跳到下一页）</li>
<li><code>help 指令</code>：获得<strong>shell内置命令</strong>的帮助信息</li>
</ul>
<p>tips：</p>
<ul>
<li>linux下，隐藏文件以 . 开头</li>
<li>指令的选项可以组合使用，如ls -al和ls -la /root</li>
</ul>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="目录增删"><a href="#目录增删" class="headerlink" title="目录增删"></a>目录增删</h3><ul>
<li><code>ls -h</code>：将文件大小以人类可以读懂的方式显示，如433M（不开-h，默认显示字节数）</li>
<li><code>ls -R</code>：递归显示整个目录的内容</li>
<li><code>ll</code>：相当于<code>ls -l</code>，显示详细信息。因此也可以写ll -ah</li>
<li><code>cd ~</code>或<code>cd</code>：回到自己的家目录，比如你是root，那么cd ~到 /root</li>
<li><code>mkdir -p</code>：创建多级目录，如mkdir -p /home/animal/tiger。如果不加-p，linux必须得找到上一级目录才会创建下一级目录，否则会报错</li>
<li><code>cp -r 源目录 目标目录</code>：递归复制整个文件夹，如cp -r /home/bbb /opt（将整个目录拷贝到/opt），如果需要强制覆盖不提示，把cp改为<code>\cp</code></li>
<li><code>rm -r 目录</code>：递归删除整个目录，如果需要强制删除不提示，再加<code>-f</code>选项</li>
</ul>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p>知识补充：</p>
<ul>
<li>管道命令：把前一个命令的结果交给下一个命令处理，类似于命令的组合</li>
</ul>
<ul>
<li><p><code>cat -n 文件名</code>：读文件，带行号。比vm读更安全，因为只能读不能改</p>
</li>
<li><p><code>more 文件名</code>：读文件，并提供了多种交互功能，交互如下：</p>
<ul>
<li>空白：向下翻动一页</li>
<li>q：离开程序</li>
</ul>
</li>
<li><p><code>cat -n 文件名| more</code>：这是一个管道命令，把cat的结果交给more，好处：使用more也可以显示行号</p>
</li>
<li><p><code>less 文件名</code>：交互比more更多，并且<strong>动态读取文本</strong>，而不是一下子把文本全部载入内存，推荐使用</p>
<ul>
<li>PgUp：向上翻动一页</li>
<li>PgDn：向下翻动一页</li>
<li>/字串：向下搜寻【字串】的功能；n：向下查找；N：向上查找（记住它）</li>
<li>?字串：向上搜寻【字串】的功能；n：向上查找；N：向下查找</li>
<li>G：跳转至末尾</li>
<li>g：跳转至开头</li>
</ul>
</li>
<li><p><code>head 文件</code>：查看文件前10行内容，<code>tail</code>查看后10行内容</p>
</li>
<li><p><code>head -n 5 文件</code>：查看文件前5行内容</p>
</li>
</ul>
<h3 id="覆盖追加"><a href="#覆盖追加" class="headerlink" title="覆盖追加"></a>覆盖追加</h3><ul>
<li><p><code>echo 环境变量</code>：查看环境变量，如echo $PATH</p>
</li>
<li><p><code>echo &quot;内容&quot;</code>：将内容打印在屏幕上，如echo “hello”</p>
</li>
<li><p><code>tail -f 文件</code>：实时追踪文档的所有更新</p>
</li>
</ul>
<p>&gt;表示覆盖写，&gt;&gt;表示追加写</p>
<ul>
<li><code>ls -l &gt; 文件</code>：将列表内容写入文件（目标文件不存在就会自动创建，下同）</li>
<li><code>cat 文件1 &gt; 文件2</code>：将文件1的内容覆盖到文件2</li>
<li><code>echo &quot;内容&quot; &gt;&gt; 文件 </code>：将内容追加进文件</li>
<li><code>cal &gt;&gt; 文件</code>：将日历信息追加进文件</li>
</ul>
<p>补充：</p>
<ul>
<li><code>&gt; 文件</code>也可以用于创建文件</li>
<li><code>echo &quot;&quot; &gt; 文件</code>可以用于把文件置空</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p><code>软链接</code>又称为符号链接，类似于win中的快捷方式，存放了链接其他文件的路径</p>
<ul>
<li><p><code>ln -s 原文件或目录 软链接名</code>：为原文件创建一个软链接</p>
<p>创建好指向某一目录的软链接，并cd进入软链接以后，使用ls，看到的列表 和 在原目录下看到的列表 一致</p>
<p>使用pwd查看目录时，仍然看到的是软链接所在目录</p>
</li>
<li><p><code>rm 软链接名</code>：删除软链接，如rm /home/myroot</p>
</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul>
<li><code>history</code>：显示所有的历史指令</li>
<li><code>history 10</code>：显示最近使用过的10个指令</li>
<li><code>!5</code>：执行历史编号为5的指令</li>
</ul>
<h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><p>字母注意大小写：</p>
<ul>
<li><p><code>date</code>：显示当前时间</p>
</li>
<li><p><code>date +%Y </code>：显示当前年份</p>
</li>
<li><p><code>date +%m</code>：月份</p>
</li>
<li><p><code>date +%d</code>：天</p>
</li>
<li><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月日时分秒</p>
<p>引号内除第一个加号必需，后面的-和空格只是起修改格式的作用，可以任意修改</p>
</li>
</ul>
<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><ul>
<li><p><code>find 搜索范围 选项</code>： 从指定目录向下递归地遍历各个子目录，将满足条件的文件或目录显示在终端</p>
<ul>
<li>-name 按指定文件名查找</li>
<li>-user 查找属于某一用户名的所有文件</li>
<li>-size 按照大小查找，+n大于，-n小于，n等于，如<code>find / -size +200M</code></li>
</ul>
<p>可以组合使用 | less，避免显示内容过长不便于阅读</p>
</li>
<li><p><code>locate 文件名</code>：快速定位文件路径</p>
<p>locate指令利用事先建立的==系统中所有文件名称及路径的locate数据库==实现快速定位给定的文件，无需遍历整个文件系统</p>
<p>使用locate之前，先使用<code>updatedb</code>更新locate数据库</p>
</li>
<li><p><code>which 指令名</code>：查看指令所在的目录</p>
</li>
<li><p><code>grep 选项 查找内容 文件名</code>：筛选文件的特定内容</p>
<ul>
<li>-n：显示匹配行及行号</li>
<li>-i：忽略字母大小写</li>
<li>-v：反向匹配</li>
</ul>
<p>可以直接用grep，也可以用管道指令，如==grep -n “yes” hello.txt== 等价于 ==cat hello.txt | grep “yes”==</p>
</li>
</ul>
<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><ul>
<li><p><code>gzip 文件</code>：将文件压缩为*.gz文件（将原本的文件变为压缩文件，而不是新生成压缩文件）</p>
</li>
<li><p><code>gunzip 压缩文件</code>：解压缩</p>
</li>
<li><p><code>zip 选项 压缩后的文件名 目录或文件 </code>：压缩文件，选项-r表示递归压缩</p>
<p>在“压缩后的文件名”处还可以提供压缩后文件所在的目录</p>
<p>如zip -r /opt/myhome.zip /home，表示将home目录及其包含的文件和子目录都压缩为/opt目录下的myhome.zip文件，同时原目录/文件被保留，相当于新生成了压缩文件</p>
</li>
<li><p><code>unzip 压缩文件</code>：解压缩</p>
<ul>
<li><code>unzip -d 目录 压缩文件</code>：指定压缩文件解压缩到某个目录下，如unzip -d /tmp /home/myhome.zip，表示将该压缩文件解压到/tmp目录下</li>
</ul>
</li>
<li><p><code>tar 选项 xxx.tar.gz 打包的内容</code>：打包目录，压缩后的文件格式.tar.gz</p>
<p>选项：</p>
<ul>
<li>-c：产生.tar打包文件</li>
<li>-v：显示详细信息</li>
<li>-f：指定压缩后的文件名</li>
<li>-z：打包同时压缩</li>
<li>-x：解包.tar文件</li>
<li>-C：解压到的位置</li>
</ul>
<p>案例：</p>
<ul>
<li>==tar -zcvf test.tar.gz a.txt b.txt==：压缩多个文件（空格分隔文件名）</li>
<li>==tar -zcvf test.tar.gz /dir==：压缩某个目录</li>
<li>==tar -zxvf test.tar.gz==：解压到当前目录</li>
<li>==tar -zxvf test.tar.gz -C /opt==：解压到/opt目录下</li>
</ul>
</li>
</ul>
<h2 id="linux组"><a href="#linux组" class="headerlink" title="linux组"></a>linux组</h2><h3 id="修改所有者和所在组"><a href="#修改所有者和所在组" class="headerlink" title="修改所有者和所在组"></a>修改所有者和所在组</h3><p>linux中的<strong>每个文件</strong>有所有者、所在组、其它组的概念</p>
<ul>
<li><code>chown 用户名 文件名</code>：修改文件/目录的所有者</li>
<li><code>chown 用户名:组名 文件/目录</code>：同时修改文件/目录的所有者和所在组</li>
<li><code>chgrp 组名 文件名</code>：修改文件/目录所在的组</li>
<li><code>-R</code>：添加这个选项后，如果是目录，其下所有子文件或目录递归生效</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>ls -l后，会看到很多信息，如：==-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc==</p>
<p>0-9位说明：</p>
<ul>
<li>第0位确定文件类型：<ul>
<li>-：普通文件</li>
<li>d：目录</li>
<li>l：软链接</li>
<li>c：字符设备文件，如鼠标、键盘</li>
<li>b：块设备文件，如键盘</li>
</ul>
</li>
<li>第1-3位确定所有者的权限，第4-6位确定所属组的权限，第7-9位确定其他用户的权限</li>
</ul>
<p>rwx权限：</p>
<ul>
<li>到文件：<ul>
<li>r：可读取、查看</li>
<li>w：可修改，但不代表可以删除文件，删除文件的前提条件是<strong>用户对文件所在的目录有写权限</strong></li>
<li>x：可执行</li>
</ul>
</li>
<li>到目录：<ul>
<li>r：可以用ls查看目录内容</li>
<li>w：可在目录内创建和删除（也可以删除目录），可以重命名目录</li>
<li>x：可以进入目录</li>
</ul>
</li>
</ul>
<p>其他说明：</p>
<ul>
<li>1：如果只有一个文件，则该数为1；如果是目录，该数 = 子目录数 + 目录下文件数（只用找一层）</li>
</ul>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>第一种方式：u：所有者，g：所属组，o：其它组，a：所有人</p>
<ul>
<li><code>chmod u=rwx,g=rx,o=x 文件/目录名</code>：设置权限</li>
<li><code>chmod o+w o+w 文件/目录名</code>：增加权限</li>
<li><code>chmod a-x 文件/目录名</code>：减少权限</li>
</ul>
<p>第二种方式：r=4，w=2，x=1</p>
<ul>
<li><code>chmod 751 文件/目录名</code>等价于上方的第一条</li>
</ul>
<h1 id="实操篇"><a href="#实操篇" class="headerlink" title="实操篇"></a>实操篇</h1><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="crontab-任务调度"><a href="#crontab-任务调度" class="headerlink" title="crontab 任务调度"></a>crontab 任务调度</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>任务调度：指系统在某个时间执行的特定的命令或程序</p>
<p>分类：</p>
<ul>
<li>系统工作：有些重要的工作必须周而复始地进行，如病毒扫描等</li>
<li>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份（也可以只是执行一条简单指令）</li>
</ul>
<p>指令：</p>
<ul>
<li><code>crontab 选项</code>：<ul>
<li>-e：编辑crontab定时任务</li>
<li>-l：查询crontab任务（列出当前有哪些任务调度）</li>
<li>-r：删除当前用户所有的crontab任务（终止任务调度）</li>
</ul>
</li>
<li><code>service crond restart</code>：重启任务调度</li>
</ul>
<p>操作：</p>
<ul>
<li>设置任务调度：crontab -e</li>
<li>输入任务到调度文件，如：==*/1 * * * * ls -l /etc &gt; /tmp/to.txt==，意思是每分钟执行ls -l /etc…这个指令</li>
</ul>
<p>5个占位符的说明：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个 *</td>
<td>一小时中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个 *</td>
<td>一天中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个 *</td>
<td>一个月中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个 *</td>
<td>一年中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个 *</td>
<td>一周中的星期几</td>
<td>0-7（0和7代表星期日）</td>
</tr>
</tbody></table>
<blockquote>
<p>星期几和几号最好不要同时出现，容易使人混乱</p>
</blockquote>
<p>特殊符号的说明：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间</td>
</tr>
<tr>
<td>,</td>
<td>代表不连续的时间，如”0 8,12,16 * * *”命令，表示在每天8:00，12:00，16:00都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间，如”0 5 * * 1-6”命令，表示在周一到周六的凌晨5点执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次，如”*/10 * * * *”命令，表示每隔10分钟就执行一次命令</td>
</tr>
</tbody></table>
<h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><p>将命令写入脚本，通过执行脚本来执行命令：</p>
<ol>
<li><code>vim xxx.sh</code> 写入内容，如 date &gt;&gt; /home/mycal 和 cal &gt;&gt; /home/mycal</li>
<li>给xxx.sh增加执行权限，<code>chmod u+x xxx.sh</code></li>
<li><code>crontab -e</code>增加 ==*/1 * * * * xxx.sh==</li>
</ol>
<h3 id="at-定时任务"><a href="#at-定时任务" class="headerlink" title="at 定时任务"></a>at 定时任务</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>简介：</p>
<ul>
<li>at命令是<strong>一次性定时计划任务</strong>，at的守护进程atd会以后台模式运行，检查作业队列来运行</li>
<li>默认情况下，atd守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</li>
<li>at命令执行完一个任务后，以后不再执行此任务</li>
<li>使用at命令时需要保证atd进程的启动，可以使用<code>ps -ef | grep atd</code>来检测atd是否在运行（ps -ef 用于检测当前运行的所有进程）</li>
</ul>
<p>at命令格式：</p>
<ul>
<li><code>at 选项 时间</code>：添加at任务</li>
<li><code>atq</code>：查看系统中没有执行的工作任务</li>
<li><code>atrm 编号</code>：从队列中删除指定编号的任务</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-m</td>
<td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td>
</tr>
<tr>
<td>-I</td>
<td>atq的别名</td>
</tr>
<tr>
<td>-d</td>
<td>atrm的别名</td>
</tr>
<tr>
<td>-v</td>
<td>显示任务将被执行的时间</td>
</tr>
<tr>
<td>-c</td>
<td>打印任务的内容到标准输出</td>
</tr>
<tr>
<td>-V</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-q &lt;队列&gt;</td>
<td>使用指定队列</td>
</tr>
<tr>
<td>-f &lt;文件&gt;</td>
<td>从指定文件读入任务，而不是从标准输入读入</td>
</tr>
<tr>
<td>-t &lt;时间参数&gt;</td>
<td>以时间参数的形式提交要运行的任务</td>
</tr>
</tbody></table>
<p>at时间定义：</p>
<img src="https://z3.ax1x.com/2021/08/29/h8QD2t.png" style="zoom: 80%;">

<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>输入at指令开始编辑后，退出时，按两次<code>ctrl + D</code></p>
<ul>
<li><p>案例1：2天后的下午5点执行 ls /home：</p>
<p>at 5pm +2days</p>
<p>ls /home</p>
</li>
<li><p>案例2：2分钟后，输出时间到指定文件内：</p>
<p>at now +2minutes</p>
<p>date &gt; /root/date.log</p>
</li>
</ul>
<h2 id="磁盘分区与挂载"><a href="#磁盘分区与挂载" class="headerlink" title="磁盘分区与挂载"></a>磁盘分区与挂载</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每块硬盘有多个分区，而linux系统中有多个目录，所谓“挂载”，就是把一个分区和一个目录联系起来</p>
<p>真正存放数据的是分区，比如在下图中，如果在/home下创建文件，就会把该文件存入分区1</p>
<img src="https://z3.ax1x.com/2021/08/29/h83RaD.png" style="zoom:80%;">

<p>硬盘说明：</p>
<ul>
<li>linux硬盘分为<code>IDE硬盘</code>和<code>SCSI硬盘</code>，目前以后者为主</li>
<li>IDE硬盘的标识为”hdx~“，SCSI硬盘的标识为”sdx~“</li>
<li>x为盘号，a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘（或简单理解为第一个盘、第二个盘…）</li>
<li>~代表分区，前四个分区用1到4表示，它们是主分区或拓展分区。从5开始是逻辑分区</li>
</ul>
<p>指令：</p>
<ul>
<li><code>lsblk</code>：查看设备挂载情况</li>
<li><code>lsblk -f</code>：信息更详细，显示磁盘每个分区对应的40位唯一标识符（当且仅当分区格式化后，才会生成该UUID）</li>
</ul>
<h3 id="增加磁盘实例"><a href="#增加磁盘实例" class="headerlink" title="增加磁盘实例"></a>增加磁盘实例</h3><p>步骤：虚拟机添加硬盘→分区→格式化→挂载→设置可以自动挂载</p>
<ul>
<li><p>虚拟机添加硬盘：vmware内操作，设置→添加硬盘→一路下一步</p>
<p>reboot 重启系统才能识别新的硬盘</p>
</li>
<li><p>分区：</p>
<ul>
<li><p><code>fdisk /dev/sdb</code>开始对/sdb 分区，具体操作：</p>
<ol>
<li><p>开始分区后输入n，新增分区</p>
</li>
<li><p>然后选择p，分区类型为主分区</p>
</li>
<li><p>两次回车，默认剩余全部空间</p>
</li>
<li><p>输入w</p>
</li>
</ol>
<p>m：显示命令列表</p>
<p>p：显示磁盘分区，同 <code>fdisk -l</code></p>
<p>n：新增分区</p>
<p>d：删除分区</p>
<p>w：写入并退出</p>
<p>q：不保存退出</p>
</li>
</ul>
</li>
<li><p>格式化磁盘：</p>
<ul>
<li><code>mkfs -t ext4 /dev/stb1</code>：格式化命令，其中ext4是分区类型</li>
</ul>
</li>
<li><p>挂载：</p>
<ul>
<li><code>mount 设备名称 挂载目录</code>：如 mount /dev/sdb1 /newdisk</li>
<li><code>umount 设备名称/挂载目录</code>：卸载命令，如 umount /dev/sdb1 或 umount /newdisk</li>
<li>注意：用命令行挂载，<strong>重启后会失效</strong></li>
</ul>
</li>
<li><p>设置自动挂载：修改/etc/fstab，添加完成后，执行mount -a即刻生效（重启也可生效）</p>
<p>最前面的UUID也可以填写设备名称，如/dev/sdb1，最后两个参数写 0 0（目前不懂）</p>
</li>
</ul>
<h3 id="取消挂载的情况"><a href="#取消挂载的情况" class="headerlink" title="取消挂载的情况"></a>取消挂载的情况</h3><p>情景：当取消挂载后，原文件夹里的文件访问不到了，如何解决？</p>
<p>比如说，先创建了dir1，把/dev/sdb1 挂载到dir1上，并在dir1内创建了几个文件。现在取消挂载，再进入dir1，发现找不到这些文件了。</p>
<p>做法：再创建dir2，把/dev/sdb1 挂载到dir2上，就能找回那些文件了</p>
<h3 id="转移硬盘的情况"><a href="#转移硬盘的情况" class="headerlink" title="转移硬盘的情况"></a>转移硬盘的情况</h3><p>（以下内容是自己总结的，未必准确，以后可能修改）</p>
<p>情景：/dev/sdb1此时挂载在dir上，现在我们想让/dev/sdb2挂载到dir上</p>
<p>做法：</p>
<ul>
<li>创建新的目录/new，使用<code>mv /dir/* /new</code>将dir中的内容剪切过去</li>
<li>取消挂载</li>
<li>将另一块硬盘挂载到/new目录下</li>
</ul>
<h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><ul>
<li><p><code>df -h</code>：查询系统整体磁盘使用情况</p>
</li>
<li><p><code>du -h</code>：查询指定目录的磁盘占用情况，默认为当前目录</p>
<p>选项：</p>
<ul>
<li>-h：带计量单位</li>
<li>-a：带文件，而不仅是子目录</li>
<li>–max-depth=1：子目录深度</li>
<li>-c：列出明细的同时，增加汇总值</li>
</ul>
<p>应用：==du -hac –max-depth=1 /opt==可查询/opt目录的磁盘占用情况，深度为1</p>
</li>
</ul>
<h3 id="磁盘实用指令"><a href="#磁盘实用指令" class="headerlink" title="磁盘实用指令"></a>磁盘实用指令</h3><p>grep可以接收一个正则表达式，以下指令如果不加 wc -l，则页面上只显示文件/文件夹：</p>
<ol>
<li><code>ls -l /opt | grep &quot;^-&quot; | wc -l</code>：统计/opt目录下文件的个数</li>
<li><code>ls -l /opt | grep &quot;^d&quot; | wc -l</code>：统计/opt目录下一级子目录的个数</li>
<li><code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code>：统计/opt目录下全部文件的个数，包括子目录里的</li>
<li><code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code>：统计/opt目录下全部目录的个数，包括子目录里的</li>
<li><code>tree 目录</code>：以树状显示目录结构，需要先<code>yum install tree</code>按照tree指令</li>
</ol>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>NAT网络配置原理图：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGeMJx.png" style="zoom:80%;">

<p>可见，linux虚拟机和vmnet8的ip地址是一样的</p>
<p>指令：</p>
<ul>
<li><code>ipconfig</code>：查看windows的网络配置</li>
<li><code>ifconfig</code>：查看linux的网络配置</li>
<li><code>ping 目的主机</code>：测试当前服务器是否可以连接目的主机</li>
</ul>
<h3 id="配置静态ip"><a href="#配置静态ip" class="headerlink" title="配置静态ip"></a>配置静态ip</h3><p>默认情况下，linux的ip是自动获取的，每次获取的ip地址可能不一样，因此我们需要指定ip</p>
<p>指定ip的方法：<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从DHCP修改为static</span></span><br><span class="line">BOOTPROTO=&quot;static&quot; </span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;49034b55-e0a4-4493-a105-50ab889139ad&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">IP地址</span></span><br><span class="line">IPADDR=192.168.200.130</span><br><span class="line"><span class="meta">#</span><span class="bash">网关</span></span><br><span class="line">GATEWAY=192.168.200.2</span><br><span class="line"><span class="meta">#</span><span class="bash">域名解析器</span></span><br><span class="line">DNS1=192.168.200.2</span><br></pre></td></tr></table></figure>

<p>修改后，使用<code>service network restart</code>或<code>reboot</code>生效</p>
<p>同时，还要修改vmware中虚拟网络编辑器中的ip，和xshell的属性（见视频）</p>
<h3 id="主机名和hosts映射"><a href="#主机名和hosts映射" class="headerlink" title="主机名和hosts映射"></a>主机名和hosts映射</h3><p>Hosts：一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p>
<h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><ul>
<li><code>hostname</code>：查看主机名</li>
<li><code>vi /etc/hostname</code>：指定主机名</li>
<li>重启生效</li>
</ul>
<h4 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h4><p>windows→linux：在C:\Windows\System32\drivers\etc\hosts 文件指定即可，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.200.130 centos7.6</span><br></pre></td></tr></table></figure>

<p>linux→windows：在/etc/hosts 文件指定，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.200.1 win10</span><br></pre></td></tr></table></figure>



<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>在linux中，每个执行的程序都称为一个进程，每一个进程都分配一个pid（进程号）</p>
<p>每个进程都可能以<strong>前台</strong>和<strong>后台</strong>两种方式存在，前台是用户目前的屏幕上可以操作的进程，后台是实际在操作，但屏幕上无法看到的进程</p>
<p>一般系统发服务通常以后台进程的方式存在，常驻系统中，直到关机才结束</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>ps：用于查看目前系统中的进程状况</p>
<p>选项：</p>
<ul>
<li>-a：显示<strong>当前终端</strong>的所有进程信息（不是所有进程）</li>
<li>-u：以用户的格式显示进程信息</li>
<li>-x：显示后台进程运行的参数</li>
<li>-e：显示所有进程</li>
<li>-f：全格式</li>
</ul>
<p>查看有无特定服务：<code>ps -aux | grep xxx</code>，比如查看有无sshd服务</p>
<h4 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps -aux"></a>ps -aux</h4><p>使用ps -aux：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGtEZt.png" style="zoom:80%;">



<table>
<thead>
<tr>
<th>USER</th>
<th>PID</th>
<th>%CPU</th>
<th>%MEM</th>
<th>VSZ</th>
<th>RSS</th>
<th>TTY</th>
<th>STAT</th>
<th>START</th>
<th>TIME</th>
<th>COMMAND</th>
</tr>
</thead>
<tbody><tr>
<td>用户名称</td>
<td>进程号</td>
<td>占用CPU百分比</td>
<td>占物理内存百分比</td>
<td>占用虚拟内存大小(KB)</td>
<td>占用物理内存大小(KB)</td>
<td>终端名称(缩写，因此显示?)</td>
<td>进程状态</td>
<td>启动时间</td>
<td>使用CPU的时间</td>
<td>启动进程所用的命令和参数(太长会截断显示)</td>
</tr>
</tbody></table>
<p>关于进程状态STAT：</p>
<ul>
<li>S：睡眠</li>
<li>s：表示该进程是会话的先导进程</li>
<li>N：表示进程比普通优先级更低的优先级</li>
<li>R：正在运行</li>
<li>D：短期等待</li>
<li>Z：僵尸进程</li>
<li>T：被跟踪或被停止</li>
</ul>
<h4 id="ps-ef-与父子进程"><a href="#ps-ef-与父子进程" class="headerlink" title="ps -ef 与父子进程"></a>ps -ef 与父子进程</h4><p><code>ps -ef</code>：以全格式显示当前所有的进程</p>
<img src="https://z3.ax1x.com/2021/08/29/hGawQg.png" style="zoom:80%;">

<table>
<thead>
<tr>
<th>UID</th>
<th>PID</th>
<th>PPID</th>
<th>C</th>
<th>STIME</th>
<th>TTY</th>
<th>TIME</th>
<th>CMD</th>
</tr>
</thead>
<tbody><tr>
<td>用户名称</td>
<td>进程号</td>
<td><strong>父进程ID</strong></td>
<td>见下方</td>
<td>进程启动的时间</td>
<td>终端名称</td>
<td>使用CPU的时间</td>
<td>启动进程所用的命令和参数</td>
</tr>
</tbody></table>
<p>C：CPU用于计算执行优先级的银子。数值越大，表明进程是CPU密集型运算，优先级降低；数值越小，表面进程是I/O密集型运算，优先级升高</p>
<p>父子进程：进程存在父子关系，先有父进程，再由父进程创建子进程，如图所示为sshd（远程登陆服务）的相关进程：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGaUW8.png" style="zoom:80%;">

<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>指令：</p>
<ul>
<li><p><code>kill 选项 进程号</code>：通过进程号杀死/终止进程；-9选项 表示强迫进程立即停止</p>
</li>
<li><p><code>killall 进程名称</code>：通过进程名杀死进程；同时，杀死父进程时也会杀死它的子进程；支持通配符</p>
</li>
</ul>
<p>最佳实践：</p>
<ul>
<li><p>踢掉某个非法登录用户：<code>kill 进程号</code>（查看sshd进程，找到进程号）</p>
</li>
<li><p>终止远程登录服务sshd，在适当的时候再次重启sshd服务：</p>
<p><code>kill sshd 进程号</code></p>
<p>重启：<code>/bin/systemctl start sshd.service</code></p>
</li>
<li><p>终止多个gedit（文本编辑器）：<code>killall gedit</code></p>
</li>
<li><p>强制杀死一个终端：<code>kill -9 bash的进程号</code></p>
</li>
</ul>
<h3 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h3><p><code>pstree 选项</code>可以直观查看进程信息</p>
<p>选项：</p>
<ul>
<li>-p：显示进程的PID</li>
<li>-u：显示进程的所属用户</li>
</ul>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top指令和ps类似，不同之处是它在执行一段时间后可以更新正在运行的进程</p>
<p><code>top -d 秒数</code>：指定top每隔几秒更新，默认3秒</p>
<p>其他选项：</p>
<ul>
<li>-i：使top不显示任何闲置或僵尸进程</li>
<li>-p：通过指定监控进程ID，来仅仅监控某个进程的状态</li>
</ul>
<p>交互操作：</p>
<ul>
<li>P：以CPU使用率排序，默认就是此项</li>
<li>M：以内存使用率排序</li>
<li>N：以PID排序</li>
<li>q：退出topt</li>
</ul>
<p>应用实例：</p>
<ul>
<li>监视特定用户：top → u →输入用户名</li>
<li>终止指定进程，如结束tom登录：top → k → 要结束进程的ID号</li>
</ul>
<h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>netstat指令：</p>
<ul>
<li><code>netstat [选项]</code><ul>
<li>-an：按一定顺序排列输出</li>
<li>-p：显示哪个进程在调用</li>
</ul>
</li>
</ul>
<p>如：<code>netstat -anp | grep sshd</code>可查看sshd服务的信息</p>
<p>netstat -anp：</p>
<p>Local Address指本机地址，Foreign Address指和本机某端口建立通信的外部地址</p>
<img src="https://z3.ax1x.com/2021/08/30/hJRQJg.png" style="zoom: 80%;">

<p>两个端口建立通信的示意图：</p>
<img src="https://z3.ax1x.com/2021/08/30/hJ2Fuq.png" style="zoom:80%;">

<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p>后台程序 ~ 服务 ~ 守护进程 </p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>service管理指令：</p>
<ul>
<li><code>service 服务名 [start|stop|restart|reload|status]</code></li>
<li>在centos7.0后，很多服务不再使用service，而是使用systemctl</li>
<li>service指令管理的服务在<code>/etc/init.d</code>查看</li>
</ul>
<p>查看服务名：</p>
<ul>
<li><code>setup</code>：查看全部系统服务</li>
</ul>
<h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p>chkconfig指令：可以给服务的各个运行级别设置自启动/关闭（在centos7.0后，很多服务使用systemctl，管理的服务在<code>/etc/init.d</code>查看）</p>
<ul>
<li><p><code>chkconfig --list [|grep xxx]</code>：查看全部服务</p>
</li>
<li><p><code>chkconfig 服务名 --list</code>：查看某项服务</p>
</li>
<li><p><code>chkconfig --level 数字 服务名 on/off</code>：对服务的各个运行级别设置自启动/关闭，需要重启生效</p>
<p>如：chkconfig –level 3 network off</p>
</li>
</ul>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>systemctl管理指令：它管理的服务在<code>/usr/lib/systemd/system</code>查看</p>
<ul>
<li><code>systemctl [start|stop|restart|status] 服务名</code>：如果选择stop，只是临时关闭服务，下次启动还看is-enabled</li>
<li><code>systemctl list-unit-files [|grep 服务名]</code>：查看服务开机启动状态</li>
<li><code>systemctl enable 服务名</code>：设置服务（在3和5级别下）开机启动</li>
<li><code>systemctl disable 服务名</code>：关闭服务（在3和5级别下）开机启动</li>
<li><code>systemctl is-enabled 服务名</code>：查询某个服务是否是自启动的</li>
</ul>
<h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h3><p>防火墙：外界想要访问服务器ip（比如192.168.200.130）下的某个端口（如111），要先经过防火墙。防火墙将一些端口开放，将一些端口关闭，如果外界访问了关闭的端口，则访问失败</p>
<p>比如防火墙未开放111端口，此时在windows <code>telnet 192.168.200.130 111</code>会失败 </p>
<p>防火墙指令：</p>
<p>输入<code>netstat -anp | more</code>，最前面一列可以看到端口对应的协议</p>
<ul>
<li><code>firewall-cmd --permanent --add-port=端口号/协议</code>：打开端口</li>
<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code>：关闭端口</li>
<li><code>firewall-cmd --reload</code>：重新载入，使上方指令生效</li>
<li><code>firewall-cmd --query-port=端口/协议</code>：查询端口是否开放</li>
</ul>
<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p>rpm类似于windows下的setup，是一个安装程序</p>
<p>rpm包名的基本格式：</p>
<img src="https://z3.ax1x.com/2021/08/30/hJ4NjJ.png" style="zoom: 80%;">

<p>指令：</p>
<ul>
<li><code>rpm -qa</code>：查询已安装的所有rpm软件包，一般使用 | grep xxx 过滤，如rpm -qa | grep firefox</li>
<li><code>rpm -q 软件包名</code>：查询软件包是否安装，如 rpm -q firefox</li>
<li><code>rpm -qi 软件包名</code>：查询软件包详细信息</li>
<li><code>rpm -ql 软件包名</code>：查询软件包中的文件</li>
<li><code>rpm -qf 文件全路径名</code>：查询文件所属的软件包，如 rpm -qf /etc/passwd，rpm -qf /root/install.log</li>
<li><code>rpm -e 软件包名</code>：卸载rpm包，如rpm -e firefox，会将火狐卸载<ul>
<li>–nodeps：无视依赖提醒，强制删除</li>
</ul>
</li>
<li><code>rpm -ivh RPM包全路径名称</code>：安装rpm包<ul>
<li>-i：安装</li>
<li>-v：提示</li>
<li>-h：进度条</li>
</ul>
</li>
</ul>
<p>删除并安装火狐的全过程：</p>
<ol>
<li><p>rpm -e firefox，卸载火狐</p>
</li>
<li><p>进入桌面上的CentOS 7 x86_64，搜索出firefox的rpm包</p>
<img src="https://z3.ax1x.com/2021/08/30/hJoCnJ.png" style="zoom: 80%;"></li>
<li><p>为了方便操作，将其复制到/opt下</p>
</li>
<li><p>执行rpm -ivh /opt/firefox</p>
</li>
</ol>
<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>yum是一个shell前端软件包管理器，基于rpm包管理，能够从指定的服务器自动下载rpm包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p>
<p>指令：</p>
<ul>
<li><code>yum list | grep 软件名</code>：查询yum服务器是否有需要安装的软件</li>
<li><code>yum install 软件名</code>：下载安装</li>
</ul>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell是一个<strong>命令行解释器</strong>，它为用户提供了一个向linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动、挂起、停止甚至是编写一些程序</p>
<h3 id="执行shell脚本"><a href="#执行shell脚本" class="headerlink" title="执行shell脚本"></a>执行shell脚本</h3><p>要求：</p>
<ol>
<li>脚本以 #!/bin/bash 开头</li>
<li>如果不用sh，脚本需要有可执行权限</li>
</ol>
<p>脚本内容示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>执行方式：</p>
<ol>
<li>首先赋予脚本+x权限，再输入脚本路径</li>
<li>不需要+x权限，直接<code>sh 脚本路径</code></li>
</ol>
<h3 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h3><p>shell的变量分为：系统变量和自定义变量</p>
<p>系统变量包括：$HOME、$PWD、$SHELL、$PATH、$USER等，可以 echo $HOME</p>
<p><code>set</code>指令可以显示当前shell中的所有变量</p>
<p>shell变量的定义：</p>
<p>基本语法：</p>
<ul>
<li>定义变量：<code>变量名=值</code>（等号两边无空格）</li>
<li>撤销变量：<code>unset 变量名</code></li>
<li>声明静态变量：<code>readonly 变量名</code>，静态变量不能unset</li>
<li>A=`命令`（反引号）：运行里边的命令，并把结果返回给变量A</li>
<li>A=$(命令)与上边等价</li>
</ul>
<p>定义变量的规则：</p>
<ul>
<li>规范：变量名为大写</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line">A=100</span><br><span class="line"><span class="meta">#</span><span class="bash">输出变量需要加$，不加当字符串处理</span></span><br><span class="line"><span class="meta">#</span><span class="bash">双引号可加可不加</span></span><br><span class="line">echo A=$A</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line"></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">unset</span> B 报错</span></span><br><span class="line">C=`date`</span><br><span class="line">D=$(date)</span><br><span class="line">echo C=$C</span><br><span class="line">echo D=$D</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">多行注释</span></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">D=1</span><br><span class="line">E=2</span><br><span class="line">F=3</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>现有一个变量，想要在多个脚本中使用，为了避免对其重复定义，应设置为环境变量</p>
<p>基本语法：</p>
<ul>
<li><code>export 变量名=变量值</code>：将shell变量输出为环境变量/全局变量</li>
<li><code>source 配置文件</code>：让修改后的配置信息立即生效</li>
<li><code>echo $变量名</code>：查询环境变量的值</li>
</ul>
<p>实践：</p>
<ol>
<li><p>在/etc/profile文件中定义MY_TEST 环境变量</p>
<p>在行尾添加：export MY_TEST=/opt/test</p>
</li>
<li><p>source /etc/profile 刷新</p>
</li>
<li><p>echo $MY_TEST，输出/opt/test，环境变量设置成功</p>
</li>
</ol>
<h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>用于获取命令行的参数信息</p>
<p>基本语法：</p>
<ul>
<li><p><code>$n</code>：n为数字，$0代表命令本身，$1到$9代表第一到第九个参数，十以上的参数需要用括号包含，如${10}</p>
</li>
<li><p><code>$*</code>：该变量代表命令行中所有的参数，$*把所有的参数看作一个整体</p>
</li>
<li><p><code>$@</code>：也代表命令行中所有的参数，但$@会把每个参数区分对待（两者的区别见for循环部分）</p>
</li>
<li><p><code>$#</code>：代表命令行中所有参数的个数</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo 0=$0 1=$1 2=$2</span><br><span class="line">echo 所有的参数=$*</span><br><span class="line">echo $@</span><br><span class="line">echo 参数的个数=$#</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYlI8H.png" style="zoom:80%;">



<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</p>
<ul>
<li><p><code>$$</code>：当前进程的进程号</p>
</li>
<li><p><code>$!</code>：后台运行的最后一个进程的进程号</p>
</li>
<li><p><code>$?</code>：最后一次执行的命令的返回状态</p>
<p>如果值为0，说明正确执行；反之不正确</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo 当前执行的进程id=$$</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">以后台的方式运行一个脚本（最后带&amp;），并获取它的进程号</span></span><br><span class="line">sh /opt/test/a.sh &amp;</span><br><span class="line"></span><br><span class="line">echo 最后一个后台方式运行的进程id=$!</span><br><span class="line">echo 执行的结果是$?</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYG7Y8.png" style="zoom:80%;">



<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>三种方式，只记录前两种：</p>
<ul>
<li><code>$((运算式))</code>：不推荐</li>
<li><code>$[运算式]</code>：推荐</li>
</ul>
<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：计算(2+3)*4</span></span><br><span class="line"></span><br><span class="line">RES1=$(((2+3)*4))</span><br><span class="line">echo res1=$RES1</span><br><span class="line"></span><br><span class="line">RES2=$[(2+3)*4]</span><br><span class="line">echo res2=$RES2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：求出命令行两个参数的和 20 50</span></span><br><span class="line">SUM=$[$1+$2]</span><br><span class="line">echo sum=$SUM</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYt4m9.png" style="zoom:80%;">



<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>基本语法：<code>[ condition ]</code>，注意空格</p>
<p><code>[ ]</code>为假，<code>[ xxx ]</code>为真（任意字符串）</p>
<p>常用判断条件：</p>
<ul>
<li>=：字符串比较</li>
<li>整数比较：<ul>
<li>-lt：小于</li>
<li>-le：小于等于</li>
<li>-eq：等于</li>
<li>-gt：大于</li>
<li>-ge：大于等于</li>
<li>-ne：不等于</li>
</ul>
</li>
<li>按照文件权限进行判断：<ul>
<li>-r：有读的权限</li>
<li>-w：有写的权限</li>
<li>-x：有执行的权限</li>
</ul>
</li>
<li>按文件类型进行判断：<ul>
<li>-f：文件存在并且是一个常规的文件</li>
<li>-e：文件存在</li>
<li>-d：文件存在并且是一个目录</li>
</ul>
</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if，elif，else"><a href="#if，elif，else" class="headerlink" title="if，elif，else"></a>if，elif，else</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">    代码</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">    代码</span><br><span class="line">else</span><br><span class="line">    代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：<span class="string">&quot;ok&quot;</span>是否等于<span class="string">&quot;ok&quot;</span></span></span><br><span class="line">if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;euqal&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：23是否大于等于22</span></span><br><span class="line">if [ 23 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;大于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例3：/opt/<span class="built_in">test</span>/a.txt 目录中的文件是否存在</span></span><br><span class="line">if [ -f /opt/test/a.txt ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYWxFf.png" style="zoom:80%;">

<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例：当命令行参数是1时输出<span class="string">&quot;周一&quot;</span>，是2时输出<span class="string">&quot;周二&quot;</span>，其他输出<span class="string">&quot;others&quot;</span></span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;others&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYIqaR.png" style="zoom:80%;">

<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>基本语法1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">    代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>基本语法2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">    代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>实践1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：打印命令行输入的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">$*把参数当整体对待，$&amp;把参数分开对待</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;num is $i&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;=======================================&quot;</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;num is $j&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYb5DS.png" style="zoom:80%;">

<p>实践2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：从命令行输入一个数n，将1~n的值累加</span></span><br><span class="line">SUM=0</span><br><span class="line">for(( i=1; i&lt;=$1; i++ ))</span><br><span class="line">do</span><br><span class="line">    SUM=$[$SUM+$i]</span><br><span class="line">done</span><br><span class="line">echo &quot;SUM=$SUM&quot;</span><br></pre></td></tr></table></figure>

<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">    代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例：从命令行输入一个数n，将1~n的值累加</span></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -le $1 ]</span><br><span class="line">do</span><br><span class="line">   SUM=$[$SUM+$i]</span><br><span class="line">   i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;执行结果=$SUM&quot;</span><br></pre></td></tr></table></figure>



<h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>基本语法：</p>
<ul>
<li><p><code>read 选项 参数</code></p>
<p>选项：</p>
<ul>
<li>-p：指定读取值时的提示符</li>
<li>-t：指定读取值时等待的时间，如果超时则不再等待</li>
</ul>
<p>参数：指定读取值的变量名（参数和前边必须用空格隔开）</p>
</li>
</ul>
<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：读取控制台输入一个NUM1值</span></span><br><span class="line">read -p &quot;请输入一个数NUM1=&quot; NUM1 #程序会被阻塞在这里，等待输入</span><br><span class="line">echo &quot;你输入的NUM1=$NUM1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：读取控制台输入一个NUM2值，在10秒内输入</span></span><br><span class="line">read -t 10 -p &quot;请输入一个数NUM2=&quot; NUM2</span><br><span class="line">echo &quot;你输入的NUM2=$NUM2&quot;</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h4><p>basename：返回完整路径最后 / 的部分，常用于获取文件名</p>
<p>语法：<code>basename [pathname] [suffix]</code></p>
<p>如果suffix被指定，则文件后缀如.txt也会被去掉</p>
<p>实例：basename /home/aaa/test.txt 返回test.txt，basename /home/aaa/test.txt .txt 返回test</p>
<p>dirname：返回完整路径最后 / 的前面的部分，常用于返回路径部分</p>
<p>语法：<code>dirname [pathname]</code></p>
<p>实例：dirname /home/aaa/test.txt 返回/home/aaa</p>
<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ function ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">    Action;</span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用直接写函数名：funname [值]</span><br></pre></td></tr></table></figure>

<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：计算输入两个参数的和（动态获取），getSum</span></span><br><span class="line">function getSum() &#123;</span><br><span class="line">    SUM=$[$n1+$n2]</span><br><span class="line">    echo &quot;SUM=$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;请输入一个数n1=&quot; n1</span><br><span class="line">read -p &quot;请输入一个数n2=&quot; n2</span><br><span class="line"></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure>



<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/htZgc6.png" style="zoom:80%;">

<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>日志是用来记录重大事件的工具</p>
<p>/var/log是系统日志文件的保存位置</p>
<p>系统常用的日志：</p>
<img src="https://z3.ax1x.com/2021/08/30/htreCd.png" style="zoom: 80%;">



<p>应用案例：</p>
<p>使用root用户通过xshell6登录，第一次使用错误的密码，第二次使用正确的密码登录成功，可以查看/var/log/secure里记录的相关信息</p>
<h3 id="日志管理服务"><a href="#日志管理服务" class="headerlink" title="日志管理服务"></a>日志管理服务</h3><p>centos7使用的日志管理服务是rsyslogd（负责写日志），和以前版本的syslogd是兼容的，/etc/rsyslog.config 可以查看日志服务管理的文件有那些</p>
<ul>
<li><code>ps aux | grep &quot;rsyslog&quot; | grep -v &quot;grep&quot;</code>：查看rsyslogd服务是否启动</li>
<li><code>systemctl list-unit-files | grep rsyslog</code>：查询rsyslogd服务的自启动状态</li>
</ul>
<p>配置文件 /etc/rsyslog.config：编辑文件时的格式为 <code>*.*</code>，其中第一个*代表日志类型，第二个*代表日志级别</p>
<p>日志类型：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auth</td>
<td align="left">pam产生的日志</td>
</tr>
<tr>
<td align="left">authpriv</td>
<td align="left">ssh、ftp等登录信息的验证信息</td>
</tr>
<tr>
<td align="left">corn</td>
<td align="left">时间任务相关</td>
</tr>
<tr>
<td align="left">kern</td>
<td align="left">内核</td>
</tr>
<tr>
<td align="left">lpr</td>
<td align="left">打印</td>
</tr>
<tr>
<td align="left">mail</td>
<td align="left">邮件</td>
</tr>
<tr>
<td align="left">mark(syslog)-rsyslog</td>
<td align="left">服务内部的信息，时间标识</td>
</tr>
<tr>
<td align="left">news</td>
<td align="left">新闻组</td>
</tr>
<tr>
<td align="left">user</td>
<td align="left">用户程序产生的相关信息</td>
</tr>
<tr>
<td align="left">uucp</td>
<td align="left">主机之间相关的通信</td>
</tr>
<tr>
<td align="left">local 1-7</td>
<td align="left">自定义的日志设备</td>
</tr>
</tbody></table>
<p>日志级别：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>级别</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>有调试信息的，日志通信最多</td>
</tr>
<tr>
<td>info</td>
<td>一般信息日志，最常用</td>
</tr>
<tr>
<td>notice</td>
<td>最具有重要性的普通条件的信息</td>
</tr>
<tr>
<td>warning</td>
<td>警告级别</td>
</tr>
<tr>
<td>err</td>
<td>错误级别，某个功能或模块不能正常工作的信息</td>
</tr>
<tr>
<td>crit</td>
<td>严重级别，整个系统或整个软件不能正常工作的信息</td>
</tr>
<tr>
<td>alert</td>
<td>需要立刻修改的信息</td>
</tr>
<tr>
<td>emerg</td>
<td>内核崩溃等重要信息</td>
</tr>
<tr>
<td>none</td>
<td>什么也不记录</td>
</tr>
</tbody></table>
<p>从上到下，级别从低到高，记录信息越来越少</p>
<p>由rsyslogd记录的日志文件，文件的格式包含以下4列：</p>
<ol>
<li>事件产生的时间</li>
<li>产生事件的服务器的主机名</li>
<li>产生事件的服务名或程序名</li>
<li>事件的具体信息</li>
</ol>
<h3 id="自定义日志服务"><a href="#自定义日志服务" class="headerlink" title="自定义日志服务"></a>自定义日志服务</h3><p>在/etc/rsyslog.conf中添加一个日志文件/var/log/test.log，当有事件发生时，该文件会接收到信息并保存</p>
<img src="https://z3.ax1x.com/2021/08/31/hUPEse.png" style="zoom:80%;">



<p>生成了test.log，里面保存了全部信息，用grep筛选可以看到有关sshd的信息</p>
<img src="https://z3.ax1x.com/2021/08/31/hUPnII.png" style="zoom: 67%;">

<h3 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>日志轮替：把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除</p>
<p>centos7使用<code>logrotate</code>进行日志轮替管理，配置文件为<code>/etc/logrotate.conf</code>，可以在该文件内进行全局配置，也可以进行局部配置（可以把局部配置写入该文件，也可以用别的方式，见自定义部分）</p>
<img src="https://z3.ax1x.com/2021/08/31/hUFg8x.png" style="zoom:80%;">



<img src="https://z3.ax1x.com/2021/08/31/hUFg8x.png" style="zoom:80%;">



<p>关于dateext参数：</p>
<ul>
<li><p>如果配置文件中有dateext参数，那么日志会用日期来作为日志文件的后缀，例如”secure-20210831”。这样日志名不会重叠，只需要指定保存日志个数，删除多余的日志文件即可</p>
</li>
<li><p>如果没有该参数，日志文件需要改名。</p>
<p>当第一次进行日志轮替时，当前”secure”日志会自动改名为”secure.1”，然后新建”secure”日志，用来保存新的日志。</p>
<p>当第一次进行日志轮替时，当前”secure1”日志会自动改名为”secure.2”，以此类推。</p>
</li>
</ul>
<p>其他参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">daily</td>
<td align="center">轮替周期为每天</td>
</tr>
<tr>
<td align="left">weekly</td>
<td align="center">每周</td>
</tr>
<tr>
<td align="left">monthly</td>
<td align="center">每月</td>
</tr>
<tr>
<td align="left">rotate 数字</td>
<td align="center">保留的日志文件的个数，0指没有备份</td>
</tr>
<tr>
<td align="left">compress</td>
<td align="center">日志轮替时，旧的日志进行压缩</td>
</tr>
<tr>
<td align="left">create mode owner group</td>
<td align="center">建立新日志，同时指定新日志的权限与所有者和所属组</td>
</tr>
<tr>
<td align="left">mail address</td>
<td align="center">当日志轮替时，输出内容通过邮件发送到指定的邮件地址</td>
</tr>
<tr>
<td align="left">missingok</td>
<td align="center">如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td align="left">notifempty</td>
<td align="center">如果日志为空文件，则不进行日志轮替</td>
</tr>
<tr>
<td align="left">minsize 大小</td>
<td align="center">日志轮替的最小值（达到该最小值才会轮替，否则时间到了也不轮替）</td>
</tr>
<tr>
<td align="left">size 大小</td>
<td align="center">日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</td>
</tr>
<tr>
<td align="left">dateext</td>
<td align="center">使用日期作为日志轮替文件的后缀</td>
</tr>
<tr>
<td align="left">sharedscripts</td>
<td align="center">在此关键字之后的脚本只执行一次</td>
</tr>
<tr>
<td align="left">prerotate/endscript</td>
<td align="center">在日志轮替之前执行脚本命令</td>
</tr>
<tr>
<td align="left">postrotate/endscript</td>
<td align="center">在日志轮替之后执行脚本命令</td>
</tr>
</tbody></table>
<h4 id="自定义日志轮替"><a href="#自定义日志轮替" class="headerlink" title="自定义日志轮替"></a>自定义日志轮替</h4><p>把自己的日志加入日志轮替：</p>
<ul>
<li>方法一：直接在/etc/logrotate.conf中写入该日志的轮替策略（不推荐）</li>
<li>方法二：在/etc/logrotate.d/目录中新建该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被”include”到主配置文件中，所以也可以把日志加入轮替（推荐，便于维护）</li>
</ul>
<img src="https://z3.ax1x.com/2021/08/31/hUe9gI.png" style="zoom:80%;">

<h4 id="日志轮替原理"><a href="#日志轮替原理" class="headerlink" title="日志轮替原理"></a>日志轮替原理</h4><p>日志轮替依赖系统定时任务</p>
<p>在/etc/cron.daily/目录中，有可执行文件logrotate，logrotate通过这个文件完成定时任务执行</p>
<h3 id="查看内存日志"><a href="#查看内存日志" class="headerlink" title="查看内存日志"></a>查看内存日志</h3><p>journalctl可以查看内存日志，重启会清空，指令：</p>
<ul>
<li><p><code>journalctl</code>：查看全部</p>
</li>
<li><p><code>journalctl -n 3</code>：查看最新3条</p>
</li>
<li><p><code>journalctl --since 19:00 --until 19:10:00</code>：查看起始时间到结束时间的日志，可加日期</p>
</li>
<li><p><code>journalctl -p err</code>：报错日志</p>
</li>
<li><p><code>journalctl -o verbose</code>：日志详细内容</p>
</li>
<li><p><code>journal _PID=1245 _COMM=sshd</code>：查看包含这些参数的日志</p>
<p>或者<code>journalctl | grep sshd</code></p>
</li>
</ul>
<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p>linux的备份和恢复的两种方式：</p>
<ol>
<li>把需要的文件（或分区）用TAR打包，下次需要恢复时，解压并覆盖即可</li>
<li>使用dump和restore命令</li>
</ol>
<h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>首先安装dump和restore指令：<code>yum -y install dump</code>，会同时安装2个指令</p>
<p>dump支持分卷和增量备份，语法：</p>
<img src="https://z3.ax1x.com/2021/08/31/hUYIc8.png" style="zoom:80%;">

<p>c是一个0到9的数，备份时从0开始，一直到9，然后又从0开始</p>
<p>关于备份层级：如果不理解可以再看看视频P133</p>
<p>实践1：将/boot分区所有内容备份到 /opt/boot.bak0.bz2 文件中，备份层级为”0”：</p>
<p><code>dump -0uj -f /opt/boot.bak0.bz2 /boot</code></p>
<p>实践2：在/boot目录下增加新文件，备份层级为”1”（只备份上次使用层次”0”备份后发生过改变的数据）：</p>
<p><code>dump -1uj -f /opt/boot.bak1.bz2 /boot</code></p>
<p>通过dump命令配合crontab可以实现无人值守备份</p>
<p>查询操作：</p>
<ul>
<li><code>dump -W</code>：显示需要备份的文件以及最后一次备份的层级、时间、日期</li>
<li><code>dump -w</code>：仅显示需要备份的文件</li>
<li><code>cat /etc/dumpdates</code>：查看备份时间文件</li>
</ul>
<p>注意，在备份分区时支持增量备份，<strong>如果备份文件或目录</strong>，不再支持增量备份，此时数字只能写0，也不能提供-u选项</p>
<blockquote>
<p>如果是重要的备份文件，建议将文件上传到其他服务器保存，<strong>不要将鸡蛋放在同一个篮子里</strong></p>
</blockquote>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>restore命令用于恢复已备份的文件，可以从dump生成的备份文件中恢复原文件</p>
<p>基本语法：</p>
<ul>
<li><p><code>restore [模式选项] [选项]</code></p>
<p>模式选项：一次只能指定一种</p>
<ul>
<li>-C：对比模式，将备份的文件与已存在的文件相互对比</li>
<li>-i：交互模式，在进行还原操作时，restore指令依序询问用户</li>
<li>-r：还原模式</li>
<li>-t：查看模式，看备份文件有哪些文件</li>
</ul>
<p>选项：</p>
<ul>
<li>-f&lt;备份设备&gt;：从指定的文件中读取备份数据，进行还原操作</li>
</ul>
</li>
</ul>
<p>实践：</p>
<ul>
<li>使用对比模式：先将某文件改名，再执行<code>restore -C -f boot.bak1.bz2</code></li>
</ul>
<img src="https://z3.ax1x.com/2021/08/31/hUg19U.png" style="zoom:80%;">



<ul>
<li>使用查看模式，看备份文件有哪些数据/文件：<code>restore -t -f boot.bak0.bz2</code></li>
</ul>
<img src="https://z3.ax1x.com/2021/08/31/hUWp7R.png" style="zoom:80%;">

<ul>
<li><p>使用还原模式，注意：如果有增量备份，需要把增量备份文件也进行恢复，有几个就要恢复几次，并且要按顺序恢复：</p>
<p><code>restore -r -f /opt/boot.bak0.bz2</code>：恢复到第1次完全备份状态</p>
<p><code>restore -r -f /opt/boot.bak1.bz2</code>：恢复到第1次增量备份状态</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 and Half of 2021</title>
    <url>/2021/05/30/11.2020+2021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="挣扎与彷徨"><a href="#挣扎与彷徨" class="headerlink" title="挣扎与彷徨"></a>挣扎与彷徨</h1><h2 id="高三之前"><a href="#高三之前" class="headerlink" title="高三之前"></a>高三之前</h2><p>高中的往事已回忆数次，无非就是这样的开局：不自信/想要变强→怀抱着不切实际要当科学家的妄想→逼迫自己，强迫症/形体化→后悔，无力改变现状。那个时候，基本是个人我都会感到羡慕，我沉沦于无止境的痛苦之中，每天都感觉过得浑浑噩噩，觉得自己的青春和人生就这么被强迫症给废掉了。不论我怎么努力，都感觉自己被限制住了，就是发挥不出来自己的能力，考试也极少进年级前50，比起我初中玩着考入班级前十，现在的我稳在班级前50%都困难。</p>
<p>现在觉得一切不过都是借口，强迫症也并没有那么可怕，虽然它让我的生活变得不太舒服，形体化的后患仍然存在，但并不影响我掌控自己的人生。当时成绩上不去，是我做了太多琐碎的事，摘抄或总结了很多笔记却很少复习且断断续续，自发刷题只坚持了英语，总之没有高效率地学习。顺带一提，这里提到的有些毛病我现在都还没有改掉。</p>
<p>在高二的时候其实我已经认识到（现在我都不知道这种认识是否正确），<strong>自己或许不能专精于任何一个方向</strong>，因为努力学习后也考不到年级顶尖水平。比起某方面的专精，我可能更适合成为全能型庸才（但其实这样我也做不到），所以当时就买了心理学、计算机、美学、音乐的书来看，还读了《混血豺王》和《比尔盖茨传》等。但是这一切在高三到来的时候就又被我抛掷脑后。</p>
<h2 id="疲于奔命"><a href="#疲于奔命" class="headerlink" title="疲于奔命"></a>疲于奔命</h2><p>高二暑假是我此生最短的暑假，短到只有两天。暑假前半段被迫参加每天200块的“名校通”，暑假后半段又要回去补课，回去前的一周我又自愿交钱补习化竞，顺带一提，后期到开学的这段时间我看完《钢之炼金术师》全套漫画。</p>
<p>那个时候，我看到了北大2020的招生简章，简章十分精美，花花绿绿，我们班上放了几本，于是我便热衷于阅读它。那个时候我被北大所深深吸引，开始幻想能不能考上，并且由于自己心态的困境，我特别想去心理学系。其实去不去心理学也无所谓，那时候我觉得读个考古都可以，反正是北大嘛。这样靠着专项计划，我还是得考到680分才可以，而我只有650分的水平，平时的模考只能考580~620区间。</p>
<p>我开始思考着自己如何达到这种“飞跃”，大概是一定要去找自己的节奏，有针对性地提分。前边还是比较顺利，在11月的一次模考中，我同时取得了语文（128，之后再也没达到过）和化学的双班级第一，年级31名，之后一次考试我坐在第一考场，考理综时心态突然崩溃，结果理综考了190，好状态完全止步于这次考试。于是我开始不听讲，不按着学校的复习进度来，自己整些笔记、刷题、网课，这些全都上了。但是随着时间的不断推移，我没觉得自己有什么进步，后边越来越过分。先是伪造病历去办了走读证，在学校旁边租了个小房间便于每天走读回去多学会，也方便刷网课。因为买的网课太多觉得刷不完，然后又跟班主任协商，翘掉四节晚自习。我开始觉得学校老师讲的啥用没有，平时的作业很多都在抄，觉得极其浪费时间，待在学校我都觉得痛苦，我把自己没有进步的错误都归咎于是学校限制了我。一轮复习结束，二轮复习开始，我觉得自己还是老样子。结果这段时间成绩不断下降，位次连着四五次都在一百名开外，老师也在找我谈话。</p>
<p>最后我还是下定决心回家复习去了，结果没走几天撞上疫情，大家都只能在家学习。在家期间我的神经十分紧绷，每天的平均时长在14个小时以上，基本每天就是6点多起床一直学到晚上11点多，除了过年有两三天偷了个懒，三个月没怎么变过。也算是刷完了学校的二轮资料和几本网课资料。但是我仍然觉得自己的学习没有太大起色，从三月起学校开始让学生印模考卷做，我仍然只能考620左右，此时心态十分炸裂，后悔却又无可奈何，那个时候平均两天就会改一次qq签名，正能量的鸡汤背后是深深的负能量。我反思前面做的这一切，终于承认了自己就是普通人的事实，为何要追求680这一虚无缥缈的目标，就这样舒舒服服地苟着不就好了吗？</p>
<h2 id="回归正常"><a href="#回归正常" class="headerlink" title="回归正常"></a>回归正常</h2><p>4月回到学校后我就开始佛系了，不再想着自己去做些什么，而是按部就班地跟着学校。回来的第一次模考，我在数学113血崩的情况下考了年级36，惊艳了一些同学。接下来的一次考试又到了100多名，然后又考了43名，之后就回到以前的段位，考60名左右的水平。事实证明，回家学习的这段时间我大概就物理有了进步，最头疼的数学还是老样子。进步最明显的是心态，我开始没那么在意高考，而且开始对现状持接纳态度，珍惜毕业前的日子。我会趁着晚上走读便利，和同学去吃华莱士、克莱堡、烧烤，甚至有一天住到他家里。考前两周我为全班同学吹奏《追梦赤子心》，高考完我回去给一位尊敬的老师吹奏《离歌》，弥补了高二的一次遗憾。</p>
<p>那段时间，我也常思考未来，不再去追求一时脑热的化学和心理学专业，觉得作为一个普通人就学个计算机专业，到时候出来工作挣钱就行了。看知乎推荐觉得北邮是一所不错的学校，因为就业率非常高，华科也可以，有“北北邮，南华科”之称。我给自己的计算机专业学校排名是：浙大→北航→华科→北邮→西电/西工。虽然佛系，高考我仍旧全力以赴，最后655收场，语文数学略炸，英语正常，理综略超常，总分是正常水平。周围不少平时一般的同学考到了670+，确实还是有点点不甘心吧。</p>
<p>报志愿的时候，这个分数在我省提前批次确实可以冲一冲华科，往年最高分数是656。但是华科CS给的名额很少，又是热门专业，所以心里没底。就这样，提前批我填了华科（只写了三个专业，还不服从调剂，事后后悔了，因为这不是稳进CS的方案），本一批填了北邮。其实这个分数挺合适的，分低一些我会进入华科非CS专业（光电/能动），分高一点（&gt;660）我说不定会冲进浙大的差专业。最后，事实证明我的担心多余，顺利来到华科CS。从结果上看，我的高考是比较顺利的。</p>
<h2 id="一晃而过的暑假"><a href="#一晃而过的暑假" class="headerlink" title="一晃而过的暑假"></a>一晃而过的暑假</h2><p>暑假开始做一些自己想做的事了，比如说学完标日上下册，还背了一些日语单词；口琴继续练；本来说要做视频，还是没有去学，懂了Pr基本操作，在9月初才剪了一个自己勉强满意的视频；骑车上国道，玩了一天多。</p>
<p>知道自己被华科CS录取后，我又开始“蠢蠢欲动”了，因为本质上我不是一个甘于平庸的人。因为高中的“难忘”经历，我果断地认定卷加权不是适合自己的道路，如何把大学生活过得丰富且有意义，是我最为注重的。早在高考之前，我就听说过华科的“三大团队”，抛开一些功利性的东西不谈，单是出于向往“互联网大学”，我就很想加入。于是我加入了秋招群，在自己并不清楚想要选什么方向的情况下，开始准备冲击联创Lab组，至于为什么是Lab，因为Lab的学习指南里有C，在看到招新信息的时候我已经学了一周的C，不想浪费基础（现在看起来有点可笑）。于是暑假的后半段我每天抽很多时间去看C、Linux，但是都是刷视频且浮光掠影；试着啃了一下黑皮《计算机科学导论》，每天刷个十几二十页，也感觉很难吸收其中的知识，看后就忘。</p>
<p><strong>从这里我开始产生一个矛盾：自己有明确想要学的东西（日语、口琴、视频），但是因为我有别的东西要追求，所以没时间做自己喜欢的事。要做的事多和有限的精力之间产生了不可调和的矛盾。</strong>现在思考一下我想加入团队的原因，无非：①因为高中怎么学都考不进年级前列，对卷加权这件事没有信心，想建立自己在其他方向的优势；②不想继续卷，觉得团队能带来有意义和丰富的生活。其他原因都能归咎于这两点上——想变强/想过不同的生活。</p>
<p>但是要加入团队，又不得不经历一个卷的过程，要努力卷进团队，就没有时间去做自己想做的事了。</p>
<h1 id="步入大学"><a href="#步入大学" class="headerlink" title="步入大学"></a>步入大学</h1><h2 id="确定方向"><a href="#确定方向" class="headerlink" title="确定方向"></a>确定方向</h2><p>来华科以后，新鲜感很快就过去，由于疫情，军训只持续了不到两星期，最后一天坐在潮湿的地面导致我感冒了。这段时间最重要的事就是冲击团队。我同时报名了冰岩、联创和Dian，最开始招新的是冰岩，根据我学习的内容，我选择了程序组。</p>
<p>那个时候我的基础，就是C语言能写<code>printf</code>和<code>if</code>、<code>for</code>循环的程度，连指针和数组都不会用。是的，美其名曰我暑假自学了C语言，其实就是刷视频，而且还没刷到指针，自己的代码能力几乎为0。Linux知道一些如<code>ls</code>、<code>cd</code>、<code>pwd</code>等的常用指令，自己配好了Vmware虚拟机。还稍微看了一点HTML和Python，但是几乎不会用。我还记得自己当时报名信息里吹得天花乱坠，把会的东西全部展开说，达到凑字数的目的，显得这个人很厉害。笔试时拿到题目，我几乎完全懵逼，但是还是硬生生的都编上去了，所有代码题和程序设计题都不会，就强行整个思路上去。最后笔试通过，国庆那天去了1006面试，为了试图作出“努力”的样子，我中午不到1点就到了，然后坐在那里为面试复习，拿起黑皮《计算机科学导论》，但是说实话什么都看不进去。那边有一两个学长学姐，我也不知道怎么跟他们寒暄。我当时思路清奇，走过去跟lyt学长说：“虽然笔试题我都不会，但我还是尽了最大努力去编答案”，似乎是想体现自己的顽强意志，结果得到了“不是给时间学了吗”的回复。然后面试开始，自我介绍，然后谈了自己会的东西，我刻意强调了自己会的都是很简单的皮毛。最后lyt学长问到如何用Python来把一个字符串逆序，我自然是承认自己不会。我最后还不忘补了一刀“我也存在一些同学在群里说的问题，就是像高中一样啃书学习，缺乏实践”。面试自然而然是被挂掉了。我认识到了自己的菜，所以后边的联创和Dian就鸽了（指连笔试题都没有做）。</p>
<p>当时我觉得，程序组的题目这么难，我自学一学期后端应该也进不了组，而且我高中数学就不是很好，编程可能比不过一些大佬，还是选一个大家都是零基础的、好入门的方向吧。那时候就在知乎上搜，发现前端学习路线非常明确，好像比较简单，加之我之前有一点点HTML的基础，觉得努力学一学期应该可以冲一冲团队，于是我就立刻决定学前端。那时真的是特别想去团队，不去想自己到底热爱什么，想的是什么方向适合我冲击团队。</p>
<p><strong>其实大学四年的时间很长，完全可以什么方向都学一些，再看看自己到底喜欢什么方向；或许自己不适合搞开发，那么就应该去读研。但我的决定就是做得这么快。</strong></p>
<h2 id="生活与学习"><a href="#生活与学习" class="headerlink" title="生活与学习"></a>生活与学习</h2><p>我的大学，从一开始就放弃参加内卷游戏，选择冲击团队之路后，我还希望自己的生活过得丰富一些。于是加入了车协，去骑东湖、骑八分山、骑到武大。武大百团的时候，我还加入了樱之音口琴社（虽然加入后从没参加过活动）。</p>
<p>不知怎么，现在的我已经没法沉下心来玩很长时间的游戏了，玩的时间一长就会导致做别的事情的时间变少，内心就会产生焦虑。其实我一点也不喜欢这样，初中那时一日十来个小时的游戏生活已经彻底远去。其他时间，就是看一看动漫，比起新番，我倾向于老的经典番剧，名作之壁。暑假看了凉宫、石头门、强风吹拂、排球、轻音、京吹，开学后继续看巨人、狼辛，后来又看了钢炼03、小圆、天元、Fate…</p>
<p>然后谈谈学习吧，为了抽出来更多时间来学技术，学校排的课我都疯狂水过，还翘了不少课。平时简单自学一下，做作业都是面向答案，考前再突击一下，第一学期除了期中线代挂掉，其他的科目都还能看，总加权也算混进了前50%，自己还是比较满意的。</p>
<p>但是技术学习，我还存在很多问题。首先我学习主要靠看视频（视频比较系统，看完了可以大概知道一个东西怎么做），而且对于100多集的视频，我一天也就看3~6集，所以学起来的速度非常慢，学完了还缺乏实践。于是就这样，我花了三个多月才完三剑客基础+Markdown，这种学习速度让我变得更加自卑，我不停地安慰自己：“不可心急，日积月累”。我想冲团队的愿望也影响了寝室的氛围，大家或多或少都在学习技术上的东西。</p>
<p>还有一件不愿提及但是不得不提的事就是摔牙，那时候我也抑郁了一阵子，觉得自己不能啃东西了什么的，但是时间可以冲淡悲伤，现在的我也逐渐接纳了这件事。</p>
<h2 id="忙碌的寒假"><a href="#忙碌的寒假" class="headerlink" title="忙碌的寒假"></a>忙碌的寒假</h2><p>我把寒假当作自己冲击冰岩的关键期，所以依然努力学习前端技术。我深入了一些JS，照着冰岩往年的笔试题来补充知识点，看了不少博客，最后觉得自己的实践能力不足，所以又复刻了一些页面。</p>
<p>因为团队是鞭策我学习的重要因素，有时候我会上网搜索信息，读完以后我就会动力十足，继续学习。一次在Github上搜索冰岩，找到了以前夏令营开的仓库，以此我了解到了gc学姐，一次问她js问题的时候，她向我发了一篇博客，是xiong35学长的。当时我就觉得学长很强，这激励了我花了三天时间，去搞了一个WP博客。然后我也加了学长的好友，稍微聊了一些后他鼓励了我，说我春招很有希望进入冰岩。当时的我，确实也有了一些进入冰岩的自信。</p>
<h2 id="冲冰岩失败"><a href="#冲冰岩失败" class="headerlink" title="冲冰岩失败"></a>冲冰岩失败</h2><p>开学以后，我一直期盼着冰岩的招新信息。这段时间我继续完成寒假的项目，以及看博客补充新的知识。很快招新就来了，因为心里激动，简历我是改了又改，最后我作了个大死，说自己搜冰岩的信息，想借此体现自己的热爱。殊不知，这是给自己挖了个天大的坑。我以为秋招面试被挂能带来一些教训，结果春招时我情商还是老样子。</p>
<p>就这样我一路杀过简历、面试，实习选题时，我不敢给自己选太难的，就还是老老实实复刻网页。因为实习只能通过很少的人，而实习名单里好像有实力很强的大二学长，我就还是不自信。实习期我疯狂翘课抄作业，硬是把所有Level基本完成了，展示时我想让自己说得更有条理一些，于是准备了稿子（作死*2），展示完后我觉得自己稳了。</p>
<p>然后就到了组面，在门外，我开始在脑海中构思着自我介绍。我一进门气氛就冷到冰点，然后就是我自顾自地说了很多（作死*3），接着被xiong35学长问到查资料的事，我也没有作出很好的解释。之后面试官问我还有没有什么问题，我反向让他们继续问我，结果被问到了答不上来的问题，场面继续尴尬。后面结局基本就注定了，组面没有通过。</p>
<h2 id="继续迷茫"><a href="#继续迷茫" class="headerlink" title="继续迷茫"></a>继续迷茫</h2><p>组面结束后的那个下午，我就不带手机绕着主校区走了一圈，以排解心中的苦闷。后来我的舍友A通过了冰岩程序组的考核，舍友B通过了Dian的考核。当时最想进入团队的我就这样落败，而他们怀着试一试的心态参与，就这样顺利进入了，一点都不羡慕是不可能的。</p>
<p>后来xiong35学长找我谈，说我技术很强，但是因为如上列举的原因没有让我通过，自己的风格和团队不符，让我找到适合自己的组织。后来我又联系了欧阳学姐，她说我“痴迷于技术”，“有种理工男呆呆的感觉”，“像个geek”，“忽略了一些情商方面的东西”（当然，我从来不认为自己像个Geek，因为Geek这个词给我一种很强的感觉，后来HackDay的队友也认为我完全不像是geek）。</p>
<p>我开始迷茫了，竟然在技术过关的情况下，因为别的因素被团队挂掉，我不太能接受这个结局。而且说我技术很强，那个时候我还真的相信了，开始考虑换方向，甚至是读研——毕竟学习能力强嘛，又何必局限于“简单”的前端。但是我技术真的强吗，也不强。学了五六个月还是这么点水平。想想xiong35学长充沛的精力和很强的学习能力，从零开始40天就能写博客的前后端，我就觉得自己什么都算不上。最后我还是继续学前端，不想浪费基础，而且还可以继续冲击团队。</p>
<p>可是说实话，我真的喜欢前端吗？不喜欢也不讨厌吧，遇到Bug会抓耳挠腮十分难受，可是解决问题时也会有巨大的成就感。写出赏心悦目的页面也可以给我带来正向反馈，但是也就仅仅是网页而已。现在我最需要的，大概就是要做出一个产品吧？一直孤立地自学，啃厚厚的书籍却什么也不做，又有何乐趣可言呢？总之，我目前还像是停留在“为了学习而学习，为了团队而学习”，而不是“为了需求而学习，一边实践一边学习”。</p>
<p>这学期的课内学习要比上学期拉跨了，一来是课业明显变得繁重，二是难度开始加大。我的态度也比上学期要松懈了许多，作业中有很多没有搞懂的内容，考试前复习得也不充分，就这样，我的微积分期中考试直接挂科。以后必须要改善学习方法了，不想投入时间又不想挂科的话，必须要依赖网上的“速成课”，或者慕课。</p>
<p>现在的我，还是想先坚持前端的路线，体验一下开发到底是什么感觉，后续作出的决定，很大程度上与我有没有进入团队有关。之前我想的是本科毕业就去投前端岗，去大厂996，但是最好还是读一下研究生，去外企955吧。</p>
<p>希望HackDay和暑假的夏令营能带来一些转变吧。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以下记录HackDay经历和带来的一些转变：</p>
<p>那是一节国际金融公选课，抄完大物答案百无聊赖的我打开了微信，看见了联创的最新推文——HackDay Reboot。其实这种比赛，我一般是不敢去想的——奖金丰厚、大佬云集，既然标榜是“极客狂欢”，和我这样的蒟蒻又有什么关系呢。但最后思量着，6月14日结束后应该来得及备考期末，况且可以学到不少东西，我还是决定报名。</p>
<p>进入FAQ群后，我本来决定报名后到现场组队，令我没有想到的是，一个冰岩的同学邀请我加入他们。最后三个冰岩人和我这个野路子组成了“启明好难队”。既然和冰岩同学组队了，我就不敢掉以轻心，生怕拖了他们的后腿。</p>
<p>我开始做知乎的项目练习前后端交互，开始写移动端，学了swiper插件（用于移动端滑动页面），由于发现原生JS的效率实在不高，在参加比赛的前一晚我入门了JQuery。</p>
<p>6月13日很快到来，我们先是在报告厅举办了开幕式，然后来到12楼，我被满眼的饮料和零食惊到了，没见过这种大场面。我们之前储备的idea押到了今年的关键字“择”，于是每个人就开始各搞各的，详细比赛过程就不多言。白嫖蒸功夫、披萨、小龙虾、K记的感觉真是太爽了，明年还来。</p>
<p>这次比赛印证了一点——我的技术确实存在短板，思维也常常跟不上，很多需求没做出来，设计的图也只用到一张。后端帮助了我很多，包括熬夜一整晚帮忙理清部分JS逻辑（惭愧）。命悬一刻的时候，都是后端救了我。没有我的队友，真的连阉割版产品都拿不出来。<br>一轮筛选的嘉宾有思否CEO高阳，有幸通过一轮筛选进入二轮，虽然最终没有获奖，但是已经很满意了。</p>
<p>顺带一提，同房间的大佬做的游戏实在牛逼（Re0从零开始的HUST生活），现场效果爆炸，拔得头筹。听到他们的商量和激烈的辩论，我发现，原来这就是Geek，他们对编程的热爱，是溢于言表的，即便是旁人也能深受感染，不像我遇到Bug时的萎靡无力。</p>
<p>经过HackDay，我认识到，学习编程是为了兴趣而非为了团队，真正的Geek用编程改变世界。几个月以来，在加入团队的室友和我侃侃而谈，以及和冰岩同学组队参加比赛之后，我愈来愈觉得，<strong>加入团队也并非我以前所以为的那样光鲜亮丽，团队人≠人上人。抬高对方，疯狂自贬的行为是错误的。</strong></p>
<p>看见大佬开发游戏的时候，我对游戏开发也产生了一定的兴趣，遂希望以后可以学一些框架去开发网页游戏。并且我认为，只是写网页确实有些普通，尝试客户端APP的开发也是一条可行之路。前端追求的是炫酷的特效和优秀的用户体验，我觉得也不错。当下先继续打好前端基础，<strong>不要把加入团队当作自己前进的动力</strong>，要因为喜欢，所以才用汗水浇灌它，哪怕最终什么团队都没加入，自己也可以在沁苑一隅发光发热。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Deep Dive with Evan You</title>
    <url>/2021/07/22/21.Deep%20Live%20with%20Evan%20You/</url>
    <content><![CDATA[<h1 id="render，h的传参"><a href="#render，h的传参" class="headerlink" title="render，h的传参"></a>render，h的传参</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>除了template，还可以为组件提供render函数，h（helper）作为渲染函数的参数，可以创造vnode，而mount可以把vnode挂载为真实dom结点</p>
<p>vnode接收的三个参数：</p>
<ol>
<li><p>类型，如’div’</p>
</li>
<li><p>对象，包含vnode上的所有数据、属性…</p>
</li>
<li><p>子结点</p>
<ul>
<li>直接传递一个字符串，如’hello’，表明这是一个文本子结点</li>
<li>也可传递一个包含更多子结点的数组，嵌套更多的嵌套的h调用</li>
</ul>
</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue@next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.mt-4</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.my-nav</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Stack</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Stack</span> <span class="attr">size</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Stack</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Stack</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; h, createApp &#125; = Vue;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> Stack = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> slot = <span class="built_in">this</span>.$slots.default</span></span><br><span class="line"><span class="javascript">        ? <span class="built_in">this</span>.$slots.default()</span></span><br><span class="line"><span class="javascript">        : []</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 尤大的例子，使用了插槽：</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;stack&#x27;</span> &#125;, slot.map(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 对Stack里的每一个子元素，都套上一层div，class为mt-4</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 在这个div中，把原先的子元素重复三次，再放进去</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">`mt-<span class="subst">$&#123;<span class="built_in">this</span>.$attrs.size&#125;</span>`</span>&#125;, [</span></span><br><span class="line"><span class="javascript">          child, child, child, </span></span><br><span class="line"><span class="javascript">        ])</span></span><br><span class="line"><span class="javascript">      &#125;))</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// return里使用vnode的三个参数：</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> h(<span class="string">&#x27;nav&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-nav&#x27;</span>&#125;, [</span></span><br><span class="line"><span class="javascript">        h(<span class="string">&#x27;nav&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-nav&#x27;</span>&#125;, <span class="string">&#x27;This is my nav 0&#x27;</span>),</span></span><br><span class="line"><span class="javascript">        h(<span class="string">&#x27;nav&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-nav&#x27;</span>&#125;, [</span></span><br><span class="line"><span class="javascript">          <span class="string">&#x27;This is my nav 1&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          h(<span class="string">&#x27;nav&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-nav&#x27;</span>&#125;, <span class="string">&#x27;This is my nav 2&#x27;</span>),</span></span><br><span class="line"><span class="javascript">          h(<span class="string">&#x27;nav&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-nav&#x27;</span>&#125;, <span class="string">&#x27;This is my nav 3&#x27;</span>),</span></span><br><span class="line"><span class="javascript">          h(<span class="string">&#x27;nav&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;my-nav&#x27;</span>&#125;, <span class="string">&#x27;This is my nav 4&#x27;</span>),</span></span><br><span class="line"><span class="javascript">        ]),</span></span><br><span class="line"><span class="javascript">      ])</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> App = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      Stack</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 此处不提供template选项，则默认使用dom内模板，即上方的html</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  createApp(App).mount(<span class="string">&#x27;#app&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="h的实现"><a href="#h的实现" class="headerlink" title="h的实现"></a>h的实现</h1><p>h函数的实现很简单，仅仅是把三个参数放入一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="mount的实现"><a href="#mount的实现" class="headerlink" title="mount的实现"></a>mount的实现</h1><p>创建结点，设置属性，插入孩子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 简化版mount</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 使用 vnode.el 存储dom元素，所以看到以前的vdom时，可以使用.el访问旧的真实dom树（与patch配合完成dom树的修改）</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> el = vnode.el = <span class="built_in">document</span>.createElement(vnode.tag)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// props —— 假设只用考虑attrs</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (vnode.props) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> vnode.props) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> value = vnode.props[key]</span></span><br><span class="line"><span class="javascript">        el.setAttribute(key, value)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// children —— 假设孩子都是数组</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (vnode.children) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.children === <span class="string">&#x27;string&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">        el.textContent = vnode.children</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        vnode.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          mount(child, el)</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    container.appendChild(el)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vdom = h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;red&#x27;</span> &#125;, [h(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello&#x27;</span>)])</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  mount(vdom, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>))</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><p>页面已经完成一次渲染，h函数生成vdom；</p>
</li>
<li><p>在一个响应式属性被更新时，触发重新渲染，重新生成vdom；</p>
</li>
<li><p>现需要对两个vdom进行比较，依赖patch函数，使dom反映更新后的状态</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vdom = h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;red&#x27;</span> &#125;, [</span><br><span class="line">  h(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vdom2 = h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;green&#x27;</span> &#125;, [</span><br><span class="line">  h(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;changed!&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">patch(vdom, vdom2)</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="selector-class">.red</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="css"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml">  <span class="selector-class">.green</span> &#123;</span></span></span><br><span class="line"><span class="css"><span class="xml">    <span class="attribute">color</span>: green;</span></span></span><br><span class="line"><span class="css"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="css"><span class="xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      tag,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      props,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      children,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// ...</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">const</span> vdom = h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;red&#x27;</span> &#125;, [h(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello&#x27;</span>)])</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  mount(vdom, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>))</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">n1, n2</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">if</span> (n1.tag === n2.tag) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> el = (n2.el = n1.el)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// props</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> oldProps = n1.props || &#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> newProps = n2.props || &#123;&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> oldValue = oldProps[key]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">const</span> newValue = newProps[key]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (newValue !== oldValue) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          el.setAttribute(key, newValue)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          el.removeAttribute(key)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="comment">// children</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> oldChildren = n1.children</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> newChildren = n2.children</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">if</span> (newChildren !== oldChildren) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            el.textContent = newChildren</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          el.textContent = newChildren</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          el.innerHTML = <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          newChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            mount(child, el)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">const</span> commonLength = <span class="built_in">Math</span>.min(oldChildren.length, newChildren.length)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            patch(oldChildren[i], newChildren[i])</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">if</span> (newChildren.length &gt; oldChildren.length) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            newChildren.slice(oldChildren.length).forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              mount(child, el)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            oldChildren.slice(oldChildren.length).forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">              el.removeChild(child.el)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">const</span> vdom2 = h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;green&#x27;</span> &#125;, [h(<span class="string">&#x27;span&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;hello&#x27;</span>)]);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  patch(vdom, vdom2) <span class="comment">// 原本字体为红色，刷新后字体为绿色</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="补充-Vue3响应式原理"><a href="#补充-Vue3响应式原理" class="headerlink" title="(补充)Vue3响应式原理"></a>(补充)Vue3响应式原理</h1><h2 id="Reactivity"><a href="#Reactivity" class="headerlink" title="Reactivity"></a>Reactivity</h2><p>本节主要讲述存储不同effect的方法，但还不能让effect自动重新运行</p>
<h3 id="dep"><a href="#dep" class="headerlink" title="dep"></a>dep</h3><p>effect函数可以计算出我们想要得到的结果，track函数用于将各个effect保存在dep集合中，trigger函数用于重新调用每个effect函数，更新值从而实现响应式</p>
<p>这里是第一步，将所有effect放入一个集合，trigger更新时将重新触发所有effect，有可能某个effect和quantity是无关的，却要再触发一次，这显然可以改进</p>
<img src="https://img-blog.csdnimg.cn/b53d6b532d6a43d3bec431506b310838.png" style="zoom: 33%;">

<h3 id="depsMap"><a href="#depsMap" class="headerlink" title="depsMap"></a>depsMap</h3><p>第二步，创建一个depsMap，可以保存对应不同属性的依赖（即effect函数），当某个属性改变，trigger时只需要重新触发和它有关的effect函数即可。</p>
<p>比如此处的effect和quantity有关，假如还有一个effect可计算出quantity * 10，那么它也会保存在quantity对应的dep中，在trigger执行时更新</p>
<p>现在的问题是，我们可能有多个响应式对象，它们含有不同的属性（可能有同名的属性），因此在外边还需要一层targetMap</p>
<img src="https://img-blog.csdnimg.cn/fda2ae9103334832b0f8b2ca6fce3db7.png" style="zoom: 33%;">

<h3 id="targetMap"><a href="#targetMap" class="headerlink" title="targetMap"></a>targetMap</h3><blockquote>
<p>weakMap的键可以是一个对象（此处保存每一个响应式对象），值对应之前的depsMap</p>
</blockquote>
<p>targetMap存储了每个响应式对象的依赖，depsMap存储了每个属性的依赖，dep是一个effects集的依赖</p>
<img src="https://img-blog.csdnimg.cn/d070de8aa35a40c38fb4d181054528a1.png" style="zoom: 33%;">



<img src="https://img-blog.csdnimg.cn/2d9a165f4665477484fdde9c0a2a6380.png" style="zoom: 33%;">

<h2 id="Proxy-and-Reflect"><a href="#Proxy-and-Reflect" class="headerlink" title="Proxy and Reflect"></a>Proxy and Reflect</h2><p>使用ES6的proxy和reflect，读取属性时自动调用track，修改属性时自动调用trigger</p>
<blockquote>
<p>了解：receiver保证了，当我们的对象有继承自其他对象的值或函数时，this指针能正确地指向使用的对象，避免一些在vue2中的响应式警告</p>
</blockquote>
<img src="https://img-blog.csdnimg.cn/e1dc743aee5144d7aa8cc68e071b6ca0.png" style="zoom: 33%;">

<h2 id="activeEffect"><a href="#activeEffect" class="headerlink" title="activeEffect"></a>activeEffect</h2><p>在之前的代码中，只要读取某个值，就会调用get中的track函数，遍历targetMap和各种依赖，这样会增加不必要的开销</p>
<p>activeEffect表示正在运行中的effect，只有当存在activeEffect时，再遍历targetMap</p>
<img src="https://img-blog.csdnimg.cn/b0258fe2e553471bbe85e00d2b51aa73.png" style="zoom: 50%;">



<p>视频作者说：“应当在effect中调用track函数”，我认为这样是正确的，在effect函数执行时，activeEffect不为null，此时调用track显得理所当然，但是代码中却没有体现对track的调用，activeEffect一下子又被设置为null。按照之前一节的理解，track在读取属性时被调用，在下方console.log时activeEffect已经变成null了，那track了个寂寞？</p>
<p>可能是这样的：在total = product.price * product.quantity 这一行，相当于已经访问了total，在此处调用了track，目前我只能这样理解了</p>
<img src="https://img-blog.csdnimg.cn/6923d4ea811a471bb87a96537010d121.png" style="zoom: 50%;">

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>上方介绍了reactive的实现，此处介绍ref：</p>
<p>ref可以把某个变量变成响应式，它无需作为某个对象的属性</p>
<img src="https://img-blog.csdnimg.cn/a2316546774d4443ae97ec4d5b4e4dc6.png" style="zoom: 50%;">

<h1 id="从零构建响应式"><a href="#从零构建响应式" class="headerlink" title="从零构建响应式"></a>从零构建响应式</h1><p>以下的两节，和上方的Vue3响应式原理大致相同</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.depend() <span class="comment">// track</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._value = newValue</span><br><span class="line">    <span class="built_in">this</span>.notify() <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subscribers.add(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  effect()</span><br><span class="line">  activeEffect = <span class="literal">null</span>    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ok = <span class="keyword">new</span> Dep(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> msg = <span class="keyword">new</span> Dep(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ok.value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg.value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;false branch&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">msg.value = <span class="string">&#x27;changed&#x27;</span>  <span class="comment">// 触发set中的notify函数，重新执行effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印结果：</span></span><br><span class="line"><span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;changed&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="从零构建-Reactive"><a href="#从零构建-Reactive" class="headerlink" title="从零构建 Reactive"></a>从零构建 Reactive</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  subscribers = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subscribers.add(activeEffect)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.subscribers.forEach(<span class="function"><span class="params">effect</span> =&gt;</span> &#123;</span><br><span class="line">    effect()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  effect()</span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.get(target)</span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    targetMap.set(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.get(key)</span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    depsMap.set(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reactiveHandlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = getDep(target, key)</span><br><span class="line">    <span class="keyword">const</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">    dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">state.count++;</span><br></pre></td></tr></table></figure>

<h1 id="构建Vue"><a href="#构建Vue" class="headerlink" title="构建Vue"></a>构建Vue</h1><p>vdom + reactive 即构建出了一个小型的Vue，现在的场景是：点击组件实现count值增加，并响应式地体现在页面上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// vdom</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, props, children</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      tag,</span></span><br><span class="line"><span class="javascript">      props,</span></span><br><span class="line"><span class="javascript">      children,</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; tag, props, children &#125; = vnode</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> el = (vnode.el = <span class="built_in">document</span>.createElement(tag))</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (props) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> value = props[key]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (key.startsWith(<span class="string">&#x27;on&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 监听事件</span></span></span><br><span class="line"><span class="javascript">          el.addEventListener(key.slice(<span class="number">2</span>).toLowerCase(), value)</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          el.setAttribute(key, value)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (children) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span></span><br><span class="line"><span class="javascript">        children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;string&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">            el.append(child)</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;object&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">            mount(child, el)</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        el.append(children)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    container.append(el)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">n1, n2</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (n1.tag === n2.tag) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> el = (n2.el = n1.el)</span></span><br><span class="line"><span class="javascript">      <span class="comment">//diff props</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> oldProps = n1.props || &#123;&#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> newProps = n2.props || &#123;&#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//添加新的属性或更改原来已有但变化了的属性</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> newProps) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> oldValue = oldProps[key]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> newValue = newProps[key]</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (newValue !== oldValue) &#123;</span></span><br><span class="line"><span class="javascript">          el.setAttribute(key, newValue)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">//移除新属性中没有的属性</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldProps) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span></span><br><span class="line"><span class="javascript">          el.removeAttribute(key)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">//diff children</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> oldChildren = n1.children</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> newChildren = n2.children</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (oldChildren !== newChildren) &#123;</span></span><br><span class="line"><span class="javascript">            el.innerHTML = newChildren</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span></span><br><span class="line"><span class="javascript">        <span class="keyword">typeof</span> oldChildren === <span class="string">&#x27;string&#x27;</span> &amp;&amp;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Array</span>.isArray(newChildren)</span></span><br><span class="line"><span class="javascript">      ) &#123;</span></span><br><span class="line"><span class="javascript">        el.innerHTML = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">        newChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> mount(child, el))</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(oldChildren) &amp;&amp; <span class="built_in">Array</span>.isArray(newChildren)) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> minLength = <span class="built_in">Math</span>.min(oldChildren.length, newChildren.length)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minLength; i++) &#123;</span></span><br><span class="line"><span class="javascript">          patch(oldChildren[i], newChildren[i])</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (oldChildren.length === minLength) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; newChildren.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            mount(newChildren[i], el)</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = minLength; i &lt; oldChildren.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">            el.removeChild(oldChildren[i].el)</span></span><br><span class="line"><span class="javascript">          &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//replace</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// reactivity</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> activeEffect = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    subs = <span class="keyword">new</span> <span class="built_in">Set</span>()</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (activeEffect) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.subs.add(activeEffect)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub())</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params">effect</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    activeEffect = effect</span></span><br><span class="line"><span class="javascript">    effect()</span></span><br><span class="line"><span class="javascript">    activeEffect = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">getDep</span>(<span class="params">target, key</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!targetMap.has(target)) &#123;</span></span><br><span class="line"><span class="javascript">      targetMap.set(target, <span class="keyword">new</span> <span class="built_in">Map</span>())</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> depMap = targetMap.get(target)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!depMap.has(key)) &#123;</span></span><br><span class="line"><span class="javascript">      depMap.set(key, <span class="keyword">new</span> Dep())</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> depMap.get(key)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> reactiveHandlers = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">get</span>(<span class="params">target, key, receiver</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> dep = getDep(target, key)</span></span><br><span class="line"><span class="javascript">      dep.depend()</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">set</span>(<span class="params">target, key, value, receiver</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> dep = getDep(target, key)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> ret = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span></span><br><span class="line"><span class="javascript">      dep.notify()</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> ret</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">raw</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(raw, reactiveHandlers)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// component组件实例，container要挂载的dom元素</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">mountApp</span>(<span class="params">component, container</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> isMounted = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> oldVdom</span></span><br><span class="line"><span class="javascript">    watchEffect(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (!isMounted) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//第一次挂载</span></span></span><br><span class="line"><span class="javascript">        oldVdom = component.render()</span></span><br><span class="line"><span class="javascript">        mount(oldVdom, container)</span></span><br><span class="line"><span class="javascript">        isMounted = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//数据变化,要进行更新</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> newVdom = component.render()</span></span><br><span class="line"><span class="javascript">        patch(oldVdom, newVdom)</span></span><br><span class="line"><span class="javascript">        oldVdom = newVdom</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> App = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: reactive(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">    &#125;),</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, [</span></span><br><span class="line"><span class="javascript">        h(</span></span><br><span class="line"><span class="javascript">          <span class="string">&#x27;div&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">onClick</span>: <span class="function">() =&gt;</span> App.data.count++,</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="built_in">String</span>(<span class="built_in">this</span>.data.count)</span></span><br><span class="line"><span class="javascript">        ),</span></span><br><span class="line"><span class="javascript">      ])</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//一个点击自增的计数器</span></span></span><br><span class="line"><span class="javascript">  mountApp(App, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>))</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web开发</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3笔记</title>
    <url>/2021/07/31/22.Vue3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="创建Vue3-0工程"><a href="#创建Vue3-0工程" class="headerlink" title="创建Vue3.0工程"></a>创建Vue3.0工程</h1><h2 id="createApp"><a href="#createApp" class="headerlink" title="createApp"></a>createApp</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App)</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载</span></span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>使用vite创建工程的步骤（了解）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入工程目录</span></span><br><span class="line">cd &lt;project-name&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">npm i</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h1 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h1><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><ol>
<li>理解：setup是一个新的配置项，值为一个函数</li>
<li>setup是所有<code>Composition API</code>表演的舞台</li>
<li>组件中用到的数据方法等，都要配置在setup中</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法，在模板中均可以直接使用</li>
<li>若返回一个渲染函数，则可以自定义渲染内容（了解）</li>
</ol>
</li>
<li>注意点：<ol>
<li>不要和Vue2.x配置混用<ul>
<li>2.x配置可以访问到setup中的属性和方法，但反过来不行</li>
<li>如果有重名，setup优先</li>
</ul>
</li>
<li>setup不能是async函数</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h1&gt;一个人的信息&lt;/h1&gt;</span><br><span class="line"> &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;button @click=&quot;sayHello&quot;&gt;说话(Vue3所配置的——sayHello)&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> // import &#123;h&#125; from &#x27;vue&#x27;</span><br><span class="line"> export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  // 此处只是测试一下setup，暂时不考虑响应式的问题</span><br><span class="line">  setup()&#123;</span><br><span class="line">   // 数据</span><br><span class="line">   let name = &#x27;张三&#x27;</span><br><span class="line">   let age = 18</span><br><span class="line"></span><br><span class="line">   // 方法</span><br><span class="line">   function sayHello()&#123;</span><br><span class="line">    alert(`我叫$&#123;name&#125;，我$&#123;age&#125;岁了，你好啊！`)</span><br><span class="line">   &#125;</span><br><span class="line">   // 返回一个对象（常用）</span><br><span class="line">   return &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 返回一个函数（渲染函数）</span><br><span class="line">      // 它会覆盖模板中的内容，比如此处页面上只显示&lt;h1&gt;尚硅谷&lt;/h1&gt;</span><br><span class="line">   // return ()=&gt; h(&#x27;h1&#x27;,&#x27;尚硅谷&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><p>作用：定义一个响应式的数据</p>
</li>
<li><p>语法：<code>const xxx = ref(initValue)</code></p>
<ul>
<li>创建一个包含响应式数据的引用对象（reference对象）</li>
<li>操作数据：<code>xxx.value</code></li>
<li>模板中读取数据不需要.value</li>
</ul>
</li>
<li><p>备注：</p>
<ul>
<li>接收数据类型：基本类型、对象类型</li>
<li>基本类型数据的响应式靠<code>Object.defineProperty()</code>的get和set完成</li>
<li>对象类型数据求助了<code>reactive</code>函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//数据</span></span><br><span class="line">  <span class="keyword">let</span> name = ref(<span class="string">&#x27;张三&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> age = ref(<span class="number">18</span>)</span><br><span class="line">  <span class="keyword">let</span> job = ref(&#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;前端工程师&#x27;</span>,</span><br><span class="line">    <span class="attr">salary</span>:<span class="string">&#x27;30K&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  	name.value = <span class="string">&#x27;李四&#x27;</span></span><br><span class="line">  	age.value = <span class="number">48</span></span><br><span class="line">  	job.value.type = <span class="string">&#x27;UI设计师&#x27;</span></span><br><span class="line">  	job.value.salary = <span class="string">&#x27;60K&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      name,</span><br><span class="line">      age,</span><br><span class="line">      job,</span><br><span class="line">      changeInfo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h2><ul>
<li>作用：定义<strong>对象类型</strong>的响应式数据</li>
<li>语法：<code>const 代理对象 = reactive(源对象)</code>，接收一个对象（或数组），返回一个proxy对象</li>
<li>定义的响应式数据是“深层次的”（即便是对象的对象的属性，修改时也能实现响应式）</li>
<li>内部基于ES6的Proxy实现，通过代理对象操作元对象内部数据进行操作</li>
</ul>
<h2 id="响应式实现原理"><a href="#响应式实现原理" class="headerlink" title="响应式实现原理"></a>响应式实现原理</h2><h3 id="vue2-x"><a href="#vue2-x" class="headerlink" title="vue2.x"></a>vue2.x</h3><ul>
<li><p>原理：</p>
<ul>
<li>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）</li>
<li>数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹，本节视频未提及）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">  get () &#123;&#125;,</span><br><span class="line">  set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>存在问题</p>
<ul>
<li>新增属性、删除属性，页面不会更新</li>
<li>直接通过下标修改数组，界面不会自动更新</li>
</ul>
</li>
<li><p>一些解决策略：</p>
<ul>
<li>使用<code>$set()</code></li>
<li>引入Vue，使用<code>Vue.set()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">addSex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="built_in">this</span>.$set(<span class="built_in">this</span>.person, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line">    <span class="comment">// 方法二</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在外部 import Vue from &#x27;vue&#x27;</span></span><br><span class="line">    Vue.set(<span class="built_in">this</span>.person, <span class="string">&#x27;sex&#x27;</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><ul>
<li>实现原理: <ul>
<li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
<ul>
<li>Reflect的好处：ECMA正尝试把越来越多的属性和方法从Object移植到Reflect上，Reflect的方法执行遇到错误时不会报错，而是将自身的返回值设置为false，在框架中，便于捕获错误</li>
</ul>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line"> <span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="reactive对比ref"><a href="#reactive对比ref" class="headerlink" title="reactive对比ref"></a>reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong> <code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong> <code>.value</code>。</li>
<li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong> <code>.value</code>。</li>
<li> 一般使用reactive更多，把属性全部定义在对象中，把对象定义在data数据中，只用return data</li>
</ul>
</li>
</ul>
<h2 id="setup的两个注意点"><a href="#setup的两个注意点" class="headerlink" title="setup的两个注意点"></a>setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>子组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&#x27;Demo&#x27;</span>,</span><br><span class="line"> <span class="attr">props</span>:[<span class="string">&#x27;msg&#x27;</span>,<span class="string">&#x27;school&#x27;</span>],</span><br><span class="line"> <span class="attr">emits</span>:[<span class="string">&#x27;hello&#x27;</span>],</span><br><span class="line"> <span class="function"><span class="title">setup</span>(<span class="params">props,context</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;---setup---&#x27;</span>,props)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;---setup---&#x27;</span>,context)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;---setup---&#x27;</span>,context.attrs) <span class="comment">//相当与Vue2中的$attrs</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;---setup---&#x27;</span>,context.emit)  <span class="comment">//触发自定义事件的。</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;---setup---&#x27;</span>,context.slots) <span class="comment">//插槽</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">let</span> person = reactive(&#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">   <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">  &#125;)</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   context.emit(<span class="string">&#x27;hello&#x27;</span>,<span class="number">666</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">   person,</span><br><span class="line">   test</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>App组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;Demo @hello=&quot;showHelloMsg&quot; msg=&quot;你好啊&quot; school=&quot;尚硅谷&quot;&gt;</span><br><span class="line">  &lt;template v-slot:qwe&gt;</span><br><span class="line">   &lt;span&gt;尚硅谷&lt;/span&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;!--由于兼容性问题，命名插槽使用 v-slot:插槽名 的形式--&gt;</span><br><span class="line">  &lt;template v-slot:asd&gt;</span><br><span class="line">   &lt;span&gt;尚硅谷&lt;/span&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"> &lt;/Demo&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h2 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">//计算属性——简写(没有考虑计算属性被修改的情况)</span></span><br><span class="line">    <span class="keyword">let</span> fullName = computed(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.firstName + <span class="string">&#x27;-&#x27;</span> + person.lastName</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = computed(&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> person.firstName + <span class="string">&#x27;-&#x27;</span> + person.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.firstName = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.lastName = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> msg = ref(<span class="string">&#x27;你好啊&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person = reactive(&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="attr">job</span>:&#123;</span><br><span class="line">    <span class="attr">j1</span>:&#123;</span><br><span class="line">      <span class="attr">salary</span>:<span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line">watch(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line">watch([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">	     若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue</span></span><br><span class="line"><span class="comment">	     若watch监视的是reactive定义的响应式数据，则强制开启了深度监视</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">watch(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line">watch(<span class="function">()=&gt;</span>person.job,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line">watch([<span class="function">()=&gt;</span>person.job,<span class="function">()=&gt;</span>person.name],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;person的job/name变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line">watch(<span class="function">()=&gt;</span>person.job,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="watch时value的问题"><a href="#watch时value的问题" class="headerlink" title="watch时value的问题"></a>watch时value的问题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> msg = ref(<span class="string">&#x27;你好啊&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> person = ref(&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">job</span>:&#123;</span><br><span class="line">      <span class="attr">j1</span>:&#123;</span><br><span class="line">        <span class="attr">salary</span>:<span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通类型数据，不能.value</span></span><br><span class="line">  watch(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sum的值变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象类型数据二选一：</span></span><br><span class="line">  <span class="comment">//    1. person.value（它是一个proxy对象）</span></span><br><span class="line">  <span class="comment">//    2. 第一个参数不.value，开启深度监视</span></span><br><span class="line">  watch(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;person的值变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    sum,</span><br><span class="line">    msg,</span><br><span class="line">    person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line">watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.value</span><br><span class="line">    <span class="keyword">const</span> x2 = person.age</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" style="zoom:80%;">

<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>===&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>===&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> ===&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ===&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> ===&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;---setup---&#x27;</span>)</span><br><span class="line">  <span class="comment">//数据</span></span><br><span class="line">  <span class="keyword">let</span> sum = ref(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过组合式API的形式去使用生命周期钩子</span></span><br><span class="line">  onBeforeMount(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;---onBeforeMount---&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;---onMounted---&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUpdate(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;---onBeforeUpdate---&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUpdated(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;---onUpdated---&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUnmount(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;---onBeforeUnmount---&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;---onUnmounted---&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;sum&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title="自定义hook函数"></a>自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h2><ul>
<li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。这样在template中，可以少写’点儿’</li>
<li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li>
<li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li>
</ul>
<ul>
<li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h4&gt;&#123;&#123;person&#125;&#125;&lt;/h4&gt;</span><br><span class="line"> &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line"> &lt;h2&gt;薪资：&#123;&#123;job.j1.salary&#125;&#125;K&lt;/h2&gt;</span><br><span class="line"> &lt;button @click=&quot;name+=&#x27;~&#x27;&quot;&gt;修改姓名&lt;/button&gt;</span><br><span class="line"> &lt;button @click=&quot;age++&quot;&gt;增长年龄&lt;/button&gt;</span><br><span class="line"> &lt;button @click=&quot;job.j1.salary++&quot;&gt;涨薪&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import &#123;ref,reactive,toRef,toRefs&#125; from &#x27;vue&#x27;</span><br><span class="line"> export default &#123;</span><br><span class="line">  name: &#x27;Demo&#x27;,</span><br><span class="line">  setup()&#123;</span><br><span class="line">   let person = reactive(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    job:&#123;</span><br><span class="line">     j1:&#123;</span><br><span class="line">      salary:20</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   return &#123;</span><br><span class="line">    person,</span><br><span class="line">    // name:toRef(person,&#x27;name&#x27;),</span><br><span class="line">    // age:toRef(person,&#x27;age&#x27;),</span><br><span class="line">    // salary:toRef(person.job.j1,&#x27;salary&#x27;),</span><br><span class="line">    ...toRefs(person) // 只能拿到job，j1和salary仍需要&#x27;点儿&#x27;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h1><h2 id="shallowReactive-与-shallowRef"><a href="#shallowReactive-与-shallowRef" class="headerlink" title="shallowReactive 与 shallowRef"></a>shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="readonly-与-shallowReadonly"><a href="#readonly-与-shallowReadonly" class="headerlink" title="readonly 与 shallowReadonly"></a>readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="toRaw-与-markRaw"><a href="#toRaw-与-markRaw" class="headerlink" title="toRaw 与 markRaw"></a>toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。（person原先没有car属性，点击按钮添加car属性，并且直接对其markRaw，这样car属性以后就不会再成为响应式对象了）</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：这种方式会修改数据，只是页面上没有响应式；readonly连数据都无法修改</p>
</blockquote>
<h2 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line"> &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line"> export default &#123;</span><br><span class="line">  name:&#x27;Demo&#x27;,</span><br><span class="line">  setup()&#123;</span><br><span class="line">   //自定义一个myRef</span><br><span class="line">   function myRef(value,delay)&#123;</span><br><span class="line">    let timer</span><br><span class="line">    //通过customRef去实现自定义</span><br><span class="line">    return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">     return&#123;</span><br><span class="line">      get()&#123;</span><br><span class="line">       track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">       return value</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newValue)&#123;</span><br><span class="line">       clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(()=&gt;&#123;</span><br><span class="line">        value = newValue</span><br><span class="line">        trigger() //告诉Vue去更新界面</span><br><span class="line">       &#125;,delay)</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">   return &#123;</span><br><span class="line">    keyword</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="provide-与-inject"><a href="#provide-与-inject" class="headerlink" title="provide 与 inject"></a>provide 与 inject</h2><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px">

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖先与后代组件间</strong>通信</p>
</li>
<li><p>套路：祖先组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖先组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> ......</span><br><span class="line">    <span class="keyword">let</span> car = reactive(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    provide(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后代组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props,context</span>)</span>&#123;</span><br><span class="line"> ......</span><br><span class="line">    <span class="keyword">const</span> car = inject(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line"> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="响应式数据的判断"><a href="#响应式数据的判断" class="headerlink" title="响应式数据的判断"></a>响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
]]></content>
      <categories>
        <category>web开发</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js笔记</title>
    <url>/2021/06/18/16.Vue2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>黑马四小时入门视频笔记：</p>
<h2 id="基本-v-on"><a href="#基本-v-on" class="headerlink" title="基本/v-on"></a>基本/v-on</h2><p>从一个基本程序讲起，它的功能是：点击按钮增加数值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引入Vue--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--插值表达式--&gt;</span></span><br><span class="line">    &#123;&#123; message + &#x27;*&#x27; + num&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;addNum&quot;</span>&gt;</span>增加number值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 创建Vue实例对象</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">// 设置挂载点，可以用多种CSS选择器，推荐ID选择器</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;Hello World&quot;</span>, <span class="comment">// 设置data，它的属性可以是对象或数组等</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">num</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123; <span class="comment">// 绑定的方法定义在methods属性中</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">addNum</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.num++;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li>除了插值表达式（双大括号），还可以设置标签的<code>v-text</code>和<code>v-html</code>，如v-text=”message”，这样做会将标签内的内容覆盖</li>
<li>除了@，还可以用<code>v-on</code>来绑定方法，如<code>v-on:click=&quot;addNum&quot;</code></li>
<li>方法内部通过<code>this</code>关键字来访问定义在data中的数据</li>
</ul>
<h2 id="v-show-v-if-v-bind"><a href="#v-show-v-if-v-bind" class="headerlink" title="v-show/v-if/v-bind"></a>v-show/v-if/v-bind</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">img</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.hot</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">outline</span>: <span class="number">5px</span> solid red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toggleShow&quot;</span>&gt;</span>切换图片显示状态<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;tempUp&quot;</span>&gt;</span>升高温度<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;tempDown&quot;</span>&gt;</span>降低温度<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;&#x27;当前是&#x27;+ temp + &#x27;度&#x27;&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgSrc1&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;title1&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;hot:temp&gt;30&#125;&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgSrc2&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;title2&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--v-bind设置属性，:src相当于v-bind:src，其余同理&gt;</span></span><br><span class="line"><span class="comment">  &lt;!--v-show和v-if设置图片是否可见，值为true时可见--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">imgSrc1</span>: <span class="string">&quot;./img/1.jpg&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">imgSrc2</span>: <span class="string">&quot;./img/2.jpg&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">title1</span>: <span class="string">&quot;神乃木&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">title2</span>: <span class="string">&quot;御冥&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">isShow</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">temp</span>: <span class="number">25</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">toggleShow</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.isShow = !<span class="built_in">this</span>.isShow;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">tempUp</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.temp++;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">tempDown</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.temp--;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>v-show</code>和<code>v-if</code>区别：前者是设置display:none，而后者是直接修改dom树，由于前者的性能更优，在切换频繁时应使用前者</li>
<li><code>v-bind:src</code>可以简写成<code>:src</code>（其余同理）；设置类名时，可以用三目运算符，如：<code>:class=&quot;isActive?active&quot;</code>可以写成<code>:class=&quot;&#123;active:isActive&#125;&quot;</code></li>
</ul>
<h2 id="v-for-v-on-v-model"><a href="#v-for-v-on-v-model" class="headerlink" title="v-for/v-on/v-model"></a>v-for/v-on/v-model</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">li</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>输入角色名：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      v-model可以便捷地设置和获取表单元素的值，</span></span><br><span class="line"><span class="comment">      input的value和newName动态双向绑定，即一方的值变化时另一方也会立即改变</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;newName&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--@keyup.enter表示按下回车键，这里是对v-on的拓展--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in nameArr&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--v-for用于生成列表，in可以是数组...--&gt;</span></span><br><span class="line">      &#123;&#123;index + 1&#125;&#125;. 逆转裁判的角色：&#123;&#123;item&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-for</span>=<span class="string">&quot;item in person&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--数组内的元素是对象的情况--&gt;</span></span><br><span class="line">      神乃木前辈的爱好：&#123;&#123;item.hobby&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">nameArr</span>: [<span class="string">&quot;成步堂龙一&quot;</span>, <span class="string">&quot;御剑怜恃&quot;</span>, <span class="string">&quot;王泥喜法介&quot;</span>, <span class="string">&quot;夕月心音&quot;</span>, <span class="string">&quot;神乃木庄龙&quot;</span>],</span></span><br><span class="line"><span class="javascript">        <span class="attr">person</span>: [&#123; <span class="attr">name</span>: <span class="string">&quot;神乃木庄龙&quot;</span>, <span class="attr">job</span>: <span class="string">&quot;律师、检察官&quot;</span>, <span class="attr">hobby</span>: <span class="string">&quot;喝咖啡&quot;</span> &#125;],</span></span><br><span class="line"><span class="javascript">        <span class="attr">newName</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">insert</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.nameArr.push(<span class="built_in">this</span>.newName); <span class="comment">// 不要忘记this</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基于数据的开发方式：无需关心dom，只要数据发生改变，页面内容就能响应式地发生改变</p>
<h2 id="vue和axios"><a href="#vue和axios" class="headerlink" title="vue和axios"></a>vue和axios</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;number&quot; placeholder=&quot;请输入要获取的笑话条数&quot; oninput=&quot;if(value&gt;100)value=100&quot; v-model=&quot;jokeNum&quot; @keyup.enter=&quot;getJoke&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;getJoke&quot;&gt;获取笑话&lt;/button&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in jokes&quot;&gt;</span><br><span class="line">        &#123;&#123; item &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    let app = new Vue(&#123;</span><br><span class="line">      el: &quot;#app&quot;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        jokeNum: 1,</span><br><span class="line">        jokes: []</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        getJoke: function () &#123;</span><br><span class="line">          // 发送axios的方式</span><br><span class="line">          axios.get(`https://autumnfish.cn/api/joke/list?num=$&#123;this.jokeNum&#125;`).then(</span><br><span class="line">            // 获取笑话的API</span><br><span class="line">            (res) =&gt; &#123;</span><br><span class="line">              this.jokes = res.data.jokes;  </span><br><span class="line">              // 老师说axios中的this和外部的this不一样，故要先that = this，此处用that</span><br><span class="line">              // 但是直接在axios内部用this也是可行的</span><br><span class="line">            &#125;,</span><br><span class="line">            (err) =&gt; &#123;</span><br><span class="line">              console.error(err);</span><br><span class="line">            &#125;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h1 id="完整版"><a href="#完整版" class="headerlink" title="完整版"></a>完整版</h1><p>尚硅谷教程笔记：</p>
<h2 id="Vue核心"><a href="#Vue核心" class="headerlink" title="Vue核心"></a>Vue核心</h2><h3 id="初识Vue"><a href="#初识Vue" class="headerlink" title="初识Vue"></a>初识Vue</h3><p>创建一个Vue的实例对象，整个应用只需要一个Vue：</p>
<ul>
<li><code>el</code>(element)用于指定当前Vue实例为哪个容器服务</li>
<li><code>data</code>存储数据，为root容器提供数据，值为一个对象</li>
</ul>
<p>除了el，第二种挂载root的方法（后期挂载的方式，不常用）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">        <span class="attr">address</span>: <span class="string">&#x27;宏福科技园综合楼&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.$mount(<span class="string">&#x27;#root&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>data的函数式写法：data是一个函数，返回数据对象（组件化编码必须使用函数式data）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span><br><span class="line">        <span class="attr">address</span>: <span class="string">&#x27;宏福科技园综合楼&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意：</p>
<ol>
<li>若使用函数式data，Vue会帮我们调用data函数，Vue就会得到返回的数据对象，从而使用，此时this是Vue的实例对象</li>
<li>data不要写成箭头函数，否则this的指向为window</li>
</ol>
<blockquote>
<p>重要原则：由Vue所管理的函数，写成普通函数（watch中的函数，computed中的函数）；不由Vue管理的函数，写成箭头函数(ajax、定时器)</p>
</blockquote>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><ol>
<li>插值语法：<ul>
<li>功能：解析标签体内容</li>
<li>写法：，xxx会作为<code>表达式</code>解析，且可以自动读取到data中的属性</li>
</ul>
</li>
<li>指令语法：<ul>
<li>功能：解析标签（包括：标签属性、标签内容、绑定事件…）</li>
<li>举例：v-bind: …</li>
</ul>
</li>
</ol>
<h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><ul>
<li>单向数据绑定（v-bind）：data中的值传给input，但input的输入不影响data</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>双向数据绑定（v-model）：data中的值传给input，input的值传给data</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h3><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><ul>
<li>M：模型（Model）：对应data中的数据</li>
<li>V：视图（View）：模板代码</li>
<li>VM：视图模型（ViewModel）：Vue实例对象</li>
</ul>
<p><img src="/2021/06/18/16.Vue2%E7%AC%94%E8%AE%B0/1.jpg"></p>
<h4 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h4><ol>
<li><p>什么是数据代理？</p>
<p>（1）数据代理：配置对象data中的数据，会被收集到<code>vm._data</code>中，然后通过<code>Object.defineProperty</code>，让vm拥有data所有的值</p>
<p>（2）当访问vm的某值时，返回的是<code>_data</code>中同名属性的值</p>
<p>（3）当修改vm的某值时，修改的是<code>_data</code>中同名属性的值</p>
</li>
<li><p>数据代理的原理：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _data = &#123;<span class="attr">msg</span>:<span class="string">&quot;尚硅谷&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> vm = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">&#x27;msg&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 设置vm.msg的同时也设置_data.msg</span></span><br><span class="line">        _data.msg = value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 读取vm.msg时返回_data.msg</span></span><br><span class="line">        <span class="keyword">return</span> _data.msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>为什么要数据代理？</p>
<p>为了更方便地读取和修改data中的数据，不这样的话，就要使用vm._data.xxx</p>
</li>
<li><p>为什么要先收集到<code>_data</code>中，再代理出去？</p>
<p>为了监视数据更高效（Vue不知道程序员在data中有多少属性，数据代理时可以只用监视_data，而不用监视整个vm）</p>
</li>
</ol>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>触发事件的函数可以带括号，也可以不带</li>
<li>指定参数会覆盖event，如果需要event，传入<code>$event</code>，<strong>一般</strong>作为第一个参数</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">@click=&quot;show1&quot;</span><br><span class="line"></span><br><span class="line">@click=&quot;show2($event, 666)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><ul>
<li><code>.prevent</code>：阻止默认行为，比如防止点击带href的a标签会跳转至其他页面</li>
<li><code>.stop</code>：阻止事件冒泡，比如防止点击子元素的事件，冒泡到点击父元素的事件</li>
<li><code>.once</code>：事件仅可触发一次</li>
<li><code>keyup.enter</code>：输入回车键，与之类似的还有<code>.esc</code>等，也可以<code>.按键编码</code>（未来版本可能废弃.编码）</li>
<li><code>.native</code>：该事件为原生DOM事件，不需要配置emit即可触发（见自定义事件）</li>
</ul>
<h4 id="表达式操作"><a href="#表达式操作" class="headerlink" title="表达式操作"></a>表达式操作</h4><p>如取反，不需要在methods中定义函数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isHot = !isHot&quot;</span>&gt;</span></span><br><span class="line">    切换天气</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ul>
<li><p>介绍：计算属性是由data中属性计算得来的新属性，vm里有计算属性，但_data中没有</p>
</li>
<li><p>执行时机：</p>
<ol>
<li>初始显示会执行一次，得到初始值去显示</li>
<li>当依赖的数据发生改变时，会被再次调用</li>
</ol>
</li>
<li><p>优势：与methods实现相比，内部有缓存机制，效率更高</p>
</li>
<li><p>备注：计算属性是用于直接读取使用的，不要加()</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;神乃木&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;庄龙&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h3><ul>
<li>介绍：监测数据改变的手段，数据发生改变后执行一些操作</li>
<li>执行时机：data中被监视的值改变时调用</li>
<li>两个参数：分别是新值和原值</li>
<li>备注：函数名要和被监视的变量名一致</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现和上方computed相同的功能</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">firstName</span>(<span class="params">newValue, oldValue</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.fullName = newValue + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">lastName</span>(<span class="params">newValue, oldValue</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.newValue</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>computed和watch的区别：</p>
<ol>
<li>只要是computed能完成的功能，watch都可以完成</li>
<li>watch可以进行异步操作（比如定时器1s后修改fullName），但computed不可以</li>
</ol>
<p>监视的完整版：（了解）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    <span class="comment">// 监测姓和名，此处只需要将其一改为完整写法：</span></span><br><span class="line">    <span class="attr">firstName</span>:&#123;</span><br><span class="line">        <span class="attr">immediate</span>: <span class="literal">true</span>,    <span class="comment">// 该值为true则handler在初始化时就会调用一次，以后的调用看firstName的改变</span></span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span>&#123;  <span class="comment">// 该函数必须叫handler</span></span><br><span class="line">            <span class="built_in">this</span>.fullName = newValue + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">lastName</span>(<span class="params">newValue, oldValue</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.fullName = <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.newValue</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监视的第二种绑定方法（不常用）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">&#x27;firstName&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">immediate</span>: <span class="literal">true</span>,  <span class="comment">// 该值为true则handler在初始化时就会调用一次，以后的调用看firstName的改变</span></span><br><span class="line">        <span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span>&#123;  <span class="comment">// 该函数必须叫handler</span></span><br><span class="line">        <span class="built_in">this</span>.fullName = newValue + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="class与style绑定"><a href="#class与style绑定" class="headerlink" title="class与style绑定"></a>class与style绑定</h3><p>class的写法（数组写法不常用，未列出）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--class的字符串写法，适用于：类名不确定，要动态获取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;myStyle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--class的对象写法，适用于：类名确定，但不确定用不用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;classA:hasA, classB:hasB&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--class的三元表达式写法，使用情况同上--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:class</span>=<span class="string">&quot;hasA ? &#x27;classA&#x27; : &#x27;&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>绑定style：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--fontSize在data中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize:size + &#x27;px&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>v-show和v-if在入门处已经说得详细，下述总结：</p>
<ul>
<li>v-if（还有v-else-if和v-else）：<ul>
<li>适用于：切换频率很低的场景</li>
<li>特点：不展示的DOM结点直接被删除（触发回流重绘）</li>
</ul>
</li>
<li>v-show：<ul>
<li>适用于：切换频率很高的场景</li>
<li>特点：不展示的DOM结点没有被删除，仅仅用样式隐藏</li>
</ul>
</li>
<li>备注：使用v-if时，DOM结点可能无法获取到，而使用v-show一定可以获取到DOM结点</li>
</ul>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>标准写法需要加上key属性，key属性要求每一个元素都是不同的值</p>
<h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4><p>这里假设数组内每一个元素都是一个对象，每一个对象的id都不同</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in arr&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h4><p>括号内的key表示键名，由于对象不存在重复键名，故可以赋值给key属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in obj&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;key&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><p>data表示字符，index是该字符在字符串内的序号，由于序号不会重复，故可以赋值给key属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(data, index) in str&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h3><p>各种情况：</p>
<ul>
<li>若是<code>&lt;input type=&quot;text&quot;&gt;</code>，则v-model收集的是value值</li>
<li>若是<code>&lt;input type=&quot;radio&quot;&gt;</code>，则v-model收集的是value值</li>
<li>若是<code>&lt;input type=&quot;checkbox&quot;&gt;</code>：<ul>
<li>没有配置value属性：收集的是checked（布尔值）</li>
<li>配置value属性：<ul>
<li>v-model的初始值是非数组：收集的是checked</li>
<li>是数组：收集的是由value组成的数组</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--一般表单都不会写action，并去除提交刷新的默认事件，使用ajax提交--&gt;</span></span><br><span class="line">        账号: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.account&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        性别: 男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">            女<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        爱好：抽烟<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;smoke&quot;</span>&gt;</span></span><br><span class="line">           喝酒<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;drink&quot;</span>&gt;</span></span><br><span class="line">           开车<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;userInfo.hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;drive&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        所属校区：<span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;city&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>请选择校区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        其他信息：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;other&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>阅读并接受<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.atguigu.com&quot;</span>&gt;</span>《用户协议》<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">            提交</span><br><span class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        userInfo&#123;</span><br><span class="line">          <span class="attr">account</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">sex</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">          <span class="attr">hobby</span>: [],</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">other</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">agree</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">submit</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>生命周期分为：</p>
<ul>
<li><p>挂载流程</p>
</li>
<li><p>更新&amp;销毁流程</p>
</li>
</ul>
<img src="/2021/06/18/16.Vue2%E7%AC%94%E8%AE%B0/2.jpg" style="zoom:67%;">

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>分析生命周期<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 准备好一个容器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;h2&quot;</span>&gt;</span>当前页面求和为：&#123;&#123;sum&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点我+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;death&quot;</span>&gt;</span>销毁<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">//修改Vue的全局配置</span></span></span><br><span class="line"><span class="javascript">    Vue.config.productionTip = <span class="literal">false</span> <span class="comment">//关闭生产提示</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">sum</span>: <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&#x27;你点了+按钮&#x27;</span>);</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.sum += <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">death</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$destroy();</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例数据代理前</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--beforeCreate--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.sum); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.add); <span class="comment">//undefined</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例数据代理完毕</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--created--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.sum); <span class="comment">// 0</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.add); <span class="comment">// function</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例更新真实DOM之前(挂载前)</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--beforeMount--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        btn.innerText = <span class="string">&#x27;Hello&#x27;</span>; <span class="comment">// 最终对DOM的操作无效</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> h2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;h2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(h2);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例更新完真实DOM了(挂载完毕)</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--mounted--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> h2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;h2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        btn.innerText = <span class="string">&#x27;Hello&#x27;</span>; <span class="comment">// 最终对DOM的操作有效</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(h2)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(btn);</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例将要更新页面</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--beforeUpdate--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.sum); <span class="comment">// sum为1，页面上为0</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例完成更新页面</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--updated--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.sum) <span class="comment">// sum为1，页面上也为1</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// debugger;</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例销毁前</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--beforeDestroy--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.sum); <span class="comment">//可以获取</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.add); <span class="comment">//可以获取</span></span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="comment">//vue实例销毁完毕</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;--destroyed--&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;移除完毕了所有数据的监视，不会再更新页面了&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="过渡和动画"><a href="#过渡和动画" class="headerlink" title="过渡和动画"></a>过渡和动画</h3><h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4><p>步骤：</p>
<ol>
<li>在目标元素外包裹<code>&lt;transition name=&quot;xxx&quot;&gt;</code></li>
<li>编写样式：<ul>
<li>进入：<ul>
<li>进入起始点：xxx-enter</li>
<li>进入过程中：xxx-enter-active</li>
<li>进入结束点：xxx-enter-to</li>
</ul>
</li>
<li>离开：<ul>
<li>离开起始点：xxx-leave</li>
<li>离开过程中：xxx-leave-active</li>
<li>离开结束点：xxx-leave-to</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.picture</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/*离开的起点，即进入的终点*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-leave-to</span>, <span class="selector-class">.demo-enter</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">opacity</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>) <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="comment">/*离开的终点，即进入的起点*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-leave-to</span>, <span class="selector-class">.demo-enter</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">opacity</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.2</span>) <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-leave-active</span>, <span class="selector-class">.demo-enter-active</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">transition</span>: <span class="number">1s</span> all;</span></span><br><span class="line"><span class="css">        <span class="comment">/*如果离开时和进入时的transition时间不一样，就得分开写*/</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">class</span>=<span class="string">&quot;picture&quot;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果是多个元素的过渡，使用<code>&lt;transition-group&gt;</code>，key值必写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;!isShow&quot;</span> <span class="attr">key</span>=<span class="string">&quot;...&quot;</span>&gt;</span>元素1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">key</span>=<span class="string">&quot;...&quot;</span>&gt;</span>元素2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>和过渡类似：</p>
<ol>
<li>基本编码<ul>
<li>在目标元素外包裹<code>&lt;transition name=&quot;xxx&quot;&gt;</code></li>
<li>编写：进入动画、离开动画的样式</li>
</ul>
</li>
<li>类名规范：<ul>
<li>进入动画样式：xxx-enter-active</li>
<li>离开动画样式：xxx-leave-active</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.picture</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    </span></span><br><span class="line"><span class="css">    <span class="comment">/*reverse表示动画反向播放*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-enter-active</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">animation</span>: test <span class="number">1s</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo-leave-active</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">animation</span>: test <span class="number">1s</span> reverse;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    </span></span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> test&#123;</span></span><br><span class="line"><span class="css">        ...</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">class</span>=<span class="string">&quot;picture&quot;</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><blockquote>
<p>Vue2只有全局过滤器，它可以影响多个Vue实例</p>
</blockquote>
<p>现有需求：将时间戳转化成格式化的时间，使用第三方库<code>moment.js</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/moment.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>显示格式化后的时间<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤器的固定语法 ↓ --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;time | dateFormater&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;time | dateFormater(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&#x27;YYYY-MM-DD HH:mm:ss&#x27;是moment.js要求传入的参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 当有任何日期想要格式化时，就可以调用dateFormater</span></span></span><br><span class="line"><span class="javascript">    Vue.filter(<span class="string">&#x27;dateFormater&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, str=<span class="string">&#x27;YYYY-MM-DD&#x27;</span></span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="comment">// value是要进行格式化的时间戳，str是dateFormater的参数，如果不传参，str为默认值</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> moment(value).format(str);  <span class="comment">// moment由moment.js提供</span></span></span><br><span class="line"><span class="javascript">    &#125;) </span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#root&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">time</span>: <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>分为：全局指令和局部指令，全局指令可以在多个vm中使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-upper-text</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>全局指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;upper-text&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>)</span>&#123; <span class="comment">// 不需写 v-</span></span><br><span class="line">    <span class="comment">// 该指令的作用是：将字符变为大写</span></span><br><span class="line">    el.innerText = binding.value.toUpperCase();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#root&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: danmosama</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>局部指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#root&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>: danmosama</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">directives</span>:&#123;</span><br><span class="line">        <span class="string">&#x27;upper-text&#x27;</span>(el, binding)&#123;  <span class="comment">// 此处为简写</span></span><br><span class="line">            el.innerText = binding.value.toUpperCase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>感性认识：插件是一个添加指令、属性…的集合</p>
<p>先创建一个plugin.js文件，作为插件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插件的定义：是一个包含install方法的对象</span></span><br><span class="line"><span class="keyword">let</span> plugin = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">plugin.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, options</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加一个全局指令</span></span><br><span class="line">    Vue.directive(<span class="string">&#x27;upper-text&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">      el.innerText = binding.value.toUpperCase();</span><br><span class="line">  &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给Vue自身添加属性和方法</span></span><br><span class="line">    Vue.proName = <span class="string">&#x27;管理系统&#x27;</span>;</span><br><span class="line">    Vue.version = <span class="string">&#x27;V1.0.1&#x27;</span>;</span><br><span class="line">    Vue.showInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Some info&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给Vue原型上添加数据，供vm使用</span></span><br><span class="line">    Vue.prototype.$method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;This method is prepared for vm&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再调用该插件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;plugin.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">// Vue会帮我们调用插件里的install方法</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    Vue.use(<span class="string">&#x27;plugin&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 其他操作（包括创建vm），可以console.log插件添加的属性，使用插件的方法等</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="组件和脚手架"><a href="#组件和脚手架" class="headerlink" title="组件和脚手架"></a>组件和脚手架</h2><h3 id="非单文件"><a href="#非单文件" class="headerlink" title="非单文件"></a>非单文件</h3><p>在真正开发中，不使用非单文件，它仅用于教学和理解原理，单文件的笔记结合了脚手架</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>组件：包含页面局部功能的代码和资源的集合，规范要求组件的首字母大写</p>
<p>组件使用的基本流程：</p>
<ul>
<li>定义组件</li>
<li>注册组件<ul>
<li>全局注册：Vue.component(‘组件名, 组件’)</li>
<li>局部注册</li>
</ul>
</li>
<li>写组件标签</li>
</ul>
<p>定义组件：</p>
<ol>
<li><p>定义方式：使用Vue.extend(options)创建</p>
</li>
<li><p>School的本质是一个构造函数，以后写<code>&lt;School/&gt;</code>，Vue帮我们去new School</p>
</li>
<li><p>options参数是配置对象，它几乎和new Vue时的options一样，区别如下：</p>
<ul>
<li><p>不能写el指定容器：</p>
<pre><code>原因：所有组件实例最终要被一个vm所管理，vm中会指定好el
</code></pre>
</li>
<li><p>data必须写成函数</p>
<pre><code>原因：确保多个组件中的数据互不干扰（如果写成对象，考虑引用数据类型的特性，修改一个vm的data会影响另一个）
</code></pre>
</li>
<li><p>组件的模板结构要配置在template属性中：</p>
<ul>
<li>值为html字符串，推荐模板字符串</li>
<li>模板的结构<strong>必须只有一个根标签</strong>（在外边套div）</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root1&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以写开始标签和结束标签，也可以写自结束标签--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--此处并非标准写法，一般最外边是app标签--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">School</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">School</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> School = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span>,</span></span><br><span class="line"><span class="javascript">                <span class="attr">address</span>: <span class="string">&#x27;北京&#x27;</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">template</span>:<span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;h2&gt;学校名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">      &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">    `</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 全局注册</span></span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;School&#x27;</span>, School); </span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义vm，去管理所有的组件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#root1&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&quot;#root2&quot;</span></span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 演示局部注册</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#root&quot;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        School <span class="comment">// 触发简写形式，School:School可以直接写School</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="VueComponent的原理"><a href="#VueComponent的原理" class="headerlink" title="VueComponent的原理"></a>VueComponent的原理</h4><p><code>VueComponent</code>继承了Vue，所以Vue.prototype上的属性和方法，vc都能看见</p>
<p>接上节例，我们说School是一个构造函数，如果console.log(new School())，输出在控制台的不是 <code>School ()</code>，而是 <code>VueComponent()</code>，由此分析出对应的原理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Vue = &#123;</span><br><span class="line">    <span class="function"><span class="title">extend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> VueComponent;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">const</span> School = Vue.extend(&#123;...&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> School();</span><br><span class="line">    <span class="built_in">console</span>.log(s);  <span class="comment">// VueComponent()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件的data函数、以及methods中配置的函数中的this都是vc</p>
<h3 id="创建脚手架"><a href="#创建脚手架" class="headerlink" title="创建脚手架"></a>创建脚手架</h3><p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"></span><br><span class="line">vue create 项目名（英文）</span><br><span class="line"></span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<p>得到的项目结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git（自动执行了init、add、commit操作）</span><br><span class="line">node_modules</span><br><span class="line">public</span><br><span class="line">  favicon.co</span><br><span class="line">  index.html</span><br><span class="line">src</span><br><span class="line">  assets（可在此处配置静态资源）</span><br><span class="line">  components</span><br><span class="line">      HelloWorld.vue</span><br><span class="line">  App.vue</span><br><span class="line">  main.js</span><br><span class="line">  .gitignore</span><br><span class="line">  bable.config.js</span><br><span class="line">  package.json</span><br><span class="line">  README.md</span><br><span class="line">  yarn.lock</span><br><span class="line">index.html</span><br></pre></td></tr></table></figure>

<h3 id="分析脚手架"><a href="#分析脚手架" class="headerlink" title="分析脚手架"></a>分析脚手架</h3><h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br></pre></td></tr></table></figure>

<p>此处的title和package.json文件挂钩</p>
<h4 id="render与h函数"><a href="#render与h函数" class="headerlink" title="render与h函数"></a>render与h函数</h4><p>模板解析器：解析template</p>
<p>在<code>import Vue from &#39;vue&#39;</code>时，由于没有指定路径，根据package.json，默认引入的是vue.runtime.common.js，该文件的优点是体积很小，但是不含模板解析器，此时默认情况下只能解析.vue文件中的模板，不能解析main.js中的模板</p>
<p>于是官方提供了render函数，它可以调用模板解析器，使得main.js中的模板可以被解析，并且有了render后，我们无需再在index.html中的div中写<code>&lt;app/&gt;</code></p>
<h3 id="单文件案例"><a href="#单文件案例" class="headerlink" title="单文件案例"></a>单文件案例</h3><p>Hello.vue：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 配置组件模板结构 */</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot;&gt;学校名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2 class=&quot;info&quot;&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;  </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">/* 配置组件数据、交互等 */</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 暴露组件配置，并没有创建组件(因为没有调用Vue.extend)</span><br><span class="line">  export default &#123;</span><br><span class="line">    // data中存放组件所需数据</span><br><span class="line">    data()&#123; </span><br><span class="line">      return &#123;</span><br><span class="line">        name:&#x27;DanmoSAMA&#x27;,</span><br><span class="line">        address:&#x27;湖北省-武汉市-洪山区-华中科技大学&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;  </span><br><span class="line"></span><br><span class="line">/* 配置组件样式 */</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .title&#123;</span><br><span class="line">    color: orange;</span><br><span class="line">  &#125;</span><br><span class="line">  .info&#123;</span><br><span class="line">    color: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>App.vue：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 配置组件的结构 */</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2 class=&quot;like&quot;&gt;我最喜欢的角色是：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;Hello/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">/* 配置组件数据、交互、事件等等*/</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 引入Hello组件</span><br><span class="line">  import Hello from &#x27;./components/Hello&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &#x27;Soryuu Kaminogi&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;Hello&#125;,  // 注册组件</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .like&#123;</span><br><span class="line">    color: green;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>main.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> <span class="comment">// 通过ES6模块化语法引入vue</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.html：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>minxin（混入）：</p>
<ul>
<li><p>功能：把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用：如下</p>
</li>
<li><p>原则：如果混合中的属性和方法与组件中data和methods有冲突，组件优先；如果是生命周期钩子有冲突，则同时应用</p>
</li>
</ul>
<p>定义混合：</p>
<p>mixin.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mixin&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">public</span>:<span class="string">&#x27;public data&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="built_in">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入混合：</p>
<ul>
<li><p>局部引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mixin&#125; <span class="keyword">from</span> <span class="string">&#x27;../mixin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;淡漠&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">19</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mixins</span>:[mixin]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>全局引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mixin&#125; <span class="keyword">from</span> <span class="string">&#x27;../mixin&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用到所有vm和vc上</span></span><br><span class="line">Vue.mixin(mixin);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><p><code>scope</code>写在style标签里，作用：让样式在局部生效，防止冲突</p>
<p>但是，App组件里定义的样式一般用于所有的组件，因此App组件的style标签不写scope</p>
<h3 id="书写less"><a href="#书写less" class="headerlink" title="书写less"></a>书写less</h3><p>如果要在style中写less：</p>
<ul>
<li>lang=”less”</li>
<li>下载less-loader，不能下载最新版本，因为新版本用webpack5：<ul>
<li><code>npm view less-loader versions</code>查看版本</li>
<li><code>npm i less-loader@7</code>下载7.3版本的less-loader</li>
</ul>
</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote>
<p><code>ref</code>被用来给元素或子组件注册引用（reference）信息。引用信息将会注册在父组件的<code>$refs</code>对象上。如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例。</p>
</blockquote>
<p>ref的使用：</p>
<ul>
<li>标签中直接编写 <code>ref=&quot;xxx&quot;</code></li>
<li>通过<code>this.$refs.xxx</code>获取</li>
<li>备注：<ul>
<li>若给html内置标签打ref，则获取到的是真实DOM结点</li>
<li>若给组件标签打ref，则获取到的是组件实例对象vc</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;button ref=&quot;btn&quot; @click=&quot;showData&quot;&gt;</span><br><span class="line">          点我获取焦点</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;input type=&quot;text&quot; ref=&quot;keyWord&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;School ref=&quot;xuexiao&quot;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import School from &#x27;./components/School&#x27;</span><br><span class="line">    </span><br><span class="line">    export default&#123;</span><br><span class="line">    components:&#123;School&#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            showData()&#123;</span><br><span class="line">                console.log(this.$refs.btn.innerText);</span><br><span class="line">                this.$refs.keyWord.focus();     // 获取input的焦点</span><br><span class="line">                console.log(this.$refs.xuexiao); // vc</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>props是properties的简称，它可以限制类型、控制必要性和指定默认值等，<strong>一般用于父组件向子组件传递数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;h2 class=&quot;name&quot;&gt;学校名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;h2 class=&quot;address&quot;&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;h4&gt;接收到的名字是&#123;&#123;username&#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                name: &#x27;尚硅谷&#x27;,</span><br><span class="line">                address: &#x27;北京&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        props:&#123;</span><br><span class="line">            userName:&#123;            // 此处不能和data中的属性名重复，因为它也会成为vc的一个属性</span><br><span class="line">                type: String,        // 类型</span><br><span class="line">                required: true,      // 必要性</span><br><span class="line">                default: &#x27;DanmoSAMA&#x27; // 默认值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果在School.vue里这样写了，则它的外壳App.vue必须绑定userName属性，否则会在控制台警告，并将默认值填入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;!--此处必须绑定userName属性--&gt;</span><br><span class="line">      &lt;School :userName=&quot;userName&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import School form &#x27;./components/School&#x27;</span><br><span class="line">    </span><br><span class="line">    export default &#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                userName: &#x27;淡漠&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;School&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>以上为完整写法，精简写法（更常用）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 次完整写法</span><br><span class="line">props:&#123;</span><br><span class="line">  userName:String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 最精简写法</span><br><span class="line">props:[&#x27;userName&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="组件自定义事件"><a href="#组件自定义事件" class="headerlink" title="组件自定义事件"></a>组件自定义事件</h3><ol>
<li><p><code>组件自定义事件</code>是一种组件间通信的方式，适用于<strong>子组件=&gt;父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件，事件的回调在A中（<strong>回调在父组件中</strong>）</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>方法一：在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>或<code>&lt;Demo v-on:atguigu=&quot;test&quot;&gt;</code></p>
</li>
<li><p>方法二：在父组件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Demo ref=&quot;demo&quot;/&gt;</span><br><span class="line">  ...</span><br><span class="line">  mounted()&#123;</span><br><span class="line">    this.$refs.xxx.$on(&#x27;atguigu&#x27;, this.test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>若想让自定义事件只能触发一次，可以用<code>once</code>修饰符或<code>$once</code>方法</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;, 数据)</code></p>
</li>
<li><p>解绑自定义事件：<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上绑定原生DOM事件：使用<code>native</code>修饰符</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;, 回调)</code>绑定自定义事件时，回调<strong>要么配置在methods中，要么用箭头函数</strong>，否则this指向会出问题</p>
</li>
</ol>
<h3 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h3><p>可以实现任意组件间的通信。</p>
<p>在main.js中安装全局事件总线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Vue.prototype.$bus = <span class="built_in">this</span> <span class="comment">//安装全局事件总线</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（此处原理暂不深究，先记住这种方法）</p>
<p><code>$bus</code>是一个东西，它不属于任何组件，A、B是兄弟组件，当A想收到数据时，在A组件里给<code>$bus</code>绑定一个自定义事件demo，此时demo的回调就留在A组件里。B想给A传数据时，触发<code>$bus</code>上的demo自定义事件，并带一些数据过去，则<code>$bus</code>上的demo事件被触发后，触发A中的回调，就把数据带过去了。</p>
<h3 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h3><p>pubsub-js是一个库，在vue中更推荐使用全局事件总线方式</p>
<ol>
<li><p>一种组件间通信的方式，适用于<strong>任意组件间通信</strong></p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入：<code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">methods()&#123;</span><br><span class="line">  demo(data)&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">mounted()&#123;</span><br><span class="line">  this.pid = pubsub.subscribe(&#x27;xxx&#x27;, this.demo);  // 订阅消息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>应在beforeDestory钩子中，用<code>pubsub.unsubsribe(pid)</code>去取消订阅</p>
</li>
</ol>
</li>
</ol>
<h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>场景：前端的端口号为8080，服务器的端口号为5000，前端向服务器发送Ajax请求时存在跨域问题，导致前端拿不到服务器返回的数据，故需要配置代理，前端请求代理，代理请求服务器（代理服务器的端口和前端相同，由于同源策略是Ajax的，服务器之间不存在跨域问题，便可以从8080端口的服务器拿到数据）</p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>在vue.config.js中添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">    <span class="attr">proxy</span>: <span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可</li>
<li>缺点：不能配置多个代理，不能灵活控制请求是否走代理</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，才会把该请求转发给服务器（优先匹配前端资源）</li>
</ol>
<h4 id="方法二（推荐）"><a href="#方法二（推荐）" class="headerlink" title="方法二（推荐）"></a>方法二（推荐）</h4><p>编写vue.config.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">pages</span>: &#123;</span><br><span class="line">    <span class="attr">index</span>: &#123;</span><br><span class="line">      <span class="comment">//入口</span></span><br><span class="line">      <span class="attr">entry</span>: <span class="string">&#x27;src/main.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">lintOnSave</span>:<span class="literal">false</span>, <span class="comment">//关闭语法检查</span></span><br><span class="line">  <span class="comment">//开启代理服务器（方式二）</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/atguigu&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">        <span class="comment">// 前端向代理请求时要加/atguigu，代理向服务器请求时会去掉/atguigu</span></span><br><span class="line">    <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/atguigu&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment">// ws: true, //用于支持websocket</span></span><br><span class="line">        <span class="comment">// changeOrigin: true //用于控制请求头中的host值</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/demo&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">    <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/demo&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">        <span class="comment">// ws: true,</span></span><br><span class="line">        <span class="comment">// changeOrigin: true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>作用：让父组件可以向子组件指定位置插入HTML结构，也是一种组件间通信的方式，适用于<strong>父组件=&gt;子组件</strong></p>
<h4 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">    &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;!--定义插槽--&gt;</span><br><span class="line">        &lt;slot&gt;插槽默认内容&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>template标签的好处是不会被解析到页面上，<code>slot</code>和<code>v-slot</code>属性都只能写在template标签上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">    &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">        &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;template v-slot:footer&gt;</span><br><span class="line">        &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;!--定义插槽--&gt;</span><br><span class="line">        &lt;slot name=&quot;center&quot;&gt;插槽默认内容&lt;/slot&gt;</span><br><span class="line">        &lt;slot name=&quot;footer&quot;&gt;插槽默认内容&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">    &lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">        &lt;!--生成的是ul列表--&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">            &lt;li v-for=&quot;game in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">    &lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">        &lt;!--生成的是h4标题--&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">            &lt;h4 v-for=&quot;game in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;game&#125;&#125;&lt;/h4&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">        &lt;!--定义插槽--&gt;</span><br><span class="line">        &lt;slot :games=&quot;games&quot;&gt;插槽默认内容&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default&#123;</span><br><span class="line">        name:&#x27;Category&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                games: [&#x27;game1&#x27;, &#x27;game2&#x27;, &#x27;game3&#x27;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol>
<li><p>概念：</p>
<p>在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进入集中式管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信</p>
</li>
<li><p>何时使用：多个组件需要<strong>共享</strong>数据时</p>
</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="/2021/06/18/16.Vue2%E7%AC%94%E8%AE%B0/3.png" style="zoom: 40%;">

<p>vuex由<code>Actions</code>、<code>Mutations</code>、<code>State</code>组成，这三者被<code>Store</code>管理着</p>
<ul>
<li>vc向Actions传动作和数据，Actions把它们交给Mutations，由它执行并更改State，渲染后影响vc（页面）</li>
<li>如果不进行发ajax等操作，vc可以直接调用commit，跳过Actions</li>
<li>类比：vc是客人，Actions是服务员，Mutations是后厨，State是做好的菜；dispatch即客人告诉服务员需求，commit即服务员把需求告诉后厨，mutate即后厨制作，render即把菜传给客人</li>
</ul>
<h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><blockquote>
<p>npm i vuex</p>
</blockquote>
<ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 应用Vuex插件</span></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备actions对象，响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;;</span><br><span class="line"><span class="comment">// 准备mutations对象，修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;;</span><br><span class="line"><span class="comment">// 准备state对象，保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在main.js中创建vm时传入store配置项</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">// 引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建vm</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">    store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​      </p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li><p>初始化数据，配置<code>actions</code>、<code>mutations</code>，操作文件<code>index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">// 响应组件中加的动作</span></span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">context, value</span>)</span>&#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;ADD&#x27;</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">// 执行加</span></span><br><span class="line">    <span class="function"><span class="title">ADD</span>(<span class="params">state, value</span>)</span>&#123;</span><br><span class="line">        state.sum += value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">sum</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    statesj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;actions中的方法名&#39;, 数据)</code>或<code>$store.commit(&#39;mutations中的方法名&#39;, 数据)</code></p>
</li>
</ol>
<blockquote>
<p>若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit</p>
</blockquote>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    <span class="function"><span class="title">bigSum</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.sum * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  ......</span><br><span class="line">    getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h3><blockquote>
<p>map方法不是必需的，它们可以对代码作出一些优化</p>
</blockquote>
<ol>
<li><p>mapState方法：用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">// 借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">    ...mapState(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>, <span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>, <span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">    <span class="comment">// 借助mapState生成计算属性：sum、school、subject（数组写法）    </span></span><br><span class="line">    ...mapState([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;school&#x27;</span>, <span class="string">&#x27;subject&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mapGetters方法：用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    <span class="comment">// 借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...mapState(&#123;<span class="attr">bigSum</span>: <span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line">    <span class="comment">// 借助mapGetters生成计算属性：bigSum（数组写法）    </span></span><br><span class="line">    ...mapState([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mapActions方法：用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">// 靠mapActions生成、increamentOdd、increamentWait（对象形式）</span></span><br><span class="line">    ...mapActions(&#123;<span class="attr">increamentOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>, <span class="attr">increamentWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;),</span><br><span class="line">    <span class="comment">// 靠mapActions生成、increamentOdd、increamentWait（数组形式）</span></span><br><span class="line">    ...mapActions([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mapMutatios方法：用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">// 靠mapActions生成、increamentOdd、increamentWait（对象形式）</span></span><br><span class="line">    ...mapMutations(&#123;<span class="attr">increamentOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>, <span class="attr">increamentWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;),</span><br><span class="line">    <span class="comment">// 靠mapActions生成、increamentOdd、increamentWait（数组形式）</span></span><br><span class="line">    ...mapMutations([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><ol>
<li>定义：是vue的一个插件库，专门实现SPA应用（单页Web应用）</li>
<li>路由：<ul>
<li>一个路由就是一组映射关系（key - value），key为路径，value为function或component</li>
<li>路由分为前端路由（浏览器路径改变时改变显示的组件）和后端路由</li>
</ul>
</li>
</ol>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li><p>安装：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>: About</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></li>
<li><p>实现切换（active-class可配置高亮样式）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>指定展示位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="几个注意点"><a href="#几个注意点" class="headerlink" title="几个注意点"></a>几个注意点</h4><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储自己的路由信息</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到</li>
</ol>
<h3 id="多级路由"><a href="#多级路由" class="headerlink" title="多级路由"></a>多级路由</h3><ol>
<li><p>配置路由规则：使用children配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: Home,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>,  <span class="comment">// 此处不要写&#x27;/&#x27;</span></span><br><span class="line">                <span class="attr">component</span>: News</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: Message</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>跳转（写完整路径）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h3><ol>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--跳转并携带query参数，to的字符串写法--&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--跳转并携带query参数，to的对象写法--&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">    :to=&quot;&#123;</span><br><span class="line">         path: &#x27;/home/message/detail&#x27;,</span><br><span class="line">         query:&#123;</span><br><span class="line">         id: 666,</span><br><span class="line">           title: &#x27;你好&#x27;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;&quot;         </span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.query.id</span><br><span class="line">$route.query.title</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转</p>
</li>
<li><p>使用：</p>
<ol>
<li><p>给路由命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: Demo,</span><br><span class="line">            <span class="attr">children</span>:[</span><br><span class="line">                name: <span class="string">&#x27;hello&#x27;</span>,  <span class="comment">// 命名</span></span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: Hello</span><br><span class="line">            ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>简化跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前--&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">&lt;!--简化后--&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">&lt;!--简化配合传递参数--&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">    :to=&quot;&#123;</span><br><span class="line">         name: &#x27;hello&#x27;,</span><br><span class="line">         query:&#123;</span><br><span class="line">         id: 666,</span><br><span class="line">           title: &#x27;你好&#x27;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;&quot;         </span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><p>params参数不带<code>a=b&amp;c=d</code>的形式，用<code>/</code>分隔</p>
<ol>
<li><p>配置路由，声明接收params参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;detail/:id/:title&#x27;</span> <span class="comment">// 使用占位符声明接收params参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>传递参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">&lt;!--简化配合传递参数--&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">    :to=&quot;&#123;</span><br><span class="line">         name: &#x27;hello&#x27;,</span><br><span class="line">         params:&#123;</span><br><span class="line">         id: 666,</span><br><span class="line">           title: &#x27;你好&#x27;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;&quot;         </span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>接收参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$route.params.id</span><br><span class="line">$route.params.title</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h3><p>作用：让路由组件更方便地收到参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// props值为对象几乎不用</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 写法一：props值为布尔值，为true时把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">    <span class="attr">props</span>: <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 写法二：props值为函数，该函数返回的对象中，每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">    <span class="function"><span class="title">props</span>(<span class="params">route</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            <span class="attr">id</span>: route.query.id,</span><br><span class="line">            <span class="attr">title</span>: route.query.title</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="replace属性"><a href="#replace属性" class="headerlink" title="replace属性"></a>replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：<code>push</code>和<code>replace</code>，前者追加历史记录，后者替换当前记录，默认为<code>push</code></li>
<li>开启replace模式：：<code>&lt;router-link replace ...&gt;&lt;/router-link&gt;</code></li>
</ol>
<h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt;</code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $router的两个API</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>: xxx,</span><br><span class="line">        <span class="attr">title</span>: xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$router.replace(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>: xxx,</span><br><span class="line">        <span class="attr">title</span>: xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$router.forward() <span class="comment">// 前进</span></span><br><span class="line"><span class="built_in">this</span>.$router.back()  <span class="comment">// 后退</span></span><br><span class="line"><span class="built_in">this</span>.$router.go() <span class="comment">// 可前进也可后退，传入一个正负数作为参数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁</p>
</li>
<li><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"></span><br><span class="line">&lt;keep-alive :include=&quot;[&#x27;News&#x27;, &#x27;Message&#x27;]&quot;&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="路由生命周期钩子"><a href="#路由生命周期钩子" class="headerlink" title="路由生命周期钩子"></a>路由生命周期钩子</h3><p>捕获路由组件的激活状态：</p>
<ol>
<li><code>activated</code>：路由组件被激活时触发</li>
<li><code>deactived</code>：路由组件失活时触发</li>
</ol>
<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>作用：对路由进行权限控制</p>
<p><code>meta</code>中可以存一些程序员想要保存的数据</p>
<h4 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置路由守卫————初始化的时候被调用、每次路由切换之前被调用</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;前置路由守卫&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">  <span class="keyword">if</span>(to.meta.isAuth)&#123; <span class="comment">//判断是否需要鉴权</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>)===<span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      alert(<span class="string">&#x27;学校名错误，无权限查看！&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用</span></span><br><span class="line">router.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;后置路由守卫&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title || <span class="string">&#x27;硅谷系统&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="独享守卫"><a href="#独享守卫" class="headerlink" title="独享守卫"></a>独享守卫</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>:News,</span><br><span class="line">  <span class="attr">meta</span>:&#123;<span class="attr">isAuth</span>:<span class="literal">true</span>,<span class="attr">title</span>:<span class="string">&#x27;新闻&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;独享路由守卫&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">    <span class="keyword">if</span>(to.meta.isAuth)&#123; <span class="comment">//判断当前路由是否需要鉴权</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>)===<span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;学校名不对，无权限查看！&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组件内守卫"><a href="#组件内守卫" class="headerlink" title="组件内守卫"></a>组件内守卫</h4><p>注意事项：</p>
<ul>
<li>不要把离开守卫理解成后置守卫</li>
<li>“通过路由规则”：如果一上来组件就展示，不会触发</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进入守卫，通过路由规则，进入该组件时被调用</span></span><br><span class="line"><span class="function"><span class="title">beforeRouterEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 离开守卫，通过路由规则，离开时该组件时被调用</span></span><br><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两种工作模式"><a href="#两种工作模式" class="headerlink" title="两种工作模式"></a>两种工作模式</h3><ol>
<li>url的hash：#及其后面的内容</li>
<li>hash值不会包含在HTTP请求中，即：hash值不会带给服务器</li>
<li>hash模式：<ol>
<li>地址中永远带着#号，不美观</li>
<li>若以后将地址通过第三方手机App分享，若App校验严格，则地址会被标记为不合法</li>
<li>兼容性较好</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址美观</li>
<li>兼容性略差</li>
<li>应用部署上线时需要后端支持，解决刷新页面服务端404的问题</li>
</ol>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="关闭生产提示"><a href="#关闭生产提示" class="headerlink" title="关闭生产提示"></a>关闭生产提示</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><p>浏览器F12-&gt;Application可以查看本地存储</p>
<ol>
<li><p>存储内容大小一般支持5MB左右</p>
</li>
<li><p>浏览器端通过 <code>Window.sessionStorage</code>和 <code>Window.localStorage</code>属性实现本地存储</p>
</li>
<li><p>API：</p>
<ol>
<li><p><code>xxxStorage.setItem(&#39;key&#39;, &#39;value&#39;)</code></p>
<p>将键值对添加到存储中，如果键名存在，则更新其对应值</p>
<p>如果value不是字符串则浏览器会使用<code>toString()</code>转换，如果传对象，这样会破坏其内部结构</p>
<p>使用<code>JSON.stringify()</code>，将其转换为字符串同时不破坏内部结构</p>
</li>
<li><p><code>xxxStorage.getItem(&#39;key&#39;)</code></p>
<p>返回键名对应的值，不存在则返回null</p>
<p>获取对象时，使用<code>JSON.parse()</code></p>
</li>
<li><p><code>xxxStorage.getItem(&#39;key&#39;)</code></p>
<p>删除该键名和键值</p>
</li>
<li><p><code>xxxStorage.getItem(&#39;key&#39;)</code></p>
<p>清空存储中的所有数据</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容随着浏览器窗口关闭而消失</li>
<li>LocalStorage存储的内容需要手动清除（调API或清空缓存）</li>
<li><code>JSON.parse(null)</code>的结果是null</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>web开发</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS高级+ES6笔记</title>
    <url>/2021/08/22/30.JS%E9%AB%98%E7%BA%A7+ES6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础总结深入"><a href="#基础总结深入" class="headerlink" title="基础总结深入"></a>基础总结深入</h1><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li><p>Object: 任意对象</p>
</li>
<li><p>Function: 一种特别的对象(可以执行)</p>
</li>
<li><p>Array: 一种特别的对象(数值下标，内部数据是有序的)</p>
<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><p>三种方法判断数据类型：typeof、instanceof、===</p>
</li>
<li><p>typeof:<br>可以判断: undefined/ 数值 / 字符串 / 布尔值 / function</p>
</li>
<li><p><em>不能判断: null与object  object与array</em>*</p>
</li>
<li><p>instanceof:<br>判断对象的具体类型</p>
</li>
<li><p>===<br>可以判断: undefined, null</p>
</li>
</ul>
<blockquote>
<p>typeof的返回值是一个字符串，如果要检查一个变量a是不是undefined，要用typeof判断，应该写console.log(typeof(a) === ‘undefined’)<br>typeof(null)的值是object，因此如果要检查一个变量是不是null，只能用===</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = &#123;</span><br><span class="line">    <span class="attr">b2</span>: [<span class="number">1</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="built_in">console</span>.log],</span><br><span class="line">    <span class="attr">b3</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;b3&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;xfzhang&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>, b1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true  false</span></span><br><span class="line">  <span class="built_in">console</span>.log(b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>, b1.b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true true</span></span><br><span class="line">  <span class="built_in">console</span>.log(b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Function</span>, b1.b3 <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b3===<span class="string">&#x27;function&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1.b2[<span class="number">2</span>]===<span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">  b1.b2[<span class="number">2</span>](<span class="number">4</span>)  <span class="comment">//调用函数演示</span></span><br><span class="line">  <span class="built_in">console</span>.log(b1.b3()())  <span class="comment">//调用函数演示</span></span><br></pre></td></tr></table></figure>


<h2 id="undefined与null"><a href="#undefined与null" class="headerlink" title="undefined与null"></a>undefined与null</h2><p>区别：</p>
<ul>
<li>undefined代表定义未赋值</li>
<li>null定义并赋值了, 只是值为null</li>
</ul>
<p>什么时候给变量赋值为null：</p>
<ul>
<li>初始赋值, 表明将要赋值为对象</li>
<li>结束前, 让对象成为垃圾对象(被垃圾回收器回收)</li>
</ul>
<h2 id="内存、数据、变量"><a href="#内存、数据、变量" class="headerlink" title="内存、数据、变量"></a>内存、数据、变量</h2><p>内存：</p>
<ul>
<li>内存条通电后产生的可储存数据的空间</li>
<li>产生和死亡: 内存条(电路板)-&gt;通电-&gt;产生内存空间-&gt;存储数据-&gt;处理数据-&gt;断电-&gt;内存空间和数据都消失</li>
<li>存放的数据：内部存储的数据、地址值</li>
<li>分类：栈: 全局变量/局部变量；堆: 对象</li>
</ul>
<p>变量：</p>
<ul>
<li>可变化的量, 由变量名和变量值组成</li>
<li>每个变量都对应的一块小内存, 变量名用来查找对应的内存, 变量值就是内存中保存的数据</li>
</ul>
<p>内存,数据, 变量三者之间的关系：</p>
<ul>
<li>内存用来存储数据的空间</li>
<li>变量是内存的标识</li>
</ul>
<h2 id="JS引擎管理内存的方式"><a href="#JS引擎管理内存的方式" class="headerlink" title="JS引擎管理内存的方式"></a>JS引擎管理内存的方式</h2><p>内存生命周期</p>
<ul>
<li>分配小内存空间, 得到它的使用权</li>
<li>存储数据, 可以反复进行操作</li>
<li>释放小内存空间</li>
</ul>
<p>释放内存</p>
<ul>
<li>局部变量: 函数执行完自动释放</li>
<li>对象: 赋值null成为垃圾对象-&gt;垃圾回收器回收</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="必须使用-‘属性名’-的情况"><a href="#必须使用-‘属性名’-的情况" class="headerlink" title="必须使用[‘属性名’]的情况"></a>必须使用[‘属性名’]的情况</h2><ol>
<li>属性名包含特殊字符: - 空格</li>
<li>属性名不确定</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一</span></span><br><span class="line">  p[<span class="string">&#x27;content-type&#x27;</span>] = <span class="string">&#x27;text/json&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(p[<span class="string">&#x27;content-type&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二</span></span><br><span class="line">  <span class="keyword">var</span> propName = <span class="string">&#x27;myAge&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  p[propName] = value</span><br><span class="line">  <span class="built_in">console</span>.log(p[propName])</span><br></pre></td></tr></table></figure>
<h2 id="对象字面量和构造函数"><a href="#对象字面量和构造函数" class="headerlink" title="对象字面量和构造函数"></a>对象字面量和构造函数</h2><p>var obj = {} 等价于 var obj = new Object()，<br>所以用对象字面量创建的对象，是Object函数的实例，</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>call和apply在JS基础上已经记过笔记</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><ol>
<li>回调函数满足：</li>
</ol>
<ul>
<li>自己定义</li>
<li>没有立即调用</li>
<li>最终它在某个时刻或某个条件下执行了</li>
</ul>
<ol start="2">
<li>常见的回调函数</li>
</ol>
<ul>
<li>dom事件回调函数 -&gt;发生事件的dom元素</li>
<li>定时器回调函数 -&gt;window</li>
<li>ajax请求回调函数(后面讲)</li>
<li>生命周期回调函数(后面讲)</li>
</ul>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="博客-自我总结"><a href="#博客-自我总结" class="headerlink" title="博客/自我总结"></a>博客/自我总结</h2><p>可以参考以下三篇博客：<br><a href="https://blog.csdn.net/u014465934/article/details/84836731?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161060666816780269868727%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161060666816780269868727&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84836731.first_rank_v2_pc_rank_v29&utm_term=object%E5%8E%9F%E5%9E%8B">JavaScript中Function和Object的原型和原型链</a></p>
<p><a href="https://blog.csdn.net/weixin_43168306/article/details/100804505?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161060666816780269868727%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161060666816780269868727&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-100804505.first_rank_v2_pc_rank_v29&utm_term=object%E5%8E%9F%E5%9E%8B">JS中 Object.prototype 原型和原型链 详解</a></p>
<p><a href="https://blog.csdn.net/lc237423551/article/details/80010100?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161061019316780277034739%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161061019316780277034739&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80010100.first_rank_v2_pc_rank_v29&utm_term=proto%E5%92%8Cprototype%E5%8C%BA%E5%88%AB">彻底理解什么是原型链，prototype和__proto__的区别（最清晰）</a></p>
<p>自己总结一下：</p>
<ul>
<li>在函数对象中存在原型对象prototype，在普通对象中没有prototype，但存在__proto__，所有对象都有__proto__属性</li>
<li>function定义的对象有prototype属性，使用new生成的对象没有prototype属性，存在__proto__</li>
<li>特殊的是， Function.prototype没有prototype属性，在控制台输出undefined</li>
<li>如果认为普通对象A是对象B的实例，A的__proto__属性等价于B的prototype属性</li>
<li>Object.__proto__指向Function.prototype(HBuilder的控制台输出结果为function Empty() {})，但是Object.prototype.__proto__指向null</li>
</ul>
<p>prototype是函数对象自带的一个属性，比如console.log(Object.prototype)，控制台打印[object Object]；console.log(Function.prototype)，控制台打印function Empty() {}。给人的感觉是，打印 <strong>自己的“本质”</strong>。prototype后又可以继续访问它的__proto__属性，如console.log(Object.prototype.<strong>proto</strong>)，控制台打印null。</p>
<p>而__proto__是普通对象自带的一个属性，普通对象.__proto__即为函数对象.prototype。__proto__给人的感觉是，<strong>要追溯它的下一级</strong>，比如用构造函数得到的对象，它的__proto__就是new后边的函数，又比如Object其实是一个函数对象，那么console.log(Object.<strong>proto</strong>)会在控制台打印function Empty() {}，即它可等价为Function.prototype。</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)<br>原型对象中有一个属性constructor, 它指向函数对象</p>
<pre><code>console.log(Date.prototype.constructor===Date)  //true
console.log(Date.prototype.constructor)    //function Date() &#123; [native code] &#125;
</code></pre>
<p>关于construcor，可以看这篇博客：<br><a href="https://segmentfault.com/q/1010000000347868">javascript 对象中的 constructor属性的作用</a></p>
<h2 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h2><ol>
<li>每个函数function都有一个prototype，即显式原型(属性)</li>
<li>每个实例对象都有一个__proto__，可称为隐式原型(属性)</li>
<li>对象的隐式原型的值为其对应构造函数的显式原型的值</li>
<li>内存结构(图)</li>
<li>总结:</li>
</ol>
<ul>
<li>函数的prototype属性: 在定义函数时自动添加的, 默认值是一个空Object对象（该“空”指的是没有程序员指定的属性或方法，不是什么都没有）</li>
<li>对象的__proto__属性: 创建对象时自动添加的, 默认值为构造函数的prototype属性值</li>
<li>程序员能直接操作显式原型, 但不能直接操作隐式原型(ES6之前)</li>
</ul>
<p>内存结构图：<br><img src="https://img-blog.csdnimg.cn/2021011416495072.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMjM1NzM2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom: 67%;"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><img src="https://img-blog.csdnimg.cn/20210114172751177.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMjM1NzM2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" style="zoom:67%;">

<h1 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h1><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p> 代码分类(位置)</p>
<ul>
<li>全局代码</li>
<li>函数(局部)代码</li>
</ul>
<p> 全局执行上下文</p>
<ul>
<li>在执行全局代码前将window确定为全局执行上下文</li>
<li>对全局数据进行预处理</li>
<li>var定义的全局变量-&gt;undefined, 添加为window的属性</li>
<li>function声明的全局函数-&gt;赋值(fun), 添加为window的方法</li>
<li>this-&gt;赋值(window)</li>
<li>开始执行全局代码</li>
</ul>
<p>函数执行上下文</p>
<ul>
<li><strong>在调用函数, 准备执行函数体之前</strong>, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中)</li>
<li>对局部数据进行预处理</li>
<li>形参变量-&gt;赋值(实参)-&gt;添加为执行上下文的属性</li>
<li>arguments-&gt;赋值(实参列表), 添加为执行上下文的属性</li>
<li>var定义的局部变量-&gt;undefined, 添加为执行上下文的属性</li>
<li>function声明的函数 -&gt;赋值(fun), 添加为执行上下文的方法</li>
<li>this-&gt;赋值(调用函数的对象)</li>
<li>开始执行函数体代码</li>
</ul>
<p><strong>执行上下文对象个数=调用函数的次数+1（多出的1是window，即全局执行上下文）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">    foo(x + b);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a + c + y);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(<span class="number">10</span>);<span class="comment">//调用bar算一次，bar中还要调用foo再算一次，共2次</span></span><br><span class="line">  bar(<span class="number">10</span>);<span class="comment">//同理，共2次</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这一段代码中共4+1=5个执行上下文对象</p>
<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><img src="https://img-blog.csdnimg.cn/20210114230525811.jpg" width="40%" style="zoom: 33%;">

<ol>
<li>在全局代码执行前, JS引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文(window)确定后, 将其添加到栈中(压栈)</li>
<li>在函数执行上下文创建后, 将其添加到栈中(压栈)</li>
<li>在当前函数执行完后,将栈顶的对象移除(出栈)</li>
<li>当所有的代码执行完后, 栈中只剩下window</li>
</ol>
<blockquote>
<ol>
<li>依次输出什么?<br>gb: undefined<br>fb: 1<br>fb: 2<br>fb: 3<br>fe: 3<br>fe: 2<br>fe: 1<br>ge: 1</li>
<li>整个过程中产生了几个执行上下文?  5</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;gb: &#x27;</span>+ i);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">foo(<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fb:&#x27;</span> + i);</span><br><span class="line">  foo(i + <span class="number">1</span>) <span class="comment">//递归调用: 在函数内部调用自己</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fe:&#x27;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;ge: &#x27;</span> + i);</span><br></pre></td></tr></table></figure>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>理解</p>
<ul>
<li>多个上下级关系的作用域形成的链, 它的方向是从下向上的(从内到外)</li>
<li>查找变量时就是沿着作用域链来查找的</li>
</ul>
<p>查找一个变量的查找规则</p>
<ul>
<li>在当前作用域下的执行上下文中查找对应的属性, 如果有直接返回, 否则进入2</li>
<li>在上一级作用域的执行上下文中查找对应的属性, 如果有直接返回, 否则进入3</li>
<li>再次执行2的相同操作, 直到全局作用域, 如果还找不到就抛出找不到的异常<h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2>区别1</li>
<li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了，而不是在函数调用时</li>
<li>全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建</li>
<li>函数执行上下文是在调用函数时, 函数体代码执行之前创建</li>
</ul>
<p>区别2</p>
<ul>
<li>作用域是静态的, 只要函数定义好了就一直存在, 且不会再变化</li>
<li>执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放</li>
</ul>
<p>联系</p>
<ul>
<li>执行上下文(对象)是从属于所在的作用域</li>
<li>全局上下文环境-&gt;全局作用域</li>
<li>函数上下文环境-&gt;对应的函数使用域</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p><a href="https://blog.csdn.net/dovlie/article/details/76339244?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control">彻底理解JS中的闭包</a></p>
<p><a href="https://blog.csdn.net/weixin_43586120/article/details/89456183?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control">闭包，看这一篇就够了——带你看透闭包的本质，百发百中</a></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包</li>
<li>闭包是嵌套的内部函数，是包含被引用变量(函数)的对象</li>
<li>闭包存在于嵌套的内部函数中，<strong>执行函数定义就会产生闭包</strong>(不用调用内部函数)</li>
<li>产生闭包的条件：<pre><code>* 函数嵌套
* 内部函数引用了外部函数的数据(变量/函数)
</code></pre>
</li>
</ul>
<h2 id="常见闭包"><a href="#常见闭包" class="headerlink" title="常见闭包"></a>常见闭包</h2><p>将函数作为另一个函数的返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line">f(); <span class="comment">// 3</span></span><br><span class="line">f(); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>将函数作为实参传递给另一个函数调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDelay</span>(<span class="params">msg, time</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(msg);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;</span><br><span class="line">  showDelay(<span class="string">&#x27;atguigu&#x27;</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol>
<li>使用函数内部的变量在函数执行完后, 仍然存活在内存中，<strong>延长了局部变量的生命周期</strong>（类比static）</li>
<li>让函数外部可以操作(读写)到函数内部的数据(变量/函数)</li>
</ol>
<p>问题:</p>
<ol>
<li>函数执行完后, 函数内部声明的局部变量一般不存在, 存在于闭包中的变量才可能存在</li>
<li>在函数外部不能直接访问函数内部的局部变量吗, 但可以通过闭包让外部操作它</li>
</ol>
<h2 id="闭包的生命周期"><a href="#闭包的生命周期" class="headerlink" title="闭包的生命周期"></a>闭包的生命周期</h2><p>产生: 在嵌套内部函数<strong>定义执行</strong>完时产生(仅是完成了定义，不是调用)<br>死亡: 在嵌套的内部函数成为垃圾对象时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//此时闭包已经产生(函数提升, 内部函数对象已经创建了)</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line">f() <span class="comment">// 3;</span></span><br><span class="line">f() <span class="comment">// 4;</span></span><br><span class="line">f = <span class="literal">null</span>; <span class="comment">//闭包死亡(包含闭包的函数对象成为垃圾对象)</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h2><p>定义JS模块</p>
<ul>
<li>具有特定功能的js文件</li>
<li>将所有的数据和功能都封装在一个函数内部</li>
<li>只向外暴露一个包含n个方法的对象或函数</li>
<li>模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能</li>
</ul>
<h1 id="对象创建模式"><a href="#对象创建模式" class="headerlink" title="对象创建模式"></a>对象创建模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>（这部分在JS基础中讲过，此处是为了和下方的自定义构造函数放在一起）</p>
<ul>
<li>套路: 通过工厂函数动态创建对象并返回</li>
<li>适用场景: 需要创建多个对象</li>
<li>问题: <strong>对象没有一个具体的类型，都是Object类型</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123; <span class="comment">//返回一个对象的函数===&gt;工厂函数</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">      <span class="attr">name</span>: name,</span><br><span class="line">      <span class="attr">age</span>: age,</span><br><span class="line">      <span class="attr">setName</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建2个人</span></span><br><span class="line">  <span class="keyword">var</span> p1 = createPerson(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = createPerson(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// p1和p2是Object类型</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义构造函数模式"><a href="#自定义构造函数模式" class="headerlink" title="自定义构造函数模式"></a>自定义构造函数模式</h2><ul>
<li>套路: 自定义构造函数, 通过new创建对象</li>
<li>适用场景: 需要创建多个<strong>类型确定的对象</strong></li>
<li>问题: 每个对象都有相同的数据，浪费内存</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">12</span>);</span><br><span class="line">  p1.setName(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(p1.name, p1.age);</span><br><span class="line">  <span class="built_in">console</span>.log(p1 <span class="keyword">instanceof</span> Person);</span><br><span class="line">  <span class="comment">//p1确定的类型是Person</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Student</span> (<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">13000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> Student);</span><br><span class="line">  <span class="comment">//p2确定的类型是Student</span></span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;JACK&#x27;</span>, <span class="number">23</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(p1, p2);</span><br></pre></td></tr></table></figure>
<h2 id="构造函数-原型-的组合模式"><a href="#构造函数-原型-的组合模式" class="headerlink" title="构造函数+原型 的组合模式"></a>构造函数+原型 的组合模式</h2><ul>
<li>套路: 自定义构造函数，<strong>属性在函数中初始化, 方法添加到原型上</strong></li>
<li>适用场景: 需要创建多个类型确定的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123; </span><br><span class="line"><span class="comment">//属性在函数中初始化</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//向原型中添加方法</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">23</span>);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(p1, p2);</span><br></pre></td></tr></table></figure>

<h1 id="继承模式"><a href="#继承模式" class="headerlink" title="继承模式"></a>继承模式</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>（这一块很重要，笔试/面试可能会考察）<br>套路</p>
<ol>
<li>定义父类型构造函数</li>
<li>给父类型的原型添加方法</li>
<li>定义子类型的构造函数</li>
<li>创建父类型的对象赋值给子类型的原型</li>
<li>将子类型原型的构造属性设置为子类型（参考：<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">阮一峰的博客</a>）</li>
<li>给子类型原型添加方法</li>
<li>创建子类型的对象: 可以调用父类型的方法</li>
</ol>
<p><strong>关键：子类型的原型为父类型的一个实例对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.定义父类型构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Supper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.supProp = <span class="string">&#x27;Supper property&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//2.给父类型的原型添加方法</span></span><br><span class="line">  Supper.prototype.showSupperProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.supProp);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//3. 定义子类型的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subProp = <span class="string">&#x27;Sub property&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//4. 创建父类型的对象赋值给子类型的原型</span></span><br><span class="line">  Sub.prototype = <span class="keyword">new</span> Supper();</span><br><span class="line">  </span><br><span class="line"><span class="comment">//5. 将子类型原型的构造属性设置为子类型</span></span><br><span class="line">  Sub.prototype.constructor = Sub;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//6. 给子类型原型添加方法</span></span><br><span class="line">  Sub.prototype.showSubProp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.subProp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//7. 创建子类型的对象: 可以调用父类型的方法</span></span><br><span class="line">  <span class="keyword">var</span> sub = <span class="keyword">new</span> Sub();</span><br><span class="line">  sub.showSupperProp(); <span class="comment">//&quot;Supper property&quot;</span></span><br><span class="line">  <span class="comment">// sub.toString();</span></span><br><span class="line">  sub.showSubProp();  <span class="comment">//&quot;Sub property&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(sub);  <span class="comment">// Sub</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Sub</span></span><br><span class="line"><span class="comment">  subProp: &quot;Sub property&quot;</span></span><br><span class="line"><span class="comment">  __proto__: Supper</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>套路:</p>
<ol>
<li>定义父类型构造函数</li>
<li>定义子类型构造函数</li>
<li>在子类型构造函数中调用父类型构造（call，或直接用this）</li>
</ol>
<p><strong>关键：在子类型构造函数中通用call()调用父类型构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义父类型构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 定义子类型构造函数  </span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, salary</span>) </span>&#123;</span><br><span class="line"><span class="comment">//3.在子类型构造函数中调用父类型构造</span></span><br><span class="line">   Person.call(<span class="built_in">this</span>, name, age) ; </span><br><span class="line">   <span class="comment">// 相当于: this.Person(name, age);</span></span><br><span class="line">   <span class="built_in">this</span>.salary = salary;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="number">14000</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(s.name+<span class="string">&quot; &quot;</span>+s.age+<span class="string">&quot; &quot;</span>+s.salary);  <span class="comment">//Tom 20 14000</span></span><br></pre></td></tr></table></figure>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>原型链+借用构造函数的组合继承</p>
<ol>
<li>利用原型链实现对父类型对象的方法继承</li>
<li>利用call()借用父类型构建函数初始化相同属性</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"> Person.prototype.setName = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, price</span>) </span>&#123;</span><br><span class="line">   Person.call(<span class="built_in">this</span>, name, age);  <span class="comment">//为了得到属性</span></span><br><span class="line">   <span class="built_in">this</span>.price = price;</span><br><span class="line"> &#125;</span><br><span class="line"> Student.prototype = <span class="keyword">new</span> Person(); <span class="comment">//为了能使用父类型的方法</span></span><br><span class="line"> Student.prototype.constructor = Student; </span><br><span class="line"> <span class="comment">//修正constructor属性(这一句可以没有)</span></span><br><span class="line"> </span><br><span class="line"> Student.prototype.setPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.price = price;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//这里可以去掉，然后在var s下边一行加：s.__proto__.setPrice = ... </span></span><br><span class="line"> <span class="comment">//或者直接s.setPrice...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">24</span>, <span class="number">15000</span>);</span><br><span class="line"> s.setName(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"> s.setPrice(<span class="number">16000</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(s.name+<span class="string">&#x27; &#x27;</span>+s.age+<span class="string">&#x27; &#x27;</span>+ s.price);</span><br></pre></td></tr></table></figure>
<h1 id="线程机制与事件机制"><a href="#线程机制与事件机制" class="headerlink" title="线程机制与事件机制"></a>线程机制与事件机制</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程：<strong>程序的一次执行</strong>，它占有一片独有的内存空间</p>
<p>线程： CPU的基本调度单位, 是<strong>程序执行的一个完整流程</strong></p>
<p>进程与线程：</p>
<ul>
<li>一个进程中一般至少有一个运行的线程: <strong>主线程</strong></li>
<li>一个进程中也可以同时运行多个线程,，称程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程直接共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
</ul>
<p>单进程浏览器：firefox、老版IE<br> 多进程浏览器：chrome、新版IE</p>
<p>如何查看浏览器是否是多进程运行：任务管理器-&gt;进程</p>
<p>浏览器都是多线程运行的</p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>浏览器内核：<strong>支持浏览器运行的最核心的程序</strong></p>
<p>不同浏览器的内核：Chrome, Safari: webkit；firefox: Gecko；IE: Trident；360,搜狗等国内浏览器: Trident + webkit</p>
<p>内核由很多模块组成：</p>
<ul>
<li>html,css文档解析模块 : 负责页面文本的解析</li>
<li>dom/css模块 : 负责dom/css在内存中的相关处理</li>
<li>布局和渲染模块 : 负责页面的布局和效果的绘制</li>
<li>定时器模块 : 负责定时器的管理</li>
<li>网络请求模块 : 负责服务器请求(常规/Ajax)</li>
<li>事件响应模块 : 负责事件的管理</li>
</ul>
<h2 id="定时器引发的思考"><a href="#定时器引发的思考" class="headerlink" title="定时器引发的思考"></a>定时器引发的思考</h2><p> 定时器并不能保证真正定时执行，一般会延迟一丁点(可以接受), 也有可能延迟很长时间(不能接受)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;启动定时器前...&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;定时器执行了&#x27;</span>, <span class="built_in">Date</span>.now()-start);</span><br><span class="line">  &#125;, <span class="number">200</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;启动定时器后...&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 做一个长时间的工作，发现定时器执行的时间远远超过200ms</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改i之后的时间，先ctrl+s保存，在浏览器中刷新，再点击按钮，才会显示新的运行时间</span></span><br></pre></td></tr></table></figure>

<p>定时器回调函数在主线程执行，<strong>js是单线程的</strong></p>
<p>定时器是如何实现的：事件循环模型</p>
<h2 id="JS是单线程的"><a href="#JS是单线程的" class="headerlink" title="JS是单线程的"></a>JS是单线程的</h2><p>如何证明js执行是单线程的?</p>
<ul>
<li>setTimeout()的回调函数是在主线程执行的</li>
<li>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</li>
</ul>
<p>为什么js要用单线程模式, 而不用多线程模式?</p>
<ul>
<li>JavaScript的单线程，与它的用途有关。</li>
<li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</li>
</ul>
<p>代码的分类:</p>
<ul>
<li>初始化代码</li>
<li>回调代码</li>
</ul>
<p>JS引擎执行代码的基本流程：</p>
<ul>
<li>执行初始化代码: 包含一些特别的代码、回调函数(异步执行)</li>
<li>设置定时器</li>
<li>绑定事件监听</li>
<li>发送ajax请求</li>
<li>后面在某个时刻才会执行回调代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout 2rd&#x27;</span>);</span><br><span class="line">  alert(<span class="string">&#x27;Second&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout 1st&#x27;</span>);</span><br><span class="line">  alert(<span class="string">&#x27;First&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout() 0&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn()&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert()之前&#x27;</span>);</span><br><span class="line">alert(<span class="string">&#x27;------&#x27;</span>);</span><br><span class="line"><span class="comment">//暂停当前主线程的执行, 同时暂停计时, 点击确定后, 恢复程序执行和计时</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;alert()之后&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>该程序执行的次序：</p>
<ol>
<li>执行fn函数，在控制台输出fn()</li>
<li>控制台输出alert()之前</li>
<li>弹出’——‘</li>
<li>控制台输出alert()之后</li>
<li>控制台输出timeout() 0</li>
<li>控制台输出timeout 1st 弹出First</li>
<li>控制台输出timeout 2nd 弹出Second</li>
</ol>
<h2 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h2><p>所有代码分类</p>
<ul>
<li>初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li>
<li>回调执行代码(异步代码): 处理回调逻辑</li>
</ul>
<p>JS引擎执行代码的基本流程:初始化代码-&gt;回调代码</p>
<p>模型的2个重要组成部分:</p>
<ul>
<li>事件(定时器/DOM事件/Ajax)管理模块</li>
<li>回调队列</li>
</ul>
<p>模型的运转流程</p>
<ul>
<li>执行初始化代码,将事件回调函数交给对应模块管理</li>
<li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中</li>
<li>只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn1()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;点击了btn&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;定时器执行了&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;fn2()&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure>
<p>控制台依次打印：<br>fn1()<br>fn2()<br>定时器执行了</p>
<p>点击按钮，打印：点击了btn</p>
<h2 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h2><p>这一部分暂时先不学习</p>
<p>参考：阮一峰的ES6教程和尚硅谷教程</p>
<h1 id="let"><a href="#let" class="headerlink" title="let"></a>let</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>变量不能重复声明</li>
<li>块级作用域，{}</li>
<li>不存在变量提升</li>
<li>不影响作用域链<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> school = <span class="string">&#x27;尚硅谷&#x27;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(school);</span><br><span class="line">    &#125;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="comment">//在fn函数内部找不到school，沿着作用域链找到了let school = &#x27;尚硅谷&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="和var的比较"><a href="#和var的比较" class="headerlink" title="和var的比较"></a>和var的比较</h2>遍历并绑定事件：</li>
</ul>
<ol>
<li>用var（正确示范）：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">     items[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">this</span>.style.background = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>用var（错误示范）：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line"><span class="comment">//此处的var换成let即可正常运行</span></span><br><span class="line">     items[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         items[i].style.background = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
js先执行初始化代码，每个回调函数是赋给了items[i]，即items[0]，items[1]和items[2]都赋上了回调函数，但是<strong>由于i为全局变量</strong>，循环进行完后i的值为3，回调函数在执行的时候，function内的语句都变成了 items[3].style.background = ‘pink’; 又因为items[3]越界，所以就会报错。</li>
</ol>
<p>而用let时，相当于创建了一个个块级作用域，每个i只在自身的块级作用域内有效，就避免了这个问题。</p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h2><ul>
<li>一定要赋初始值</li>
<li>一般常量使用大写(潜规则)</li>
<li>值不能修改</li>
<li>块级作用域</li>
<li>对于数组和对象的元素修改（比如增删对象属性和方法，增删数组元素）, 不算做对常量的修改, 不会报错</li>
</ul>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><p>数组/对象都可用，但是数组要求<strong>顺序一致</strong>，对象要求花括号内的名称必须和对象内元素/方法的<strong>名称一致</strong></p>
<p>第一个例子，因为H在let中是第二个元素，对应原数组的第二个元素，所以控制台输出Yan而不是Han</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Dorm214 = [<span class="string">&#x27;Cui&#x27;</span>,<span class="string">&#x27;Yan&#x27;</span>,<span class="string">&#x27;Han&#x27;</span>,<span class="string">&#x27;Dong&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span>[Y,H,D] = Dorm214;</span><br><span class="line"><span class="built_in">console</span>.log(H);<span class="comment">//Yan</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> Danmo = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;Danmo&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="string">&quot;不详&quot;</span>,</span><br><span class="line">    <span class="attr">school</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&quot;此人在关山口男子职业技术学院读书&quot;</span>);  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;  </span><br><span class="line"> <span class="keyword">let</span> &#123;school&#125; = Danmo;</span><br><span class="line"> <span class="comment">//解构调用</span></span><br><span class="line"> school();</span><br><span class="line"> <span class="comment">//可以直接用方法的名字调用，不需要再写Danmo.school</span></span><br></pre></td></tr></table></figure>

<h1 id="模板字符串（反引号）与字符串拼接"><a href="#模板字符串（反引号）与字符串拼接" class="headerlink" title="模板字符串（反引号）与字符串拼接"></a>模板字符串（反引号）与字符串拼接</h1><p>单引号’’和双引号“”的字符串内，不能有换行符</p>
<p>而ES6新引入的反引号``，它建立的字符串中<strong>可以换行</strong></p>
<p>字符串拼接，只能在模板字符串中使用，格式是${变量名} <strong>←花括号</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//还记得JS练习3增删员工吗，这是以前的代码：</span></span><br><span class="line"> tr.innerHTML = <span class="string">&quot;&lt;td&gt;&quot;</span>+name+<span class="string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="line">        <span class="string">&quot;&lt;td&gt;&quot;</span>+email+<span class="string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="line">        <span class="string">&quot;&lt;td&gt;&quot;</span>+salary+<span class="string">&quot;&lt;/td&gt;&quot;</span>+</span><br><span class="line">        <span class="string">&quot;&lt;td&gt;&lt;a href=&#x27;javascript:;&#x27;&gt;Delete&lt;/a&gt;&lt;/td&gt;&quot;</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//用模板字符串：</span></span><br><span class="line">tr.innerHTML = <span class="string">`&lt;td&gt;<span class="subst">$&#123;name&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;td&gt;<span class="subst">$&#123;email&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;td&gt;<span class="subst">$&#123;salary&#125;</span>&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;td&gt;&lt;a href=&#x27;javascript:;&#x27;&gt;Delete&lt;/a&gt;&lt;/td&gt;;`</span></span><br></pre></td></tr></table></figure>
<h1 id="对象简化写法"><a href="#对象简化写法" class="headerlink" title="对象简化写法"></a>对象简化写法</h1><p>为了书写简洁，ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;HUST&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;来华科当单身狗!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    name,<span class="comment">//不需写name = name,</span></span><br><span class="line">    change,<span class="comment">//不需写change = change,</span></span><br><span class="line">    <span class="function"><span class="title">improve</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;提高单身姿势！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需写improve = function()&#123;...&#125;的“=function”</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);<span class="comment">//HUST</span></span><br><span class="line">school.change();<span class="comment">//来华科当单身狗!</span></span><br><span class="line">school.improve();<span class="comment">//提高单身姿势！</span></span><br></pre></td></tr></table></figure>

<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6 允许使用「箭头」（=&gt;）定义函数</p>
<h2 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h2><ul>
<li>this 是静态的. <strong>this 始终指向函数声明时所在作用域下的 this 的值</strong></li>
<li>不能作为构造实例化对象（不能var 对象 = new 箭头函数）</li>
<li>不能使用 arguments 变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> getName2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置 window 对象的 name 属性</span></span><br><span class="line">    <span class="built_in">window</span>.name = <span class="string">&#x27;华中科技大学&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> school = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;HUST&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//由于箭头函数是在全局下声明的，this就永远为window（静态this无法被修改）</span></span><br><span class="line">  getName.call(school);<span class="comment">//HUST</span></span><br><span class="line">    getName2.call(school);<span class="comment">//华中科技大学</span></span><br></pre></td></tr></table></figure>
<h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><ul>
<li>当形参只有一个时，可以省略小括号</li>
<li>当代码体只有一行语句时，可以省略花括号，如果这一条语句是return，此return也必须省略，语句的执行结果就是函数的返回值<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pow = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"><span class="built_in">console</span>.log(pow(<span class="number">8</span>));<span class="comment">//64</span></span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>需求1： 点击 div 2s 后颜色变成『粉色』<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="keyword">let</span> ad = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ad&#x27;</span>);</span><br><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">ad.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//修改背景颜色 </span></span><br><span class="line">        <span class="comment">//此处的this，是ad</span></span><br><span class="line">        <span class="built_in">this</span>.style.background = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
如果不用箭头函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取元素</span></span><br><span class="line"><span class="keyword">let</span> ad = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ad&#x27;</span>);</span><br><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">ad.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//保存 this 的值,如果不这么做，直接在定时器使用this，那么this的值为window</span></span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   _this.style.background = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>需求2：从数组中返回偶数的元素<br><a href="https://www.runoob.com/jsref/jsref-filter.html">filter方法——菜鸟教程</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">25</span>];</span><br><span class="line"> <span class="keyword">const</span> result = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(item % <span class="number">2</span> === <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">25</span>];</span><br><span class="line">    <span class="keyword">const</span> result = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<h1 id="函数参数默认值设置"><a href="#函数参数默认值设置" class="headerlink" title="函数参数默认值设置"></a>函数参数默认值设置</h1><p>ES6 允许给函数参数赋值初始值</p>
<p>形参初始值 具有默认值的参数, 一般位置要靠后(潜规则)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b,c=<span class="number">10</span></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a + b + c;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> result = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(result);<span class="comment">//13</span></span><br></pre></td></tr></table></figure>
<p>可与解构赋值结合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">&#123;host=<span class="string">&quot;1037&quot;</span>, username,password, port&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(host);  <span class="comment">//1037（没传参数，使用默认值）</span></span><br><span class="line">    <span class="built_in">console</span>.log(username);  <span class="comment">//root</span></span><br><span class="line">    <span class="built_in">console</span>.log(password);  <span class="comment">//root</span></span><br><span class="line">    <span class="built_in">console</span>.log(port);  <span class="comment">//3306</span></span><br><span class="line">&#125;</span><br><span class="line">connect(&#123;</span><br><span class="line">    <span class="comment">//host: &#x27;hust&#x27;,</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3306</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments</p>
<p>rest获取实参和arguments的区别：前者把参数存入数组，后者是类数组但不是数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5 获取实参的方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">date</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">date(<span class="string">&#x27;白芷&#x27;</span>,<span class="string">&#x27;阿娇&#x27;</span>,<span class="string">&#x27;思慧&#x27;</span>);</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210122221703792.jpg" width="30%">

<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rest 参数</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">date</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(args);</span><br><span class="line"> &#125;</span><br><span class="line"> date(<span class="string">&#x27;阿娇&#x27;</span>,<span class="string">&#x27;柏芝&#x27;</span>,<span class="string">&#x27;思慧&#x27;</span>);</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210122221901428.jpg" width="30%">

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rest 参数必须要放到参数最后</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,...args</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(b);<span class="comment">//2</span></span><br><span class="line">     <span class="built_in">console</span>.log(args);<span class="comment">//剩下参数全存入数组，(4)[3,4,5,6]</span></span><br><span class="line"> &#125;</span><br><span class="line">  fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><h2 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h2><p>『…』 扩展运算符能将『数组』转换为逗号分隔的『参数序列』</p>
<p>对于下例，即把[‘易烊千玺’,’王源’,’王俊凯’]变为’易烊千玺’,’王源’,’王俊凯’</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tfboys = [<span class="string">&#x27;易烊千玺&#x27;</span>,<span class="string">&#x27;王源&#x27;</span>,<span class="string">&#x27;王俊凯&#x27;</span>];</span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunwan</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">chunwan(...tfboys);</span><br><span class="line"><span class="comment">// 等价于chunwan(&#x27;易烊千玺&#x27;,&#x27;王源&#x27;,&#x27;王俊凯&#x27;)</span></span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210123211033731.jpg" width="30%">

<hr>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tfboys = [<span class="string">&#x27;易烊千玺&#x27;</span>,<span class="string">&#x27;王源&#x27;</span>,<span class="string">&#x27;王俊凯&#x27;</span>];</span><br><span class="line"><span class="comment">// 声明一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunwan</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">chunwan(tfboys);</span><br><span class="line"><span class="comment">//不加拓展运算符</span></span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/20210123211105675.jpg" width="40%">

<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><h3 id="数组的合并"><a href="#数组的合并" class="headerlink" title="数组的合并"></a>数组的合并</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> kuaizi = [<span class="string">&#x27;王太利&#x27;</span>,<span class="string">&#x27;肖央&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fenghuang = [<span class="string">&#x27;曾毅&#x27;</span>,<span class="string">&#x27;玲花&#x27;</span>];</span><br><span class="line"><span class="comment">// const zuixuanxiaopingguo = kuaizi.concat(fenghuang);</span></span><br><span class="line"><span class="keyword">const</span> zuixuanxiaopingguo = [...kuaizi, ...fenghuang];</span><br><span class="line"><span class="built_in">console</span>.log(zuixuanxiaopingguo);</span><br></pre></td></tr></table></figure>

<h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sanzhihua = [<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;M&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> sanyecao = [...sanzhihua];<span class="comment">//  [&#x27;E&#x27;,&#x27;G&#x27;,&#x27;M&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(sanyecao);</span><br></pre></td></tr></table></figure>

<h3 id="将伪数组转化为真正数组"><a href="#将伪数组转化为真正数组" class="headerlink" title="将伪数组转化为真正数组"></a>将伪数组转化为真正数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> divArr = [...divs];</span><br><span class="line"><span class="built_in">console</span>.log(divArr);</span><br></pre></td></tr></table></figure>
<img src="https://img-blog.csdnimg.cn/2021012323401920.jpg" width="30%">

<h1 id="Symbol——第七种数据类型"><a href="#Symbol——第七种数据类型" class="headerlink" title="Symbol——第七种数据类型"></a>Symbol——第七种数据类型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Symbol</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;尚硅谷&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&#x27;尚硅谷&#x27;</span>);</span><br><span class="line"><span class="comment">//s2===s3报false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Symbol.for 创建</span></span><br><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;尚硅谷&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s5 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;尚硅谷&#x27;</span>);</span><br><span class="line"><span class="comment">//s4===s5报true</span></span><br></pre></td></tr></table></figure>
<p>Symbol不能与其他数据进行运算</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Symbol表示独一无二的值</p>
<p>可以简单、高效、安全地向对象中添加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> game = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;俄罗斯方块&#x27;</span>,</span><br><span class="line">    <span class="attr">up</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">down</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在想要向这个对象中添加up和down方法（不知道会重名），则用Symbol较为安全</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> methods = &#123;</span><br><span class="line">    <span class="attr">up</span>: <span class="built_in">Symbol</span>(),</span><br><span class="line">    <span class="attr">down</span>: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line">game[methods.up] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以改变形状&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">game[methods.down] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以快速下降&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接把Symbol作为属性名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> game = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;狼人杀&quot;</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;say&#x27;</span>)]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我可以发言&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;zibao&#x27;</span>)]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我可以自爆&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>
    <img src="https://img-blog.csdnimg.cn/20210205113902749.jpg" width=" 60%">
    <br>
    <font size="3" face="楷体" color="#999"><u>Symbol的一些方法：控制对象在特定场景下的表现<u></u></u></font>
</center>

<p>像上方的.hasInstance，.match，它们都是Symbol的属性，而Symbol.hasInstance，又作为对象的属性，控制对象在特定场景下的表现（或者说拓展对象的功能）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//Symbol.isConcatSpreadable属性，表示数组合并时是否展开</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.concat(arr2));</span><br></pre></td></tr></table></figure>

<center>
    <img src="https://img-blog.csdnimg.cn/20210205114752392.jpg" width=" 50%">
    <br>
    <font size="3" face="楷体" color="#999"><u>如图，Array(3)没有展开</u></font>
</center>

<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><h2 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h2><p>演示：<br>for…of遍历输出键值，而for…in遍历输出键名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xiyou = [<span class="string">&#x27;唐僧&#x27;</span>,<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;猪八戒&#x27;</span>,<span class="string">&#x27;沙僧&#x27;</span>];</span><br><span class="line"><span class="comment">//使用 for...of 遍历数组</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> xiyou)&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(v);<span class="comment">//唐僧 孙悟空 猪八戒 沙僧</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">in</span> xiyou)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(v);<span class="comment">//0 1 2 3</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用条件和原理"><a href="#使用条件和原理" class="headerlink" title="使用条件和原理"></a>使用条件和原理</h2><p>使用迭代器的条件：对象拥有Symbol.iterator属性</p>
<center>
    <img src="https://img-blog.csdnimg.cn/20210205120844253.jpg" width=" 80%">
    <br>
    <font size="3" face="楷体" color="#999"><u>条件</u></font>
</center>

<p>迭代器的工作原理：</p>
<ul>
<li>创建一个指针对象，指向当前数据结构的起始位置</li>
<li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</li>
<li>每调用 next 方法返回一个包含 value 和 done 属性的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xiyou = [<span class="string">&#x27;唐僧&#x27;</span>,<span class="string">&#x27;孙悟空&#x27;</span>,<span class="string">&#x27;猪八戒&#x27;</span>,<span class="string">&#x27;沙僧&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iterator = xiyou[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"><span class="built_in">console</span>.log(iterator);</span><br></pre></td></tr></table></figure>
<center>
    <img src="https://img-blog.csdnimg.cn/20210205120850213.jpg" width="50%">
    <br>
    <font size="3" face="楷体" color="#999"><u>打印Symbol.iterator属性对应函数的返回值</u></font>
</center>

<p>继续调用next方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br></pre></td></tr></table></figure>

<center>
    <img src="https://img-blog.csdnimg.cn/20210205121426299.jpg" width="38%">
    <br>
    <font size="3" face="楷体" color="#999"><u>返回具有value和done属性的对象，遍历完成后done为true</u></font>
</center>

<h2 id="自定义遍历数据"><a href="#自定义遍历数据" class="headerlink" title="自定义遍历数据"></a>自定义遍历数据</h2><p>Symbol.iterator要返回对象，该对象内需要有next方法，next需要返回一个含value和done（必须叫value和done）的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> banji = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;终极一班&quot;</span>,</span><br><span class="line">    <span class="attr">stus</span>: [</span><br><span class="line">        <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xiaoning&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;xiaotian&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;knight&#x27;</span></span><br><span class="line">    ],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        <span class="comment">//使得_this指向banji，此处可以用箭头函数替代</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; _this.stus.length) &#123;</span><br><span class="line">                    <span class="keyword">const</span> result = &#123; <span class="attr">value</span>: _this.stus[index], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">                    index++;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> banji) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);<span class="comment">//xiaoming xiaoning xiaotian knight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h1><h2 id="简介、传参"><a href="#简介、传参" class="headerlink" title="简介、传参"></a>简介、传参</h2><p>生成器是一个特殊的函数，在function和括号之间要加星号，它是实现异步编程的一种方式</p>
<p>它不会立即执行，而需要先获取迭代器对象，用next方法一步一步执行，每一次next都执行到下一个yield为止（yield为分隔符，yield后可以是数字,字符串…）</p>
<p>可以向next中传参，其参数会成为上一个yield的返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">    <span class="keyword">let</span> one = <span class="keyword">yield</span> <span class="number">111</span>;<span class="comment">//one==&#x27;BBB&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(one);</span><br><span class="line">    <span class="keyword">let</span> two = <span class="keyword">yield</span> <span class="number">222</span>;<span class="comment">//two==&#x27;CCC&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(two);</span><br><span class="line">    <span class="keyword">let</span> three = <span class="keyword">yield</span> <span class="number">333</span>;<span class="comment">//three==&#x27;DDD&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行获取迭代器对象</span></span><br><span class="line"><span class="keyword">let</span> iterator = gen(<span class="string">&#x27;AAA&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="comment">//AAA</span></span><br><span class="line"><span class="comment">//&#123;value:111,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">&#x27;BBB&#x27;</span>));</span><br><span class="line"><span class="comment">//BBB</span></span><br><span class="line"><span class="comment">//&#123;value:222,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">&#x27;CCC&#x27;</span>));</span><br><span class="line"><span class="comment">//CCC</span></span><br><span class="line"><span class="comment">//&#123;value:333,done:flase&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">&#x27;DDD&#x27;</span>));</span><br><span class="line"><span class="comment">//DDD</span></span><br><span class="line"><span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h2><p>需求：使用定时器，1s 后控制台输出 111，2s后输出 222，3s后输出 333</p>
<p>传统方案：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>当计时器不断增多，缩进不断向右，形成“回调地狱”</p>
<p>改进：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">111</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">222</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">three</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">333</span>);</span><br><span class="line">        iterator.next();</span><br><span class="line">    &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> one();</span><br><span class="line">    <span class="keyword">yield</span> two();</span><br><span class="line">    <span class="keyword">yield</span> three();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用生成器函数</span></span><br><span class="line"><span class="keyword">let</span> iterator = gen();</span><br><span class="line"><span class="comment">//此处第一次调用</span></span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure>

<p>需求：依次获取到用户数据  订单数据  商品数据（异步）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&#x27;用户数据&#x27;</span>;</span><br><span class="line">        <span class="comment">//调用 next 方法, 并且将数据传入</span></span><br><span class="line">        <span class="comment">//第二次调用next方法，参数data传给第一次yield的返回值，即users=&#x27;用户数据&#x27;</span></span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOrders</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&#x27;订单数据&#x27;</span>;</span><br><span class="line">        <span class="comment">//第三次调用next方法，参数data传给第二次yield的返回值，即orders=&#x27;订单数据&#x27;</span></span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGoods</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&#x27;商品数据&#x27;</span>;</span><br><span class="line">        iterator.next(data);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> users = <span class="keyword">yield</span> getUsers();</span><br><span class="line">    <span class="keyword">let</span> orders = <span class="keyword">yield</span> getOrders();</span><br><span class="line">    <span class="keyword">let</span> goods = <span class="keyword">yield</span> getGoods();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用生成器函数</span></span><br><span class="line"><span class="keyword">let</span> iterator = gen();</span><br><span class="line"><span class="comment">//第一次调用next方法</span></span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>我的理解：Promise内部的函数执行，和用then调用是可以不同时进行的（像生成器gen和next方法），所以使用Promise是一个异步的过程，这些ES6中新的异步特性，大多都是为了避免“回调地狱”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">let</span> data = <span class="string">&#x27;数据库中的用户数据&#x27;</span>;</span><br><span class="line">       resolve(data);</span><br><span class="line">       <span class="comment">//执行resolve后就不会再执行下方代码了</span></span><br><span class="line">       <span class="comment">//如果把上边两行注了，状态变为失败，调用then的时候会在控制台输出&#x27;数据读取失败&#x27;</span></span><br><span class="line">       <span class="keyword">let</span> err = <span class="string">&#x27;数据读取失败&#x27;</span>;</span><br><span class="line">       reject(err);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 promise 对象的 then 方法</span></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">//&#x27;数据库中的用户数据&#x27;</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(reason);</span><br><span class="line">    <span class="comment">//.error和.log类似，只不过输出的是红色的错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>then中可以只传一个函数作为参数</strong>（只写成功函数，或只写失败函数）</p>
<h2 id="读取封装文件"><a href="#读取封装文件" class="headerlink" title="读取封装文件"></a>读取封装文件</h2><p>此处和node.js有联系，某些地方暂时看不懂也没关系</p>
<p><a href="https://www.runoob.com/nodejs/nodejs-fs.html">Node.js 文件系统</a></p>
<p>同理，这是一个异步的过程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 使用 Promise 封装</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;./resources/为学.md&quot;</span>, <span class="function">(<span class="params">err, data</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//判断如果失败,比如把文件路径写错</span></span><br><span class="line">        <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">        <span class="comment">//如果成功，文件路径正确且可读</span></span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.toString());</span><br><span class="line">    <span class="comment">//value的值是一个buffer</span></span><br><span class="line">    <span class="comment">//调用.toString方法后，就能把文件内容打印在控制台</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;读取失败!!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="封装Ajax请求"><a href="#封装Ajax请求" class="headerlink" title="封装Ajax请求"></a>封装Ajax请求</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口地址: https://api.apiopen.top/getJoke</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//1. 创建对象</span></span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 初始化</span></span><br><span class="line">      xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://api.apiopen.top/getJ&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 发送</span></span><br><span class="line">      xhr.send();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4. 绑定事件, 处理响应结果</span></span><br><span class="line">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">//判断</span></span><br><span class="line">          <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">              <span class="comment">//判断响应状态码 200-299</span></span><br><span class="line">              <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                  <span class="comment">//表示成功</span></span><br><span class="line">                  resolve(xhr.response);</span><br><span class="line">                  <span class="comment">//不用Promise会这样写：console.log(xhr.response)</span></span><br><span class="line">                  <span class="comment">//外边这个function是回调函数，即依靠回调函数来实现异步</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//如果失败</span></span><br><span class="line">                  reject(xhr.status);</span><br><span class="line">                  <span class="comment">//不用Promise会这样写：console.error(xhr.status)</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//指定回调</span></span><br><span class="line">  p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>以前在回调函数中执行回调，现在在then方法中执行回调，结构更清晰，也没有回调地狱</p>
<h2 id="Promise-then方法详解"><a href="#Promise-then方法详解" class="headerlink" title="Promise.then方法详解"></a>Promise.then方法详解</h2><p>调用 then 方法，then方法的返回结果是 Promise 对象, 对象状态由回调函数的执行结果决定</p>
<ol>
<li>如果回调函数中返回的结果是 非 promise 类型的属性, 状态为成功, 返回值为对象的成功的值（如果不写return，返回值为undefined，为非promise类型属性，状态仍为成功）</li>
<li>如果回调函数中返回的结果是promise类型属性，状态和该promise的状态一致，对象的成功/失败值也和该promise一致</li>
<li>如果没有返回值，而是抛出错误，则状态为失败，对象的失败值和抛出错误的内容一致</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;用户数据&#x27;</span>);</span><br><span class="line">        <span class="comment">// reject(&#x27;出错啦&#x27;);</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"> <span class="keyword">const</span> result = p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错啦!&#x27;</span>);<span class="comment">//扔出错误1</span></span><br><span class="line">        <span class="comment">//throw &#x27;出错啦!&#x27;;     //扔出错误2</span></span><br><span class="line"> &#125;, <span class="function"><span class="params">reason</span>=&gt;</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.warn(reason);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<center>
    <img src="https://img-blog.csdnimg.cn/20210208113226894.jpg" width=" 60%">
    <br>
    <font size="3" face="楷体" color="#999"><u>扔出错误1</u></font>
</center>


<center>
    <img src="https://img-blog.csdnimg.cn/20210208113303808.jpg" width=" 60%">
    <br>
    <font size="3" face="楷体" color="#999"><u>扔出错误2</u></font>
</center>

<p>由于then的返回结果是Promise对象，因此可以链式调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="用Promise合并三个文本"><a href="#用Promise合并三个文本" class="headerlink" title="用Promise合并三个文本"></a>用Promise合并三个文本</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先需要声明一个promise对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;./resources/为学.md&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//通过then方法形成链式结构</span></span><br><span class="line"><span class="comment">//then的返回值是promise对象，先执行函数体内的语句，</span></span><br><span class="line"><span class="comment">//该promise的value就等于成功值，即resolve括号内的值</span></span><br><span class="line">p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;./resources/插秧诗.md&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            resolve([value, data]);</span><br><span class="line">            <span class="comment">//value是上一个成功值，即为学，data是插秧诗</span></span><br><span class="line">            <span class="comment">//这里新建了一个数组，并把为学和插秧诗放在这个数组内</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(<span class="string">&quot;./resources/观书有感.md&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//value是之前创造的数组，data是观书有感</span></span><br><span class="line">            <span class="comment">//把观书有感作为元素压入这个数组</span></span><br><span class="line">            value.push(data);</span><br><span class="line">            resolve(value);</span><br><span class="line">            <span class="comment">//现在得到一个数组，元素是三个文本</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.join(<span class="string">&#x27;\r\n&#x27;</span>));</span><br><span class="line">    <span class="comment">// \r是回车（回到本行行首），\n是换行（到下一行同一个位置处）</span></span><br><span class="line">    <span class="comment">//用回车符和换行符来分隔三个文本</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="catch方法"><a href="#catch方法" class="headerlink" title=".catch方法"></a>.catch方法</h2><p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p>
<p>是ES6提供的一个语法糖，专门指定状态为失败时的回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//设置 p 对象的状态为失败, 并设置失败的值</span></span><br><span class="line">        reject(<span class="string">&quot;出错啦!&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// p.then(function(value)&#123;&#125;, function(reason)&#123;</span></span><br><span class="line"><span class="comment">//     console.error(reason);</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="集合Set"><a href="#集合Set" class="headerlink" title="集合Set"></a>集合Set</h1><h2 id="简介与API"><a href="#简介与API" class="headerlink" title="简介与API"></a>简介与API</h2><p>set规定元素不能重复，如果重复会自动去重</p>
<p>set支持拓展运算符，和for…of</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个 set</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();<span class="comment">//声明一个空集合</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;大事儿&#x27;</span>,<span class="string">&#x27;小事儿&#x27;</span>,<span class="string">&#x27;好事儿&#x27;</span>,<span class="string">&#x27;坏事儿&#x27;</span>,<span class="string">&#x27;小事儿&#x27;</span>]);</span><br><span class="line"><span class="comment">//集合接受数组为参数，用来初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//元素个数</span></span><br><span class="line">   <span class="built_in">console</span>.log(s2.size);<span class="comment">//4</span></span><br><span class="line"><span class="comment">//添加新的元素</span></span><br><span class="line">   s2.add(<span class="string">&#x27;喜事儿&#x27;</span>);</span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">   s2.delete(<span class="string">&#x27;坏事儿&#x27;</span>);</span><br><span class="line"><span class="comment">//检测</span></span><br><span class="line">   <span class="built_in">console</span>.log(s2.has(<span class="string">&#x27;糟心事&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">   s2.clear();</span><br><span class="line">   <span class="built_in">console</span>.log(s2);<span class="comment">//Set(0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> s2)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul>
<li>数组去重：先把数组转化为集合，再用…将集合转化为数组</li>
<li>交集：使用数组filter方法，把其中的一个数组转化为集合（去重提高效率），再判断该集合中有无该元素（filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素）</li>
<li>差集：对交集取反即可</li>
<li>并集：先用…合并数组，转化为集合去重，再转化为数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="comment">//1. 数组去重</span></span><br><span class="line">   <span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line">   <span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">//2. 交集</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">   <span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)].filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>(arr2);<span class="comment">// 4 5 6</span></span><br><span class="line">       <span class="keyword">if</span>(s2.has(item))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="comment">//以下为简略写法：</span></span><br><span class="line">   <span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)].filter(<span class="function"><span class="params">item</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(item));</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 并集</span></span><br><span class="line">   <span class="keyword">let</span> union = [...new <span class="built_in">Set</span>([...arr, ...arr2])];</span><br><span class="line">   <span class="built_in">console</span>.log(union);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 差集</span></span><br><span class="line"><span class="keyword">let</span> diff = [...new <span class="built_in">Set</span>(arr)].filter(<span class="function"><span class="params">item</span> =&gt;</span> !(<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(item)));</span><br><span class="line"><span class="built_in">console</span>.log(diff);</span><br></pre></td></tr></table></figure>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map是一个升级版的对象，传统Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明 Map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">m.set(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;尚硅谷&#x27;</span>);</span><br><span class="line">m.set(<span class="string">&#x27;change&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我们可以改变你!!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> key = &#123;</span><br><span class="line">    <span class="attr">school</span> : <span class="string">&#x27;ATGUIGU&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">m.set(key, [<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//size</span></span><br><span class="line"><span class="built_in">console</span>.log(m.size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.delete(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(<span class="string">&#x27;change&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(m.get(key));</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.clear();</span><br><span class="line"><span class="comment">//console.log(m); //Map(0)&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> m)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>

<center>
    <img src="https://img-blog.csdnimg.cn/2021020816082817.jpg" width="60%">
    <br>
    <font size="3" face="楷体" color="#999"><u>控制台信息</u></font>
</center>

<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了让JS更有面向对象内味，ES6加入了class，其绝大部分功能ES5都可以实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5通过原型对象添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand, price</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加方法</span></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">let</span> Huawei = <span class="keyword">new</span> Phone(<span class="string">&#x27;华为&#x27;</span>, <span class="number">5999</span>);</span><br><span class="line">Huawei.call();</span><br><span class="line"><span class="built_in">console</span>.log(Huawei);</span><br><span class="line"></span><br><span class="line"><span class="comment">//class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shouji</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造方法 名字不能修改</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, price</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法必须使用该语法, 不能使用 ES5 的对象完整形式（call:function()&#123;&#125;）</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> onePlus = <span class="keyword">new</span> Shouji(<span class="string">&quot;1+&quot;</span>, <span class="number">1999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(onePlus);</span><br></pre></td></tr></table></figure>

<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>ES5引例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Phone.name = <span class="string">&#x27;手机&#x27;</span>;</span><br><span class="line">Phone.change = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以改变世界&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这些添加的属性和方法，只属于函数对象，不属于实例对象，称为静态成员</span></span><br><span class="line">Phone.prototype.size = <span class="string">&#x27;5.5inch&#x27;</span>;</span><br><span class="line"><span class="comment">//如果想要实例对象也有这些属性或方法，必须添加给原型对象</span></span><br><span class="line"><span class="keyword">let</span> nokia = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(nokia.name); <span class="comment">//undefined</span></span><br><span class="line">nokia.change();<span class="comment">//报错，change函数未定义</span></span><br><span class="line"><span class="built_in">console</span>.log(nokia.size);<span class="comment">//5.5inch</span></span><br></pre></td></tr></table></figure>
<p>ES6：静态成员同理，只属于函数但不属于实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&#x27;手机&#x27;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">change</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我可以改变世界&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nokia = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(nokia.name);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Phone.name);<span class="comment">//手机</span></span><br></pre></td></tr></table></figure>

<h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><p>ES5的组合继承：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand, price</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能手机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmartPhone</span>(<span class="params">brand, price, color, size</span>)</span>&#123;</span><br><span class="line">    Phone.call(<span class="built_in">this</span>, brand, price);</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置子级构造函数的原型</span></span><br><span class="line">SmartPhone.prototype = <span class="keyword">new</span> Phone;</span><br><span class="line">SmartPhone.prototype.constructor = SmartPhone;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明子类的方法</span></span><br><span class="line">SmartPhone.prototype.photo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以拍照&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmartPhone.prototype.playGame = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以玩游戏&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chuizi = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;锤子&#x27;</span>,<span class="number">2499</span>,<span class="string">&#x27;黑色&#x27;</span>,<span class="string">&#x27;5.5inch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(chuizi);</span><br></pre></td></tr></table></figure>

<p>ES6的类继承：<br>声明子类时，用extends 父类，在子类中想要获取父类的属性，使用super()，其相当于父类的constructor</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, price</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的成员属性</span></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">brand, price, color, size</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(brand, price);<span class="comment">// Phone.call(this, brand, price)</span></span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">photo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;拍照&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">playGame</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">call</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我可以进行视频通话&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaomi = <span class="keyword">new</span> SmartPhone(<span class="string">&#x27;小米&#x27;</span>,<span class="number">799</span>,<span class="string">&#x27;黑色&#x27;</span>,<span class="string">&#x27;4.7inch&#x27;</span>);</span><br><span class="line"><span class="comment">// console.log(xiaomi);</span></span><br><span class="line">xiaomi.call();</span><br><span class="line">xiaomi.photo();</span><br><span class="line">xiaomi.playGame();</span><br></pre></td></tr></table></figure>
<h2 id="set和get"><a href="#set和get" class="headerlink" title="set和get"></a>set和get</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">price</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;价格属性被读取了&quot;</span>);<span class="comment">//当读取price的值时，执行该函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;iloveyou&#x27;</span>;<span class="comment">//return的值会赋给price</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">price</span>(<span class="params">newVal</span>)&#123;<span class="comment">//此处必须传参，否则报错</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;价格属性被修改了&#x27;</span>);<span class="comment">//设置price的值时，执行该函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(s.price);</span><br><span class="line">s.price = <span class="string">&#x27;free&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="数值拓展"><a href="#数值拓展" class="headerlink" title="数值拓展"></a>数值拓展</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0. Number.EPSILON 是 JavaScript 表示的最小精度</span></span><br><span class="line"><span class="comment">//EPSILON 属性的值接近于 2.2204460492503130808472633361816E-16</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(a-b) &lt; <span class="built_in">Number</span>.EPSILON)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);<span class="comment">//false</span></span><br><span class="line"> <span class="built_in">console</span>.log(equal(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>))<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 二进制和八进制</span></span><br><span class="line"> <span class="keyword">let</span> b = <span class="number">0b1010</span>;</span><br><span class="line"> <span class="keyword">let</span> o = <span class="number">0o777</span>;</span><br><span class="line"> <span class="keyword">let</span> d = <span class="number">100</span>;</span><br><span class="line"> <span class="keyword">let</span> x = <span class="number">0xff</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Number.isFinite  检测一个数值是否为有限数</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="number">100</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="number">100</span>/<span class="number">0</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3. Number.isNaN 检测一个数值是否为 NaN </span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.isNaN(<span class="number">123</span>)); </span><br><span class="line"></span><br><span class="line"><span class="comment">//4. Number.parseInt Number.parseFloat字符串转整数</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseInt(<span class="string">&#x27;5211314love&#x27;</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.parseFloat(<span class="string">&#x27;3.1415926神奇&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. Number.isInteger 判断一个数是否为整数</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">5</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Number</span>.isInteger(<span class="number">2.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. Math.trunc 将数字的小数部分抹掉  </span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">3.5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. Math.sign 判断一个数到底为正数 负数 还是零</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.sign(<span class="number">100</span>));<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.sign(<span class="number">0</span>));<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.sign(-<span class="number">20000</span>));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<h1 id="对象方法拓展"><a href="#对象方法拓展" class="headerlink" title="对象方法拓展"></a>对象方法拓展</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Object.is 判断两个值是否完全相等</span></span><br><span class="line"><span class="comment">//它和===几乎一样，唯一区别在于判断NaN时，等号认为NaN不能和任何值相等，而is认为可以 </span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">120</span>, <span class="number">120</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. Object.assign 对象的合并</span></span><br><span class="line">   <span class="keyword">const</span> config1 = &#123;</span><br><span class="line">       <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">       <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">       <span class="attr">pass</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">       <span class="attr">test</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">const</span> config2 = &#123;</span><br><span class="line">       <span class="attr">host</span>: <span class="string">&#x27;http://atguigu.com&#x27;</span>,</span><br><span class="line">       <span class="attr">port</span>: <span class="number">33060</span>,</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&#x27;atguigu.com&#x27;</span>,</span><br><span class="line">       <span class="attr">pass</span>: <span class="string">&#x27;iloveyou&#x27;</span>,</span><br><span class="line">       <span class="attr">test2</span>: <span class="string">&#x27;test2&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(config1, config2));</span><br><span class="line">   <span class="comment">//如果键名相同，后面的覆盖前面的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. Object.setPrototypeOf 设置原型对象  Object.getPrototypeof</span></span><br><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;尚硅谷&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cities = &#123;</span><br><span class="line">    <span class="attr">xiaoqu</span>: [<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(school, cities);</span><br><span class="line"><span class="comment">//虽然可行，但是通过Object.create()方法设置原型对象效率更高</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(school));</span><br><span class="line"><span class="built_in">console</span>.log(school);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>web开发</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>c++面向对象</title>
    <url>/2021/08/19/25.c++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>已有c的基础，故只记录了以前没学过的部分：</p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1 Hello World"></a>1 Hello World</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-输出变量"><a href="#2-输出变量" class="headerlink" title="2 输出变量"></a>2 输出变量</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a =&quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// a = 10</span></span><br></pre></td></tr></table></figure>

<h2 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3 关键字"></a>3 关键字</h2><table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4 数据类型"></a>4 数据类型</h2><h3 id="4-1-转义"><a href="#4-1-转义" class="headerlink" title="4.1 转义"></a>4.1 转义</h3><table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>*<em>\\*</em></td>
<td><strong>代表一个反斜线字符”&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody></table>
<h3 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h3><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==（经过测试，不加也可以运行）</p>
</blockquote>
<h3 id="4-3-布尔"><a href="#4-3-布尔" class="headerlink" title="4.3 布尔"></a>4.3 布尔</h3><p><strong>bool类型占==1个字节==大小</strong></p>
<h3 id="4-4-数据的输入"><a href="#4-4-数据的输入" class="headerlink" title="4.4 数据的输入"></a>4.4 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//整型输入</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; a;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//浮点型输入</span></span><br><span class="line">  <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; d;</span><br><span class="line">  cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字符型输入</span></span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; ch;</span><br><span class="line">  cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字符串型输入</span></span><br><span class="line">  string str;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; str;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//布尔类型输入</span></span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 测试时输入一个数，输入0时输出0，输入非0时输出1</span></span><br><span class="line">  <span class="comment">// 如果输入的是true或false，得到的输出都为0</span></span><br><span class="line">  cin &gt;&gt; flag;</span><br><span class="line">  cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>  在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>  <strong>代码区：</strong></p>
<p>​    存放 CPU 执行的机器指令</p>
<p>​    代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​    代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>  <strong>全局区：</strong></p>
<p>​    全局变量和静态变量存放在此.</p>
<p>​    全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​    ==该区域的数据在程序结束后由操作系统释放==.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//局部变量</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印地址</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<img src="https://z3.ax1x.com/2021/08/19/fHLqPO.png" alt="1545017602518" style="zoom: 80%;">



<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p><strong>栈区：</strong></p>
<p>​    由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​    注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆区：</strong></p>
<p>​    由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​    在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>  C++中利用==new==操作符在堆区开辟数据</p>
<p>  堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>
<p>  语法：<code> new 数据类型</code></p>
<p>  利用new创建的数据，会返回该数据对应的类型的==指针==</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    arr[i] = i + <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">  <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">  <span class="keyword">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">  c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">  <span class="keyword">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">  <span class="keyword">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">  ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">  <span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">  ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">func</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//v += 10;</span></span><br><span class="line">  cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">  <span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">  cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong> （避免歧义，编译器就不会迷惑）</li>
</ul>
<blockquote>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p>
<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>
<p>具有相同性质的==对象==，可以抽象称为==类==</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>  在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="keyword">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//行为</span></span><br><span class="line">  <span class="comment">//获取到圆的周长</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">calculateZC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2 * pi  * r</span></span><br><span class="line">    <span class="comment">//获取圆的周长</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">  <span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">  Circle c1;</span><br><span class="line">  c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected  保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问 子类可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问 子类不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  string m_Car;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">    m_Password = <span class="number">123456</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">  <span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">  <span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  C1 c1;</span><br><span class="line">  c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">  C2 c2;</span><br><span class="line">  c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">//姓名设置可读可写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    m_Name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取年龄 </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置年龄</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情人设置为只写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">    m_Lover = lover;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">  string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Person p;</span><br><span class="line">  <span class="comment">//姓名设置</span></span><br><span class="line">  p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//年龄设置</span></span><br><span class="line">  p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情人设置</span></span><br><span class="line">  p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">  <span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>  一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>  同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong> <code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>  按参数分为： 有参构造和无参构造</p>
<p>  按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>  括号法</p>
<p>  显示法</p>
<p>  隐式转换法</p>
<p>注意事项：</p>
<p>  显示法中，如果只写等号右侧的部分，则是一个匿名对象，当前行执行完毕后立刻析构</p>
<p>  不能利用<code>拷贝构造函数</code>初始化匿名对象，编译器会认为是对象声明</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有参构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    age = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    age = p.age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.1  括号法，常用</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">  <span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.2 显式法</span></span><br><span class="line">  Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">  Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">  <span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.3 隐式转换法</span></span><br><span class="line">  Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">  Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">  <span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mAge = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mAge = p.mAge;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">  <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">  Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Person newman3;</span></span><br><span class="line">  <span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">  <span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Person p1;</span><br><span class="line">  cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">  cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line">  <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p><strong>结论：</strong></p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li>
</ul>
<ul>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有参构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    age = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    age = p.age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">  <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">  Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">  Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">  <span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p>浅拷贝的问题：如果不提供拷贝构造函数，编译器提供的拷贝函数使用浅拷贝，如果有在堆区开辟的属性，会出现内存重复释放问题。</p>
<p>此处的场景：p1通过有参构造函数构造，p2由p1拷贝得到，它们都是局部变量，根据栈先进后出的原则，p2会先被析构函数释放，于是堆区0x0011被清空，在此之后p1被析构函数释放时，会再次对堆区0x0011进行清空，但此时堆区0x0011不具有清空的权限，就会报错。</p>
<p>所以p2应当使用深拷贝（必须自己提供拷贝函数），在拷贝时再开辟一片空间来保存m_Height</p>
<img src="https://z3.ax1x.com/2021/08/20/fLjZYq.png" style="zoom: 67%;">

<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有参构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age ,<span class="keyword">int</span> height) &#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    m_age = age;</span><br><span class="line">    m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(height);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数  </span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">    m_age = p.m_age;</span><br><span class="line">    m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_height);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//析构函数，用于释放堆区</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_age;</span><br><span class="line">  <span class="keyword">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">////传统方式初始化</span></span><br><span class="line">  <span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">  <span class="comment">//  m_A = a;</span></span><br><span class="line">  <span class="comment">//  m_B = b;</span></span><br><span class="line">  <span class="comment">//  m_C = c;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化列表方式初始化</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>创建B对象时，A与B的构造顺序：==先A后B（先零件后整体）==，析构与之相反</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Phone</span>(string name) &#123;</span><br><span class="line">    m_PhoneName = name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_PhoneName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">  <span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">  <span class="comment">//析构顺序与构造相反</span></span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">  p.<span class="built_in">playGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字<code>static</code>，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li> 所有对象共享同一份数据</li>
<li> 在编译阶段分配内存</li>
<li> 类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li> 所有对象共享同一个函数</li>
<li> 静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态成员变量特点：</span></span><br><span class="line">  <span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">  <span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">  <span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//1、通过对象</span></span><br><span class="line">  Person p1;</span><br><span class="line">  p1.m_A = <span class="number">100</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  Person p2;</span><br><span class="line">  p2.m_A = <span class="number">200</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、通过类名</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="补充：双冒号"><a href="#补充：双冒号" class="headerlink" title="补充：双冒号"></a>补充：双冒号</h5><p><code>::</code> 是作用域符，是运算符中等级最高的，它分为三种:</p>
<ol>
<li>==global scope (全局作用域符）==，用法（::name)，如在程序中的某一处想调用全局变量a，那么就写成::a（也可以是全局函数）</li>
<li>==class scope (类作用域符）==，用法(class::name)，如果想调用class A中的成员变量a，那么就写成A::a</li>
<li>==namespace scope (命名空间作用域符）==，用法(namespace::name)，如果想调用namespace std中的cout成员，就写成std::cout</li>
</ol>
<p>都是左关联（left-associativity)，作用都是为了更明确的调用变量</p>
<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    mA = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">  <span class="keyword">int</span> mA;</span><br><span class="line">  <span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> mB; </span><br><span class="line">  <span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li> 当形参和成员变量同名时，可用this指针来区分</li>
<li> 在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处必须返回引用，才能保证修改的是同一个对象</span></span><br><span class="line">    <span class="comment">//否则参考4.2.3，以值方式返回时会调用拷贝构造函数，创建一个新的Person实例对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">    <span class="comment">//返回对象本身</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person * p = <span class="literal">NULL</span>;</span><br><span class="line"> p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line"> p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后，称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数（一般函数里可能存在对某一不可修改变量的修改）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>() &#123;</span><br><span class="line">  m_A = <span class="number">0</span>;</span><br><span class="line">  m_B = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"> <span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">//this-&gt;m_A = 100; //报错</span></span><br><span class="line">  <span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">//mA = 10000;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">int</span> m_A;</span><br><span class="line"> <span class="keyword">mutable</span> <span class="keyword">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line"> cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line"> person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//常对象访问成员函数</span></span><br><span class="line"> person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象只能调用常函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员，关键字为 <code>friend</code></p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line"> <span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"> <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Building</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> string m_BedRoom;     <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GoodGay是一个全局函数，不在类Building中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span> </span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Building b;</span><br><span class="line"> <span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-类做友元（含类外实现成员函数）"><a href="#4-4-2-类做友元（含类外实现成员函数）" class="headerlink" title="4.4.2 类做友元（含类外实现成员函数）"></a>4.4.2 类做友元（含类外实现成员函数）</h4><p>代码中包括了：在类的外部定义函数的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span> <span class="comment">//声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">goodGay</span>();  <span class="comment">//声明有该函数，但在外部定义</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">  <span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123;</span><br><span class="line">  building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  goodGay gg;</span><br><span class="line">  gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">goodGay</span>();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">  <span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123;</span><br><span class="line">  building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  goodGay  gg;</span><br><span class="line">  gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">  Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">    temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//  Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//  temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//  temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//  return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p2, <span class="keyword">int</span> val) &#123;</span><br><span class="line">  Person temp;</span><br><span class="line">  temp.m_A = p2.m_A + val;</span><br><span class="line">  temp.m_B = p2.m_B + val;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//成员函数方式</span></span><br><span class="line">  Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  Person p4 = p3 + <span class="number">10</span>;  <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<p>注意点：</p>
<ol>
<li>&lt;&lt;运算符重载只能使用全局函数，因为成员函数实现时&lt;&lt;在右侧，实现不了想要的效果</li>
<li>全局函数的返回值类型是ostream&amp;，如果是void，后边就不能加 &lt;&lt; endl，导致无法换行（实现链式编程）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载（输出类实例的全部属性）</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">  <span class="comment">//此处形参写out，在test中传入的实参还是cout（简化版可能没那么容易看出）</span></span><br><span class="line">  out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据递增</p>
<p>对于前置++，在++(++num)时，由于需要保证每次修改的是同一个num，因此需要返回引用</p>
<p>而对于后置++，由于重载函数体内返回了局部变量，如果返回值是引用，那么返回的就是局部变量的引用，会报错，因此只能返回值，因此出现(num++)++的写法是无效的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">    m_Num = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//前置++</span></span><br><span class="line">  MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="comment">//先++ 再返回</span></span><br><span class="line">    m_Num++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//后置++</span></span><br><span class="line">  <span class="comment">//只能通过int占位符区分前置和后置</span></span><br><span class="line">  MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="comment">//先返回</span></span><br><span class="line">    MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">    m_Num++;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">  out &lt;&lt; myint.m_Num;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyInteger myInt;</span><br><span class="line">  cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyInteger myInt;</span><br><span class="line">  cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>==赋值运算符 operator=, 对属性进行值拷贝==</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">    m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重载赋值运算符 </span></span><br><span class="line">  Person&amp; <span class="keyword">operator</span>=(Person &amp;p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_Age;</span><br><span class="line">      m_Age = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">    <span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">    m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回自身</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_Age;</span><br><span class="line">      m_Age = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//年龄的指针</span></span><br><span class="line">  <span class="keyword">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//重载关系运算符 </span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//重载的()操作符，也称为仿函数</span></span><br><span class="line">  MyPrint myFunc;</span><br><span class="line">  <span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//重载()操作符</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyAdd add;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//匿名对象调用  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>定义一些类时，下级别的成员除了拥有上一级的共性，还有自己的特性，可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Java页面</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Java ja;</span><br><span class="line">  ja.<span class="built_in">header</span>();</span><br><span class="line">  ja.<span class="built_in">footer</span>();</span><br><span class="line">  ja.<span class="built_in">left</span>();</span><br><span class="line">  ja.<span class="built_in">content</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Python页面</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Python py;</span><br><span class="line">  py.<span class="built_in">header</span>();</span><br><span class="line">  py.<span class="built_in">footer</span>();</span><br><span class="line">  py.<span class="built_in">left</span>();</span><br><span class="line">  py.<span class="built_in">content</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//C++页面</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  CPP cp;</span><br><span class="line">  cp.<span class="built_in">header</span>();</span><br><span class="line">  cp.<span class="built_in">footer</span>();</span><br><span class="line">  cp.<span class="built_in">left</span>();</span><br><span class="line">  cp.<span class="built_in">content</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<img src="https://z3.ax1x.com/2021/08/22/fzWXNV.png" alt="img" style="zoom:80%;">





<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">    m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">    <span class="comment">//m_C; //不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son1 s1;</span><br><span class="line">  s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">    m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">    <span class="comment">//m_C; //不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son2 s;</span><br><span class="line">  <span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> Base3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">    m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">    <span class="comment">//m_C; //不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandSon3</span> :</span><span class="keyword">public</span> Son3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">    <span class="comment">//m_A;</span></span><br><span class="line">    <span class="comment">//m_B;</span></span><br><span class="line">    <span class="comment">//m_C;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>利用工具查看：</p>
<p><img src="https://z3.ax1x.com/2021/08/22/fzhfSS.png" alt="1545881904150"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<img src="https://z3.ax1x.com/2021/08/22/fzhRW8.png" alt="1545882158050" style="zoom:80%;">



<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">  Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员——直接访问即可</li>
<li>访问父类同名成员——需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123;</span><br><span class="line">    m_A = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>() &#123;</span><br><span class="line">    m_A = <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">  <span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">func</span>();</span><br><span class="line">  s.Base::<span class="built_in">func</span>();</span><br><span class="line">  s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员——直接访问即可</li>
<li>访问父类同名成员——需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过对象访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Son s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过类名访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl; <span class="comment">//直接写Base::m_A也可以</span></span><br><span class="line">  <span class="comment">//第一个::代表通过类名方式访问，第二个::代访问父类作用域下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过对象访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Son s;</span><br><span class="line">  s.<span class="built_in">func</span>();</span><br><span class="line">  s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Son::<span class="built_in">func</span>();</span><br><span class="line">  Son::Base::<span class="built_in">func</span>();</span><br><span class="line">  <span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">  Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现的现象，需要加作用域区分，故<strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base1</span>() &#123;</span><br><span class="line">    m_A = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base2</span>() &#123;</span><br><span class="line">    m_A = <span class="number">200</span>; <span class="comment">// 和Base1中的m_A重名</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>() &#123;</span><br><span class="line">    m_C = <span class="number">300</span>;</span><br><span class="line">    m_D = <span class="number">400</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">  <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承和虚继承"><a href="#4-6-8-菱形继承和虚继承" class="headerlink" title="4.6.8 菱形继承和虚继承"></a>4.6.8 菱形继承和虚继承</h4><p>由于多继承使用较少，遇到菱形继承的机会更少，因此了解即可</p>
<p><strong>菱形继承概念：</strong></p>
<p>  两个派生类继承同一个基类</p>
<p>  又有某个类同时继承者两个派生类</p>
<p>  这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<img src="https://z3.ax1x.com/2021/08/22/fzXFQ1.png" alt="IMG_256" style="zoom: 67%;">



<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SheepTuo st;</span><br><span class="line">  st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">  st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li><p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费</p>
</li>
<li><p>利用虚继承可以解决菱形继承问题</p>
</li>
<li><p>虚继承的原理：子类不再保存父类的数据，而是保存指针，通过给指针设置不同的偏移量，从而共享数据（详情见视频）</p>
</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>对多态的解释：多态，即一个接口有多种形态，对于同一个接口，当传入的对象不同（Animal、cat…）时，会得到不同的结果</p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载 属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">  <span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态多态</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span> </span>&#123;</span><br><span class="line">  animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态的满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态的使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Cat cat;</span><br><span class="line">  <span class="comment">//动态多态，传入cat后才确定函数地址，进而调用Cat类的函数</span></span><br><span class="line">  <span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line">  Dog dog;</span><br><span class="line">  <span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数（父类要有虚函数，子类将它重写，子类中的同名函数的virtual可带可不带）</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型、函数名、参数列表 完全一致 称为重写</p>
<h4 id="4-7-2-多态的原理剖析"><a href="#4-7-2-多态的原理剖析" class="headerlink" title="4.7.2 多态的原理剖析"></a>4.7.2 多态的原理剖析</h4><img src="https://z3.ax1x.com/2021/08/22/hS1G24.png" style="zoom: 50%;">

<p>添加了virtual后，类中保存了vfptr指针，它指向对应的vftable，vftable中存该类的属性和函数（可以是自己的，也可以是继承下来的）</p>
<p>一旦重写了子类的函数，子类对应的vftable会改变</p>
<img src="https://z3.ax1x.com/2021/08/22/hS1zJU.png" style="zoom:67%;">

<h4 id="4-7-3-多态案例一-计算器类"><a href="#4-7-3-多态案例一-计算器类" class="headerlink" title="4.7.3 多态案例一-计算器类"></a>4.7.3 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li><p>满足开闭原则（对于扩展是开放的，对于修改是封闭的）</p>
</li>
<li><p>代码组织结构清晰</p>
</li>
<li><p>可读性强</p>
</li>
<li><p>利于前期和后期的扩展以及维护</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>普通实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(string oper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Num1;</span><br><span class="line">  <span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//普通实现测试</span></span><br><span class="line">  Calculator c;</span><br><span class="line">  c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">  c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多态实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多态实现 抽象计算器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> m_Num1;</span><br><span class="line">  <span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建加法计算器</span></span><br><span class="line">  AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">  abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">  abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建减法计算器</span></span><br><span class="line">  abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">  abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">  abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建乘法计算器</span></span><br><span class="line">  abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">  abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">  abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-4-纯虚函数和抽象类"><a href="#4-7-4-纯虚函数和抽象类" class="headerlink" title="4.7.4 纯虚函数和抽象类"></a>4.7.4 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 纯虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base * base = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//base = new Base; //错误，抽象类无法实例化对象</span></span><br><span class="line">  base = <span class="keyword">new</span> Son;</span><br><span class="line">  base-&gt;<span class="built_in">func</span>();</span><br><span class="line">  <span class="keyword">delete</span> base;       <span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-5-多态案例二-制作饮品"><a href="#4-7-5-多态案例二-制作饮品" class="headerlink" title="4.7.5 多态案例二-制作饮品"></a>4.7.5 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDrinking</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//烧水</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//冲泡</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//倒入杯中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//加入辅料</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//规定流程</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Boil</span>();</span><br><span class="line">    <span class="built_in">Brew</span>();</span><br><span class="line">    <span class="built_in">PourInCup</span>();</span><br><span class="line">    <span class="built_in">PutSomething</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//烧水</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//冲泡</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//倒入杯中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//加入辅料</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//烧水</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//冲泡</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//倒入杯中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//加入辅料</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">  drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">  <span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-6-虚析构和纯虚析构"><a href="#4-7-6-虚析构和纯虚析构" class="headerlink" title="4.7.6 虚析构和纯虚析构"></a>4.7.6 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//虚析构</span></span><br><span class="line">  <span class="comment">//virtual ~Animal() &#123;</span></span><br><span class="line">  <span class="comment">//  cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//纯虚析构（和虚析构有其一即可）</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚析构不仅要有声明，还要有实现，否则在运行时编译器报错</span></span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含了纯虚析构函数的类也是一个抽象类，不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cat</span>(string name) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_Name;</span><br><span class="line">      m_Name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">  animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">  <span class="comment">//父类指针在析构的时候不会调用子类中的析构函数，导致子类如果有堆区的属性，会出现内存泄漏</span></span><br><span class="line">  <span class="comment">//只要把父类的析构改为虚析构/纯虚析构 即可</span></span><br><span class="line">  <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ol>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
</ol>
<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三种流对象:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>其中，2、3可以合并为一步</p>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 少了这句会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ofstream ofs;</span><br><span class="line">  <span class="comment">//只写文件名，则在当前目录下创建文件</span></span><br><span class="line">  ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">  <span class="comment">//ofstream ofs(&quot;test.txt&quot;, ios::out); 等价于以上写法</span></span><br><span class="line">  </span><br><span class="line">  ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">  ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">  ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 少了这句会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ifstream ifs;</span><br><span class="line">  ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一种方式</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二种</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf))) &#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第三种</span></span><br><span class="line">  string buf;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf)) &#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第四种</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF) &#123;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件 </li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作，打开方式要指定为 ==ios::binary==</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 少了这句会报错</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、创建输出流对象</span></span><br><span class="line">  <span class="comment">//可以在这一步就指定打开方式，从而省略open</span></span><br><span class="line">  <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3、打开文件</span></span><br><span class="line">  <span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">  Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、写文件</span></span><br><span class="line">  ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p)); <span class="comment">// 第一个参数需要强制类型转换为char *</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//5、关闭文件</span></span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1 命名空间"></a>1 命名空间</h2><h3 id="1-1-命名空间的介绍"><a href="#1-1-命名空间的介绍" class="headerlink" title="1.1 命名空间的介绍"></a>1.1 命名空间的介绍</h3><p>namespace即命名空间，它的目的是解决同一作用域下同名变量或函数的冲突</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> space_1 &#123;</span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// 访问时使用 space_1::num</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> space_2 &#123;</span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// 访问时使用 space_2::num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-using-namespace"><a href="#1-2-using-namespace" class="headerlink" title="1.2 using namespace"></a>1.2 using namespace</h3><p>如果每一个同名变量都使用 <code>命名空间::变量名</code>的方式去访问，显得冗余</p>
<p>因此，可以使用 <code>using namespace 命名空间名</code>，指定默认的命名空间，从而当只写变量名时，会访问该命名空间下的变量</p>
<p>不过，如果某一个函数在某一命名空间下声明，在写实现的时候，必须加命名空间名，否则编译器会认为是一个新的全局函数，而不是对已声明函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myspace &#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">namespace</span> inner &#123;</span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// 不会冲突</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myspace;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myspace::print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;pi&quot;</span> &lt;&lt; pi &lt;&lt; endl;&#125; <span class="comment">// 必须加命名空间名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  size = <span class="number">100</span>; <span class="comment">// 即myspace::size = 100</span></span><br><span class="line">  inner::size = <span class="number">200</span>; <span class="comment">// 此处不可简写</span></span><br><span class="line">  cout &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; inner::size &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-std"><a href="#1-3-std" class="headerlink" title="1.3 std"></a>1.3 std</h3><p>常见的cin、cout、endl等对象都定义在std（标准命名空间）中，因此如果不使用<code>using namespace std</code>，访问他们就必须加std::</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// using namespace myspace;</span></span><br><span class="line"><span class="comment">// 如果同时使用了这两个命名空间，会出现变量名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myspace &#123;</span><br><span class="line"> <span class="keyword">int</span> cout = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">int</span> endl = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; myspace::cout &lt;&lt; <span class="string">&quot; _This is myspace_ &quot;</span> &lt;&lt; myspace::endl &lt;&lt; std::endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>2021寒假前端刷题笔记</title>
    <url>/2021/08/22/32.2021%E5%AF%92%E5%81%87%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><del>我是蒟蒻，大佬求放过:sob:</del></p>
<h1 id="BY2017秋"><a href="#BY2017秋" class="headerlink" title="BY2017秋"></a>BY2017秋</h1><h2 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h2><blockquote>
<p>尝试定义一个复制函数，接受上图所示的类似结构（只有一个根节点），返回一个全新的结构相同的对象</p>
</blockquote>
<p><em><strong>考点：数据结构</strong></em></p>
<p>这题应该是定义一个可以复制二叉树的函数，不过数据结构目前还没学到这…</p>
<hr>
<h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><blockquote>
<p>请使用尽可能多的CSS选择器及伪类选中如下的”I love bingyan”,并将其变为红色（规则主体可只写一次）</p>
</blockquote>
<p><em><strong>考点：CSS选择器</strong></em></p>
<p>上方的代码由自己补全：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="comment">/*  元素选择器 span&#123;&#125;   √</span></span></span><br><span class="line"><span class="comment"><span class="css">      *  id选择器 #&#123;&#125;     √</span></span></span><br><span class="line"><span class="comment"><span class="css">      *  类选择器 .&#123;]     √</span></span></span><br><span class="line"><span class="comment"><span class="css">      *  通配选择器 *&#123;&#125;      ×</span></span></span><br><span class="line"><span class="comment"><span class="css">      *  交/并集选择器，子元素，后代，兄弟 此处不考虑</span></span></span><br><span class="line"><span class="comment"><span class="css">      *  重点练习伪类选择器：（child和type的区别见下方）</span></span></span><br><span class="line"><span class="comment"><span class="css">      */</span></span></span><br><span class="line"><span class="css">      <span class="selector-tag">span</span><span class="selector-pseudo">:first</span>-child&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">           <span class="selector-tag">span</span><span class="selector-pseudo">:first</span>-of-type&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">span</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">span</span><span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="css">                <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="css">            &#125;</span></span><br><span class="line"><span class="css">            </span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!---------------------------------------------------------------------------------------------------------------------&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">id</span>=<span class="string">&quot;world&quot;</span> <span class="attr">data-love</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">     DO NOT SELECT ME.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">     I love bingyan.</span><br><span class="line">     <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/2050/p/3569509.html">css选择器中:first-child与:first-of-type的区别</a>：总的来说，child系匹配<strong>结构上</strong>的第n个子元素，type系匹配的是某父元素下<strong>相同类型</strong>子元素中的第一个。</p>
<hr>
<h3 id="盒模型、border-box"><a href="#盒模型、border-box" class="headerlink" title="盒模型、border-box"></a>盒模型、border-box</h3><blockquote>
<p>请用图形方式展现如下CSS代码产生的盒模型及尺寸</p>
</blockquote>
<p><em><strong>考点：CSS盒子模型，border-box</strong></em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">   <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">20px</span> <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">padding-top</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">padding-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">   <span class="attribute">box-sizing</span>: border-box; </span></span><br><span class="line"><span class="css"> &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>三个方向的margin，分别代表：<strong>上、左右、下</strong></p>
<ul>
<li>之前关于border-box的理解不够深刻：经过测试，对content-box修改padding值会影响盒子的大小，但对于border-box，只要padding不超过width或height，对盒子的大小没有影响</li>
</ul>
<img src="https://img-blog.csdnimg.cn/20210126223201877.jpg" width="40%">

<p>（擅自加了背景颜色和边框，右侧为content-box对比版）</p>
<ul>
<li>用开发者工具看一看：<center>
  <img src="https://img-blog.csdnimg.cn/20210310184852348.jpg" width="20%">
  <br>
  <font size="3" face="楷体" color="#999"><u></u></font>
</center></li>
</ul>
<center>
    <img src="https://img-blog.csdnimg.cn/20210310184858203.jpg" width="50%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>

<p>由于一般情况下padding的值默认为0，又没有设置padding-bottom，所以padding-bottom == 0，而height == 100 - 20 = 80px</p>
<hr>
<h3 id="双栏等宽布局"><a href="#双栏等宽布局" class="headerlink" title="双栏等宽布局"></a>双栏等宽布局</h3><blockquote>
<p>使用HTML和CSS实现一个双栏等宽布局</p>
</blockquote>
<p><em><strong>考点：HTML和CSS实现网页布局</strong></em><br>首先来了解一下什么是“双栏布局”，这个布局方式见过，但这个名词我还没听说过：<a href="https://zhuanlan.zhihu.com/p/106079715">kokodayo</a></p>
<p>用box-shadow将两栏隔开</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">!DOCTYPE html&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.wrapper</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">1210px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>);</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果展示：<br><img src="https://img-blog.csdnimg.cn/20210127122840673.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMjM1NzM2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="JS选中HTML元素的方法"><a href="#JS选中HTML元素的方法" class="headerlink" title="JS选中HTML元素的方法"></a>JS选中HTML元素的方法</h3><hr>
<blockquote>
<p>列出在JavaScript中可以选中HTML元素的方法，他们的返回值分别是什么类型</p>
</blockquote>
<ul>
<li>getElementById，返回值是id为某个值的对象</li>
<li>getElementsByTagName，返回值是封装了标签名为某个值的对象的伪数组</li>
<li>getElementsByName，返回值是封装了name为某个值的对象的伪数组</li>
<li>getElementsByClassName，返回值是封装了class为某个值的对象的伪数组</li>
</ul>
<p>突然想到一个问题：type=”text/javascript”是必须的吗：<a href="https://segmentfault.com/q/1010000002804178">kokodayo</a></p>
<hr>
<blockquote>
<p>列出你所知道的JavaScript基本类型</p>
</blockquote>
<p>USONB  you are so niubility （滑稽）</p>
<p>u  undefined<br>s  string  symbol<br>o  object（引用类型）<br>n  null number<br>b  boolean</p>
<p>继续思考，怎么对object进行分类：<a href="https://juejin.cn/post/6844903951125446669">kokodayo</a></p>
<hr>
<h3 id="css三角形"><a href="#css三角形" class="headerlink" title="css三角形"></a>css三角形</h3><blockquote>
<p>请思考如何在网页中显示一个三角形，列出尽可能多的方法（请放飞自我）</p>
</blockquote>
<p>请参考我的这篇博客：<a href="https://blog.csdn.net/m0_51235736/article/details/109817725">kokodayo</a></p>
<p>不过里面只有两种方法，最常见的方法估计还是第一种</p>
<hr>
<h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><blockquote>
<p>列出尽可能多的专用于创建一个表单的HTML元素（如table，tr）</p>
</blockquote>
<p><a href="https://www.w3school.com.cn/html/html_tables.asp">w3school表格</a><br><a href="https://www.w3school.com.cn/html/html_forms.asp">w3school表单</a></p>
<p>table、tbody、td、tr、th（表头）</p>
<p>form、input、button</p>
<p>表单的属性众多：</p>
<ul>
<li>form的属性：action、method、name、target、autocomplete</li>
<li>input的属性：type</li>
</ul>
<p>（表单相关内容在学习了nodejs后再复习更佳）</p>
<hr>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><blockquote>
<p>如何让一个元素相对其父元素垂直居中</p>
</blockquote>
<p>可以参考：<a href="https://blog.csdn.net/m0_51235736/article/details/109799086">HTML/CSS 实现居中的方法</a></p>
<p>方法一：绝对定位+margin<br>方法二：table-cell和align管垂直+margin管水平<br>方法三：绝对定位和平移<br>补充：方法四：弹性盒中的垂直居中</p>
<hr>
<h3 id="行内和块元素的区别"><a href="#行内和块元素的区别" class="headerlink" title="行内和块元素的区别"></a>行内和块元素的区别</h3><blockquote>
<p>行内元素和块级元素有什么区别</p>
</blockquote>
<ol>
<li>行内元素可以排在一行中，块级元素独占一行</li>
<li>行内元素只能包含数据和其他行内元素，而块级元素可以包含行内元素和其他块级元素</li>
<li>行内元素不能设置宽高，但块级元素可以</li>
</ol>
<hr>
<h3 id="JS创建对象并添加属性"><a href="#JS创建对象并添加属性" class="headerlink" title="JS创建对象并添加属性"></a>JS创建对象并添加属性</h3><blockquote>
<p>列出在JavaScript中创建一个对象并给其增加一个可读取的属性的方法</p>
</blockquote>
<p>先创建对象再设置属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.attr1 = <span class="string">&quot;attr1&quot;</span></span><br><span class="line">obj.attr2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>对象字面量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  attr1 = <span class="string">&quot;attr1&quot;</span>,</span><br><span class="line">  attr2 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="原型链——Array和Object"><a href="#原型链——Array和Object" class="headerlink" title="原型链——Array和Object"></a>原型链——Array和Object</h3><blockquote>
<p>JavaScript的Array和Object之间有什么关系</p>
</blockquote>
<p>参考：<a href="https://juejin.cn/post/6844903951125446669">JS对象分类</a></p>
<p>Array是Object，<br>Object是Array的原型，Array是Object的实例(更准确的说法是，Object.prototype是Array.prototype的原型，反过来是实例…)</p>
<p>参考：<a href="https://blog.csdn.net/C05230/article/details/108234593">js中Object与Function与Array的关系图</a></p>
<p>特别喜欢这个博客说的一句话：万物皆对象，所有的函数都是function的实例</p>
<hr>
<h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><h3 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h3><blockquote>
<p>在JavaScript中使用new运算符创建一个对象的过程中发生了什么</p>
</blockquote>
<p><a href="https://xie.infoq.cn/article/3767706419c668c9b5e671717">参考博客1</a><br><a href="https://shizhonghai.github.io/2020/09/16/javascript-new-object-happen/">参考博客2</a><br><a href="https://www.runoob.com/jsref/jsref-shift.html">数组的shift方法</a><br><a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">阮一峰博客</a></p>
<p>过程四（+1）步走：</p>
<ol>
<li>创建一个空对象（1）</li>
<li>获取到构造函数（2）</li>
<li>把空对象作为构造函数的上下文（3）</li>
<li>把该对象关联到构造函数（4）</li>
<li>如果原始对象或者构造函数有返回值且为对象，则返回该对象，否则返回新创建的对象（5）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个简单的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rocker</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">Rocker.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),   </span><br><span class="line">  <span class="comment">//(1)创建一个空对象</span></span><br><span class="line">  Constructor = [].shift.call(<span class="built_in">arguments</span>);   </span><br><span class="line">  <span class="comment">//(2)shift方法会返回数组中的第一个元素，</span></span><br><span class="line">  <span class="comment">//该语句的意思是，将传入的第一个参数（即构造函数对象，也就是下方的Rocker）赋值给Constrctor对象</span></span><br><span class="line">  <span class="comment">//（因为prototype的constructor属性会指向该原型对象的构造函数，所以这里给变量起名为Constructor，不懂的去看阮一峰博客）</span></span><br><span class="line">  obj.__proto__ = Constructor.prototype;    </span><br><span class="line">  <span class="comment">//(3)把obj的原型链指向Constructor的原型</span></span><br><span class="line">  <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>);    </span><br><span class="line">  <span class="comment">//(4)把参数传入Constructor（即Rocker）函数中，并把this修改为obj（修改上下文）</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret : obj;   </span><br><span class="line">  <span class="comment">//(5)如果传参正确，就返回ret（正确的实例对象），否则返回空对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Freak = createObject(Rocker, <span class="string">&#x27;Freak&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Freak.name);  <span class="comment">//Freak</span></span><br><span class="line"><span class="built_in">console</span>.log(Freak.getName());  <span class="comment">//Freak</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(Freak) === Rocker.prototype); <span class="comment">//true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="空对象和空数组不相等"><a href="#空对象和空数组不相等" class="headerlink" title="空对象和空数组不相等"></a>空对象和空数组不相等</h3><blockquote>
<p>计算返回值（已用console.log表示）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(&#123;&#125;==&#123;&#125;);<span class="comment">//false</span></span><br><span class="line">  <span class="built_in">console</span>.log([]==[]);<span class="comment">//false</span></span><br><span class="line">  <span class="built_in">console</span>.log([]==<span class="number">0</span>);<span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;0&quot;</span>==<span class="literal">false</span>);<span class="comment">//true</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>空对象和空数组不相等的原因：<a href="https://www.cnblogs.com/superlizhao/p/8944377.html">kokodayo</a><br><a href="https://segmentfault.com/a/1190000006752076">思否：JavaScript 深入了解基本类型和引用类型的值</a></p>
<p>因为对象是引用类型，比较两个对象时，是引用的比较，两个对象的地址不一样，所以返回false。</p>
<hr>
<h3 id="类数组转化为数组"><a href="#类数组转化为数组" class="headerlink" title="类数组转化为数组"></a>类数组转化为数组</h3><blockquote>
<p>如何将一个类数组对象转化为数组对象？如果想不转化便使用Array上定义的方法该如何做？</p>
</blockquote>
<p>学习一下“伪数组”：<br><a href="https://segmentfault.com/a/1190000015285969">思否：伪数组(ArrayLike)</a><br><a href="https://www.cnblogs.com/chenpingzhao/p/4764791.html">JavaScript中的数组与伪数组的区别</a><br><a href="https://blog.csdn.net/weixin_45811256/article/details/110856303?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161172802916780271524250%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161172802916780271524250&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-110856303.first_rank_v2_pc_rank_v29&utm_term=%25E4%2BC%25AA%25E6%2595%25B0%25E7%25BB%2584%25E8%25BD%25AC%25E5%258C%2596%25E7%259C%259F%25E6%2595%25B0%25E7%25BB%2584">CSDN：如何把一个伪数组转化成真正的数组？</a></p>
<p>方法一：ES6的拓展运算符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> divArr = [...divs];</span><br><span class="line">  <span class="built_in">console</span>.log(divArr);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//即：var arr = [...arrLike];</span></span><br></pre></td></tr></table></figure>
<p>方法二：遍历添加入一个空数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrLike.length; i++)&#123;</span><br><span class="line">    arr.push(arrLike[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三：ES6的Array.from方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(arrLike);</span><br></pre></td></tr></table></figure>
<p>方法四：slice()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [].slice.call(arrlike);</span><br><span class="line"><span class="comment">//对于call和apply，slice之前是[]或Array.prototype都可以</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.apply(arrlike);</span><br></pre></td></tr></table></figure>
<p>以上几种方法，不会保留索引值以外的其他额外属性</p>
<hr>
<p>方法五：修改原型指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arrLike.__proto__ = <span class="built_in">Array</span>.prototype;</span><br></pre></td></tr></table></figure>
<p>这样arrLike就继承了Array.prototype中的方法，可以使用push()，unshift()等方法了，length值也会随之动态改变。<br>另外这种直接修改原型链的方法，<strong>还会保留下伪数组中的所有属性</strong>，包括不是索引值的属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">div</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid black;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> arrlike = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;box&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//var arrlike = document.getElementsByTagName(&quot;div&quot;);</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//不要这么写，因为页面中有隐藏div，占用伪数组的第一个位置</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(arrlike);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(arrlike <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> arr = <span class="built_in">Array</span>.from(arrlike);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(arr);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);        </span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在测试这个例子的时候，发现以后应尽量避免使用getElementsByTagName(“div”)</p>
<img src="https://img-blog.csdnimg.cn/20210127142628701.jpg" width="60%">

<h3 id="不转化如何使用数组方法"><a href="#不转化如何使用数组方法" class="headerlink" title="不转化如何使用数组方法"></a>不转化如何使用数组方法</h3><p><strong>用call或apply：</strong></p>
<p>使用slice：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arrlike = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;box&quot;</span>);</span><br><span class="line">  <span class="comment">//比如，此时想对伪数组使用slice方法</span></span><br><span class="line">  <span class="keyword">var</span> arr = [].slice.call(arrlike,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrlike,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">var</span> arr = [].slice.apply(arrlike,[<span class="number">2</span>,<span class="number">5</span>]);</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.apply(arrlike,[<span class="number">2</span>,<span class="number">5</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(arr);</span><br><span class="line">  <span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用其他方法：<a href="https://juejin.cn/post/6844903730719129613#heading-0">在类数组中使用数组方法</a></p>
<p>我试图照猫画虎使用push()，但是一直在报错…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myul = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myul&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(arrlike,myul);</span><br></pre></td></tr></table></figure>
<p>这个地方先放着，我在网上查到的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// [1,2,3,4]/&#123; &#x27;0&#x27;: 1, &#x27;1&#x27;: 2, &#x27;2&#x27;: 3, &#x27;3&#x27;: 4 &#125;</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>但我照着写，发现还是失败了…</p>
<hr>
<p>3.10 我回来了，这样写就ok了，之前是没理解call</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> arrlike = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;box&quot;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> arr = [].slice.call(arrlike).concat(<span class="string">&quot;Danmo&quot;</span>)</span></span><br><span class="line"><span class="javascript">            <span class="comment">// arr.push(&quot;Danmo&quot;) 输出结果正常</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(arr)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以先将伪数组转化为数组，再使用push，但这样不符合“伪数组使用数组方法”的题意</p>
<hr>
<blockquote>
<p>请写出以下代码的日志结果</p>
</blockquote>
<p><a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">阮一峰——学习Javascript闭包（Closure）</a><br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021250770016">廖雪峰——闭包</a><br><em><strong>考点：闭包</strong></em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i++);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)();</span><br><span class="line">fn();</span><br><span class="line">fn();</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>输出结果是：1 2 3</p>
<p>fn的返回值是一个匿名函数（它是函数中的函数，即闭包），它调用了变量i，导致fn第一次调用后产生的i还留在内存中</p>
<h2 id="Final-Stage"><a href="#Final-Stage" class="headerlink" title="Final Stage"></a>Final Stage</h2><h3 id="let和暂时性死区"><a href="#let和暂时性死区" class="headerlink" title="let和暂时性死区"></a>let和暂时性死区</h3><blockquote>
<p>请描述let，const和var之间的区别，并解释暂时性死区的意义</p>
</blockquote>
<p>可参考：<br><a href="https://www.cnblogs.com/msth/p/8976813.html">let，const和var之间的区别</a><br><a href="https://es6.ruanyifeng.com/#docs/let">阮一峰的ES6教程</a></p>
<p>var：变量可重复声明，无块级作用域，存在变量提升<br>let：变量不能重复声明，存在块级作用域，不存在变量提升<br>const：声明必须赋初值，不能重复声明，值不能修改，块级作用域，不存在变量提升</p>
<p>暂时性死区：如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。<br><strong>在代码块内，使用let命令声明变量之前，该变量都是不可用的。</strong> 这在语法上，称为“暂时性死区”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>请写出使用XMLHttpRequest发送一个GET请求的代码</p>
</blockquote>
<h3 id="使用XMLHttpRequest发送一个GET请求"><a href="#使用XMLHttpRequest发送一个GET请求" class="headerlink" title="使用XMLHttpRequest发送一个GET请求"></a>使用XMLHttpRequest发送一个GET请求</h3><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/send">MDN</a><br>由于还没学ajax，暂时不能看懂</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 请求结束后,在此处写处理代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//XMLHttpRequest.send() 方法接受一个可选的参数，其作为请求主体；</span></span><br><span class="line"><span class="comment">//如果请求方法是 GET 或者 HEAD，则应将请求主体设置为 null</span></span><br></pre></td></tr></table></figure>

<p>5.12回来：现在能看懂了</p>
<p>AJAX的作用：不刷新页面，即可更新页面的一部分<br>以下GET请求的作用：点击按钮后，在框中显示“HELLO AJAX”</p>
<p>客户端：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">document</span>.getElementById(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://127.0.0.1:8000/server&#x27;</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">        result.innerHTML = xhr.response;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端（express）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/server&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.setHeader(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  res.send(<span class="string">&#x27;HELLO AJAX&#x27;</span>);  <span class="comment">//对应上方的xhr.response</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;服务已经启动，8000端口监听中&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="请求从客户端发出后的流转过程"><a href="#请求从客户端发出后的流转过程" class="headerlink" title="请求从客户端发出后的流转过程"></a>请求从客户端发出后的流转过程</h3><blockquote>
<p>请简单描述一个请求从客户端发送出去的流转过程</p>
</blockquote>
<p>参考：<a href="https://segmentfault.com/a/1190000022514313">一个HTTP请求的曲折经历</a></p>
<ul>
<li>输入URL后，会先进行域名解析</li>
<li>浏览器拿到服务器的IP地址后，会向它发送HTTP请求。HTTP请求经由一层层的处理、封装、发出之后，最终经由网络到达服务器，通过三次握手建立TCP连接，服务器接收到请求并开始处理</li>
<li>服务器构建响应，再经由一层层的处理、封装、发出后，到达客户端，浏览器处理请求</li>
<li>浏览器开始渲染页面，解析HTML，构建render树，根据render树的节点和CSS的对应关系，进行布局，绘制页面</li>
</ul>
<p>（现在理解并不深入，学过计网后再看一遍吧）</p>
<hr>
<h1 id="BY2018秋"><a href="#BY2018秋" class="headerlink" title="BY2018秋"></a>BY2018秋</h1><h2 id="Level-0-1"><a href="#Level-0-1" class="headerlink" title="Level 0"></a>Level 0</h2><blockquote>
<p>如何对⼀个整数乱序数组进⾏排序？请写出代码或简单思路</p>
</blockquote>
<p>选择排序和插入排序，之前的博客里有…这里先不写了，其他的排序方法还不是太熟悉…（简单的桶排序其实也可）</p>
<hr>
<blockquote>
<p>有如下的⼆维数据，请⽤最适当的数据结构进⾏描述并能够较好扩展，并⽤代码实现以下⽬的</p>
</blockquote>
<p>emm，涉及数据结构的题目啊，先放着</p>
<hr>
<h2 id="Level-1-1"><a href="#Level-1-1" class="headerlink" title="Level 1"></a>Level 1</h2><blockquote>
<ol>
<li>&lt; img&gt; 中⼀般都会有的属性是 () A. src B. alt C. title D. href</li>
</ol>
</blockquote>
<p>A</p>
<hr>
<blockquote>
<ol start="2">
<li>⿏标点击时超链接样式为 () A. a:link B. a:visited C. a:hover D. a: active</li>
</ol>
</blockquote>
<p>D</p>
<hr>
<blockquote>
<ol start="3">
<li>下⾯哪⼀个不是JavaScript基本类型 () A. symbol B. object C.array D. null</li>
</ol>
</blockquote>
<p>C</p>
<hr>
<h3 id="数组方法中的纯函数"><a href="#数组方法中的纯函数" class="headerlink" title="数组方法中的纯函数"></a>数组方法中的纯函数</h3><blockquote>
<ol start="4">
<li>（不定项）纯函数是⼀类没有副作⽤的函数，其输出结果只依赖其输⼊，以下关于 Array 的⽅法中你认为是纯函数的有哪些 () A. sort B. filter C. map D. reverse E. push F. pop G. every H. splice I. slice</li>
</ol>
</blockquote>
<p>CGI</p>
<p>这道题介绍了纯函数的概念，可参考博客：<br><a href="https://cloud.tencent.com/developer/article/1629653">JavaScript 数组纯函数</a><br><a href="https://juejin.cn/post/6844903614918459406">JS 数组详细操作方法及解析合集</a></p>
<p><a href="https://www.runoob.com/jsref/jsref-every.html">菜鸟教程——Array every方法</a><br>（some和every类似，只不过some只要有一个符合条件就会返回true，而every要求全部符合条件）</p>
<p><a href="https://www.runoob.com/jsref/jsref-map.html">菜鸟教程——Array map方法</a><br>（在原数组的基础上构建一个新数组）</p>
<p><strong>可以简单认为，对原数组没有影响的方法就是纯函数</strong></p>
<hr>
<h3 id="区分行内元素和块级元素"><a href="#区分行内元素和块级元素" class="headerlink" title="区分行内元素和块级元素"></a>区分行内元素和块级元素</h3><blockquote>
<ol start="5">
<li>请尽可能多的写出你知道的html元素标签，并区分⾏内元素与块级元素</li>
</ol>
</blockquote>
<p>这篇博客概括得极为全面：<a href="https://www.jianshu.com/p/e47569bc0705">行内元素和块级元素都有哪些</a></p>
<p>列举一些常见的块级元素和行内元素：<br>块级：div、nav、h1~h6、p、table、ul、ol、li、form<br>行内：a、span、i、em、img（易错）、input（易错）、br（易忽略）</p>
<hr>
<h3 id="列举css选择器"><a href="#列举css选择器" class="headerlink" title="列举css选择器"></a>列举css选择器</h3><blockquote>
<ol start="6">
<li>请尽可能多的写出你知道的css 选择器</li>
</ol>
</blockquote>
<p>可参考：<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">阮一峰——CSS选择器笔记</a><br>元素选择器、id选择器、类选择器、通配选择器、伪类选择器、复合选择器、交集选择器、并集选择器、子元素选择器、后代元素选择器、兄弟选择器、属性选择器（用得很少）</p>
<hr>
<h3 id="引用css的几种方法"><a href="#引用css的几种方法" class="headerlink" title="引用css的几种方法"></a>引用css的几种方法</h3><blockquote>
<ol start="7">
<li>请尽可能多的写出引⽤css的⼏种⽅法，并区分其优先级</li>
</ol>
</blockquote>
<p>内联样式：在标签内style=” : “，比如：&lt; body style=”background-color: gray”&gt;<br>内部样式表：不必多言<br>外部样式表：不必多言，link引入</p>
<p>优先级：!improtant &gt; 内联样式 &gt; 内部样式表 &gt; 外部样式表</p>
<hr>
<blockquote>
<ol start="8">
<li>请你写出合适的html、css，使⽤在(6)中写出的css 选择器来选择HTML元素，随意发挥</li>
</ol>
</blockquote>
<p>这题不想做Orz……</p>
<hr>
<h2 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h2><h3 id="变量作用域-内外变量重名"><a href="#变量作用域-内外变量重名" class="headerlink" title="变量作用域/内外变量重名"></a>变量作用域/内外变量重名</h3><blockquote>
<ol>
<li>请写出以下代码的运⾏结果：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">  <span class="keyword">var</span> a = a + <span class="number">1</span>; </span><br><span class="line">  <span class="built_in">console</span>.log(a); </span><br><span class="line">&#125; </span><br><span class="line">b();</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021187855808">廖雪峰——变量作用域与解构赋值</a></p>
<p>这篇博客里有句话值得关注：JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。<strong>如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</strong></p>
<p>对于这道题，由于外部函数和内部函数都定义了a，而且内部函数是用var定义的，存在变量提升，也就是说，内部函数在初始化的时候a就赋值为undefined了…</p>
<p>所以输出结果是：undefined NaN（这题考的确实巧妙）</p>
<hr>
<h3 id="对call和bind的深入理解"><a href="#对call和bind的深入理解" class="headerlink" title="对call和bind的深入理解"></a>对call和bind的深入理解</h3><blockquote>
<ol start="2">
<li>请说明以下输出的结果，并说明原因：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> maple = &#123;</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.baz; i++)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>,i);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar.bind(foo).call(maple);</span><br></pre></td></tr></table></figure>
<p>先了解一下什么是“严格模式”吧：<a href="https://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html">阮一峰——Javascript 严格模式详解</a></p>
<p>（严格模式下，有很重要的一条：禁止this关键字指向全局对象，菜鸟教程中说，在函数中，在严格模式下，this 是未定义的(undefined)）</p>
<p>我们回到这道题，输出结果为：</p>
<pre><code>foo对象
window对象
window对象
window对象
window对象
</code></pre>
<p>首先foo.bar.bind(foo)会把this值指定为foo，这个整体会成为新的函数<br>然后.call(maple)会调用这个新的函数，并再次把this值修改为maple（但实际上this的值还是为foo）</p>
<p>参考这篇博客：<a href="https://blog.csdn.net/zhouzuoluo/article/details/84935106">深入理解call、apply、bind（改变函数中的this指向）</a></p>
<p><font size="3" color="DodgerBlue">注意：一旦函数通过bind绑定了有效的this对象，那么在函数执行过程中this会指向该对象，即使使用call、apply也不能改变this的指向</font></p>
<p>关于计时器呢，可以看看这篇博客：<a href="https://www.jianshu.com/p/82824e5691de">Javascript定时器中的this指向</a></p>
<p><font size="3" color="DodgerBlue">如果没有特殊指向，setInterval和setTimeout的回调函数中this的指向都是window。这是因为JS的定时器方法是定义在window下的。</font></p>
<hr>
<h3 id="ES5实现find"><a href="#ES5实现find" class="headerlink" title="ES5实现find"></a>ES5实现find</h3><blockquote>
<ol start="3">
<li>请⽤ es5 的语法实现JavaScript数组的find⽅法：</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myfind = <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.length;i++)&#123;</span><br><span class="line">  <span class="comment">//误打误撞把this给用对了</span></span><br><span class="line">    <span class="keyword">if</span>(fun(<span class="built_in">this</span>[i]))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ages = [<span class="number">3</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAdult</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = ages.myfind(checkAdult);</span><br><span class="line"><span class="built_in">console</span>.log(foo);<span class="comment">//18</span></span><br><span class="line"><span class="comment">//测试后，和find的效果别无二致</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="undefined-和-not-defined"><a href="#undefined-和-not-defined" class="headerlink" title="undefined 和 not defined"></a>undefined 和 not defined</h3><blockquote>
<ol start="4">
<li>简述undefined和not defined的区别。</li>
</ol>
</blockquote>
<p>可参考：<a href="https://www.jianshu.com/p/eca505f12095">javaScript中not defined，undefined和null的区别</a></p>
<p>总结一下，区别就是：undefined表示定义但未赋值，而not defined表示没有定义。用var声明变量时存在变量提升，此时也只是先声明变量但不给变量赋值。</p>
<hr>
<h3 id="http-method，状态码"><a href="#http-method，状态码" class="headerlink" title="http method，状态码"></a>http method，状态码</h3><blockquote>
<ol start="5">
<li>你知道哪些 http method？返回状态码⾸位数字含义(1、2、3、4、5)。</li>
</ol>
</blockquote>
<ul>
<li>GET：用于请求服务器发送某个资源</li>
<li>HEAD：与 GET 方法的行为很类似，但服务器在响应中只返回首部，不会返回实体的主体部分，允许客户端在未获取实际资源的情况下，对资源的首部进行检查</li>
<li>POST：用于向服务器发送数据</li>
<li>PUT：用于向服务器上的资源(例如文件)中存储数据，比如写入文档</li>
<li>DELETE：请服务器删除请求 URL 所指定的资源</li>
<li>TRACE：主要用于诊断，用来查看代理和其他应用程序对用户请求所产生的效果</li>
</ul>
<p>返回状态码首位数字含义：<br>1**  信息。服务器收到请求，请继续执行请求<br>2**  成功。请求被成功接收并处理<br>3**  重定向。需要进一步操作来完成请求<br>4**  客户端错误。无法完成请求，或请求包含语法错误<br>5**  服务器错误。服务器在处理请求的过程中发成错误</p>
<hr>
<h3 id="发送POST请求"><a href="#发送POST请求" class="headerlink" title="发送POST请求"></a>发送POST请求</h3><blockquote>
<ol start="6">
<li>请⽤你喜欢的⽅式向 <code>https://google.com</code> 发送⼀个 POST 请求，在请求体上附带上 <code>hello google</code> 信息。</li>
</ol>
</blockquote>
<p>客户端：（还没解决跨域问题）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;https://google.com&#x27;</span>);</span><br><span class="line">  xhr.send(<span class="string">&#x27;hello google&#x27;</span>);</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3"></a>Level 3</h2><h3 id="浏览器缓存方法和区别"><a href="#浏览器缓存方法和区别" class="headerlink" title="浏览器缓存方法和区别"></a>浏览器缓存方法和区别</h3><blockquote>
<ol>
<li>简述浏览器缓存的多种⽅法及其区别（从时效、特性等出发）</li>
</ol>
</blockquote>
<p>参考博客：<a href="https://segmentfault.com/a/1190000020031339">简述浏览器端的九大缓存</a></p>
<ol>
<li><code>http缓存</code>是基于HTTP协议的浏览器文件级缓存机制，针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件</li>
<li><code>websql</code>这种方式只有较新的chrome浏览器支持，并以一个独立规范形式出现。它是将数据以数据库的形式存储在客户端，根据需求去读取。跟Storage的区别是： Storage和Cookie都是以键值对的形式存在的；Web Sql 更方便于检索，允许sql语句查询，让浏览器实现小型数据库存储功能</li>
<li><code>indexDB</code> 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API，一般用户保存大量用户数据并要求数据之间有搜索需要的场景</li>
<li><code>Cookie</code>一般网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）</li>
<li><code>Localstorage</code>html5的一种新的本地缓存方案，目前用的比较多，一般用来存储ajax返回的数据，加快下次页面打开时的渲染速度。不适合存放过多的数据</li>
<li><code>Sessionstorage</code>和localstorage类似，但是浏览器关闭则会全部删除，api和localstorage相同，实际项目中使用较少。</li>
<li><code>application cache</code> 是将大部分图片资源、js、css等静态资源放在manifest文件配置中，便于离线浏览网页</li>
<li><code>cacheStorage</code>是在ServiceWorker的规范中定义的，可以保存每个serverWorker申明的cache对象</li>
<li><code>flash缓存</code> 这种方式基本不用，这一方法主要基于flash有读写浏览器端本地目录的功能</li>
</ol>
<p>再看一篇：<a href="https://zhuanlan.zhihu.com/p/60950750">浏览器缓存看这一篇就够了</a></p>
<hr>
<h3 id="如何看待JS继承"><a href="#如何看待JS继承" class="headerlink" title="如何看待JS继承"></a>如何看待JS继承</h3><blockquote>
<ol start="2">
<li>你如何看待JavaScript ‘继承’？简要谈谈你的理解。</li>
</ol>
</blockquote>
<ul>
<li>继承可以让实例对象拥有其原型对象的属性和方法</li>
<li>实现继承的方式：原型链继承/使用构造函数继承</li>
<li>继承的应用：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了</li>
</ul>
<hr>
<blockquote>
<ol start="3">
<li>请写出以下内容的输出（环境限定为当前最新 lts 版 node, v8.12.0）</li>
</ol>
</blockquote>
<p>我希望再学一次event loop和promise，现在对异步JS编程的理解还是不够</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);  <span class="comment">// 同步代码 (1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">    <span class="attr">then</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error in foo&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;this is bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;time out&#x27;</span>);  <span class="comment">// timers阶段，执行setTimeout(6)</span></span><br><span class="line">&#125;, <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">res, rej</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;in promise&#x27;</span>);  <span class="comment">//同步代码 (2)</span></span><br><span class="line">    <span class="built_in">setTimeout</span>((<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">//由于res的执行被延迟了，所以直接执行rej</span></span><br><span class="line">        res(foo);</span><br><span class="line">        <span class="keyword">return</span> foo.bar;</span><br><span class="line">    &#125;)(), <span class="number">0</span>);</span><br><span class="line">    rej(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error in promise&#x27;</span>));  <span class="comment">//经测试，即便注掉这句，也不影响&#x27;error in foo&#x27;的输出</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;  <span class="comment">//不执行res，因此then中的代码不会生效</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get promise val&#x27;</span>);  </span><br><span class="line">    <span class="built_in">console</span>.log(o.value);</span><br><span class="line">&#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;  <span class="comment">//catch用于指定发生错误时的回调函数，和throw对应</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.message);  <span class="comment">//promise的then或catch，此处控制输出&#x27;error in foo&#x27; (5)</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;next tick&#x27;</span>);  <span class="comment">//遇到后event loop会停下来，立马执行，此处它会在第一个event loop开始之前执行 (4)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)  <span class="comment">//同步代码 (3)</span></span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<ol start="4">
<li>你了解哪些有趣的前端或者互联⽹历史</li>
</ol>
</blockquote>
<p>网景公司和微软公司的较量，第一二次浏览器大战</p>
<hr>
<h1 id="BY不知年份"><a href="#BY不知年份" class="headerlink" title="BY不知年份"></a>BY不知年份</h1><h2 id="不定项-选择题"><a href="#不定项-选择题" class="headerlink" title="(不定项)选择题"></a>(不定项)选择题</h2><blockquote>
<ol>
<li>选出下列四个选项中不是html标签的一项 A. tr B. td C. th D. tb</li>
</ol>
</blockquote>
<p>D</p>
<hr>
<blockquote>
<ol start="2">
<li>选出以下不为css属性的一项 A. font-­color B. margin C. text­-size D. z–index</li>
</ol>
</blockquote>
<p>我认为A和C都没有欸</p>
<hr>
<blockquote>
<ol start="3">
<li>以下哪项能获取到DOM中的第一个 元素？ A. document.getElementById(“test”) B. document.getElementsByClassName(“test”)[0] C. dom.getElementById(“test”) D. dom.getElementByClassName(“test”)[0]</li>
</ol>
</blockquote>
<p>B</p>
<hr>
<h3 id="JS字符串隐式转换"><a href="#JS字符串隐式转换" class="headerlink" title="JS字符串隐式转换"></a>JS字符串隐式转换</h3><blockquote>
<ol start="4">
<li>JavaScript: 2 + “1” + 2 = ? A. “23” B. 5 C. “5” D. “212”</li>
</ol>
</blockquote>
<p>D</p>
<p>‘+’两侧只要有一侧是字符串，另一侧的数字则会自动转换成字符串，因为其中存在隐式转换</p>
<hr>
<blockquote>
<ol start="5">
<li>JavaScript: 2 / 0 = ? A. 报错 B. 0 C. infinity</li>
</ol>
</blockquote>
<p>C</p>
<hr>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><blockquote>
<ol>
<li>css有几种选择器(写不出名字可直接上代码) </li>
<li>写出所有你能想到的方法，在网页上呈现出一个三角形</li>
</ol>
</blockquote>
<p>这两题做过了~</p>
<hr>
<blockquote>
<ol start="3">
<li>写出对元素实现绝对(水平，垂直)居中布局的方式</li>
</ol>
</blockquote>
<p>margin，position:absolute，transform，display:table-cell，vertical-align:center…上边也说过了</p>
<hr>
<h2 id="构造函数和普通函数的区别"><a href="#构造函数和普通函数的区别" class="headerlink" title="构造函数和普通函数的区别"></a>构造函数和普通函数的区别</h2><blockquote>
<ol start="4">
<li>指出以下两行代码的区别</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiahao = <span class="keyword">new</span> Person() </span><br><span class="line"><span class="keyword">var</span> xiahao = Person()</span><br></pre></td></tr></table></figure>
<p>第二种方式，仅仅是把函数Person的返回值赋值给xiahao；<br>而第一种方式，xiahao成为构造函数Person的一个实例对象</p>
<hr>
<h3 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h3><blockquote>
<ol start="5">
<li>写出常见的一些图片格式</li>
</ol>
</blockquote>
<p>参考：<a href="https://www.jianshu.com/p/919247bc36fe">常用的几种图片格式</a></p>
<p>jpg、png、gif、psd、webp（限于chrome）</p>
<p>图片的格式：</p>
<ul>
<li><p>jpeg(jpg)</p>
<ul>
<li>支持的颜色比较丰富，不支持透明效果，不支持动图</li>
<li>一般用来显示照片</li>
</ul>
<ul>
<li>gif</li>
</ul>
<ul>
<li>支持的颜色比较少，支持简单透明，支持动图</li>
<li>颜色单一的图片，动图</li>
</ul>
<ul>
<li>png</li>
</ul>
<ul>
<li>支持的颜色丰富，支持复杂透明，不支持动图</li>
<li>颜色丰富，复杂透明图片（专为网页而生）</li>
</ul>
<ul>
<li>webp</li>
</ul>
<ul>
<li>这种格式是谷歌新推出的专门用来表示网页中的图片的一种格式</li>
<li>它具备其他图片格式的所有优点，而且文件还特别的小</li>
<li>缺点：兼容性不好</li>
</ul>
<ul>
<li>base64 </li>
</ul>
<ul>
<li>将图片使用base64编码，这样可以将图片转换为字符，通过字符的形式来引入图片    </li>
<li>一般都是一些需要和网页一起加载的图片才会使用base64</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三栏等宽布局"><a href="#三栏等宽布局" class="headerlink" title="三栏等宽布局"></a>三栏等宽布局</h3><blockquote>
<ol start="6">
<li>用HTML和CSS实现一个简单的等宽三栏式布局</li>
</ol>
</blockquote>
<p>之前写的双栏等宽布局是可以的，不过我发现width写成百分比的形式好像更符合题意：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">33.33%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">box-shadow</span>: <span class="number">3px</span> <span class="number">3px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">3</span>);</span></span><br><span class="line"><span class="css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210129152635234.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMjM1NzM2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<h3 id="JS字符串逆序"><a href="#JS字符串逆序" class="headerlink" title="JS字符串逆序"></a>JS字符串逆序</h3><blockquote>
<ol start="7">
<li>如何用JavaScript将字符串“abcdefg”变成”gfedcba”</li>
</ol>
</blockquote>
<p><del>这题考到了sort方法呀 ←No，字符串和数组是不一样的，sort失败了…</del></p>
<p>参考博客：<br><a href="https://www.shuzhiduo.com/A/ZOJPYo3o5v/">JavaScript字符串逆序（2种方法）</a><br><a href="https://www.runoob.com/jsref/jsref-join.html">join方法</a></p>
<p>主要有如下两种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先将字符串用push存入一个数组，再将数组用join转化为字符串</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params"> str </span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> stack = [];<span class="comment">//生成一个栈</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> len = str.length,i=len;i&gt;=<span class="number">0</span>;i-- )&#123;</span><br><span class="line">    stack.push(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> stack.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字符串用split存入另一个数组，然后reverse，join一气呵成，干净利落（推荐）</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span>(<span class="params"> str </span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<ol start="8">
<li>请写出以下输出日志结果，并解释。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i) </span><br><span class="line">   &#125;, <span class="number">500</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.cnblogs.com/planetwithpig/p/12016231.html">JS中For循环中嵌套setTimeout()方法的执行顺序</a></p>
<p>结果：输出5次5<br>原因：定时器是一个<strong>异步函数</strong>，在执行它之前，先跑完for循环，所以定时器会在控制台输出5次5。</p>
<hr>
<blockquote>
<ol start="9">
<li>和2017年秋final stage前的那道题是一样的，考点为闭包</li>
</ol>
</blockquote>
<hr>
<h2 id="附加题"><a href="#附加题" class="headerlink" title="附加题"></a>附加题</h2><blockquote>
<ol>
<li>一个乱序数字数组长度为n，如[3,2,5,7…]，如何将该数组按由大到小排序?尽量用多种方式。（不熟悉JavaScript可以直接用高中的那种流程框图表达思路）</li>
</ol>
</blockquote>
<h3 id="JS由大到小排序"><a href="#JS由大到小排序" class="headerlink" title="JS由大到小排序"></a>JS由大到小排序</h3><p>传统的冒泡排序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//（4）[3，2，5，7]</span></span><br><span class="line">bubbleSort(array,array.length);<span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr,n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">var</span> t=arr[j];</span><br><span class="line">        arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>]=t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//（4）[2，3，5，7]</span></span><br></pre></td></tr></table></figure>
<p>传统的选择排序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array);  <span class="comment">//（4）[3，2，5，7]    </span></span><br><span class="line">selectSort(array,array.length);<span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">arr,n</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i,k=j+<span class="number">1</span>;k&lt;n;)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j]&lt;=arr[k])&#123;</span><br><span class="line">        <span class="keyword">var</span> min=j;</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> min=k;</span><br><span class="line">        j=k;</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> t=arr[i];</span><br><span class="line">    arr[i]=arr[min];</span><br><span class="line">    arr[min]=t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(array);<span class="comment">//（4）[2，3，5，7]</span></span><br></pre></td></tr></table></figure>
<p>使用JS特色的sort方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line">array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br></pre></td></tr></table></figure>
<hr>
<p><del>剩下几个聊天题就不做了</del></p>
<h1 id="BY2020春"><a href="#BY2020春" class="headerlink" title="BY2020春"></a>BY2020春</h1><h2 id="Level-0-2"><a href="#Level-0-2" class="headerlink" title="Level 0"></a>Level 0</h2><blockquote>
<ol>
<li>列举⾏内元素、块级元素各三个。</li>
</ol>
</blockquote>
<p>行内：a、span、img<br>块级：h1、p、div</p>
<hr>
<h3 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h3><blockquote>
<ol start="2">
<li>content-box 盒⼦模型结构如何？其与 border-box 有何区别？</li>
</ol>
</blockquote>
<ul>
<li>content-box：默认值，width和height设置内容区的大小，加上padding （内边距）、border（边框）后盒子可见框变大。</li>
<li>border-box：width和height设置可见框的大小，可见框大小固定，如果添加了padding和border会导致内容区变小。</li>
</ul>
<hr>
<h3 id="辨析单位"><a href="#辨析单位" class="headerlink" title="辨析单位"></a>辨析单位</h3><blockquote>
<ol start="3">
<li>px,em,rem,vw 分别作何解释？</li>
</ol>
</blockquote>
<p>参考博客：<a href="https://www.jianshu.com/p/82f02af17e78">px、em、rem、%、vw、vh、vm这些单位的区别</a></p>
<ul>
<li>px：pixel，像素，一张图片最小的一个点</li>
<li>em：1em=父元素的字体大小，如果自身的字体大小被定义，则1em=自身字体大小，默认下1em=16px</li>
<li>rem：1rem=根元素字体大小</li>
<li>vw：视窗宽度，1vw=视窗宽度1%，主要用于适配移动端</li>
</ul>
<hr>
<h3 id="display-none-和-visibility-hidden"><a href="#display-none-和-visibility-hidden" class="headerlink" title="display:none 和 visibility:hidden"></a>display:none 和 visibility:hidden</h3><blockquote>
<ol start="4">
<li>display:none 与 visibility:hidden 有何区别</li>
</ol>
</blockquote>
<p>参考博客：<a href="https://www.jianshu.com/p/da8e9fba48b7">visibility :hidden和display:none的区别</a></p>
<p>这篇博客说得很全面了，不过按我的经验，仅仅是：</p>
<ul>
<li>display:none 既不显示，还不占页面空间</li>
<li>visibility:hidden 不显示，但占页面空间</li>
</ul>
<hr>
<h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><blockquote>
<ol start="5">
<li>inline-block 的 vertical-align 属性默认是以下哪种对⻬？<br>middle 中线 baseline 基线 bottom 底线 top 顶线</li>
</ol>
</blockquote>
<p>当然是 baseline！</p>
<hr>
<blockquote>
<ol start="6">
<li>rgba() 和 opacity 的透明效果在应⽤上有何不同？</li>
</ol>
</blockquote>
<p>参考博客：<a href="https://segmentfault.com/a/1190000017790405">css透明度之rgba和opacity的区别及兼容</a></p>
<p>主要是作用对象和继承性不同：</p>
<ul>
<li>opacity作用于元素，以及元素内的所有的元素的透明度</li>
<li>而rgba()只作用于元素的颜色或其背景色，设置rgba透明的元素的子元素不会继承透明效果</li>
</ul>
<hr>
<h3 id="Doctype"><a href="#Doctype" class="headerlink" title="!Doctype"></a>!Doctype</h3><blockquote>
<ol start="7">
<li>简述 &lt;!Doctype&gt; 声明的作⽤。</li>
</ol>
<p>参考博客：<a href="https://www.jianshu.com/p/ce48b13a4e1e">HTML文件里开头的!Doctype有什么作用？</a></p>
</blockquote>
<p>&lt; !Doctype&gt;是文档类型声明，即告诉浏览器当前 HTML 是用什么版本编写的，使得浏览器以W3C的标准解析渲染页面，从而使该页面在所有浏览器中以相同的方式显示。</p>
<hr>
<h3 id="CSS继承"><a href="#CSS继承" class="headerlink" title="CSS继承"></a>CSS继承</h3><blockquote>
<ol start="8">
<li>分别列举出三种有继承性和没有继承性的css属性。</li>
</ol>
</blockquote>
<p>参考博客：<a href="https://www.jianshu.com/p/34044e3c9317">CSS有哪些属性可以继承？</a></p>
<p>有继承性：opacity，font-size，color（字体系列和文本系列的很多属性可以被继承）<br>无继承性：width，background-color，position（盒子模型、定位、背景属性都不能被继承）</p>
<hr>
<h3 id="前端实现动画"><a href="#前端实现动画" class="headerlink" title="前端实现动画"></a>前端实现动画</h3><blockquote>
<ol start="9">
<li>想要在前端实现动画，如何应对？写出尽可能多的途径。</li>
</ol>
</blockquote>
<p>参考博客：<a href="https://www.cnblogs.com/Renyi-Fan/p/9268657.html">前端实现动画的6种方式详解</a></p>
<p>在下不才，只遇到过三种，总结如下：</p>
<p>途径一：CSS3 transition过渡动画，不能实现独立的动画，只能在某个标签元素样式或状态改变时进行平滑的动画效果过渡，而不是马上改变。</p>
<p>途径二：CSS3 animation动画，通过对关键帧和循环次数的控制，页面标签元素会根据设定好的样式改变进行平滑过渡。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--一个简单的CSS3动画--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-id">#box1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/*width: 100px;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*height: 100px;*/</span></span></span><br><span class="line"><span class="css">        <span class="comment">/*background-color: #bfa;*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">        <span class="attribute">animation</span>: Ani1 <span class="number">2500ms</span> linear alternate infinite;</span></span><br><span class="line"><span class="css">        <span class="comment">/*注意中间用空格隔开，而不是逗号*/</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      </span></span><br><span class="line"><span class="css">      <span class="selector-id">#box1</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">animation</span>: Ani1 <span class="number">2500ms</span> linear alternate infinite paused;</span></span><br><span class="line"><span class="css">        <span class="comment">/*当鼠标放在box上时，停止动画*/</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      </span></span><br><span class="line"><span class="css">      <span class="keyword">@keyframes</span> Ani1&#123;</span></span><br><span class="line"><span class="css">        <span class="number">0%</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="number">50%</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">700px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">top</span>: <span class="number">350px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: orange;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="number">100%</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">left</span>: <span class="number">1300px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">top</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;        </span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>途径三：JS定时器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试创建一个可以执行简单动画的函数</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *   obj:要执行动画的对象</span></span><br><span class="line"><span class="comment"> *   attr:要执行动画的样式，比如：left top width height</span></span><br><span class="line"><span class="comment"> *   target:执行动画的目标位置</span></span><br><span class="line"><span class="comment"> *   speed:移动的速度(正数向右移动，负数向左移动)</span></span><br><span class="line"><span class="comment"> *  callback:回调函数，这个函数将会在动画执行完毕以后执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">obj, attr, target, speed, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//关闭上一个定时器</span></span><br><span class="line">  <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">  <span class="comment">//获取元素目前的位置</span></span><br><span class="line">  <span class="keyword">var</span> current = <span class="built_in">parseInt</span>(getStyle(obj, attr));</span><br><span class="line">  <span class="comment">//判断速度的正负值</span></span><br><span class="line">  <span class="comment">//如果从0 向 800移动，则speed为正</span></span><br><span class="line">  <span class="comment">//如果从800向0移动，则speed为负</span></span><br><span class="line">  <span class="keyword">if</span>(current &gt; target) &#123;</span><br><span class="line">    <span class="comment">//此时速度应为负值</span></span><br><span class="line">    speed = -speed;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开启一个定时器，用来执行动画效果</span></span><br><span class="line">  <span class="comment">//向执行动画的对象中添加一个timer属性，用来保存它自己的定时器的标识</span></span><br><span class="line">  obj.timer = <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//获取box1的原来的left值</span></span><br><span class="line">    <span class="keyword">var</span> oldValue = <span class="built_in">parseInt</span>(getStyle(obj, attr));</span><br><span class="line">    <span class="comment">//在旧值的基础上增加</span></span><br><span class="line">    <span class="keyword">var</span> newValue = oldValue + speed;</span><br><span class="line">    <span class="comment">//判断newValue是否大于800</span></span><br><span class="line">    <span class="comment">//从800 向 0移动</span></span><br><span class="line">    <span class="comment">//向左移动时，需要判断newValue是否小于target</span></span><br><span class="line">    <span class="comment">//向右移动时，需要判断newValue是否大于target</span></span><br><span class="line">    <span class="keyword">if</span>((speed &lt; <span class="number">0</span> &amp;&amp; newValue &lt; target) || (speed &gt; <span class="number">0</span> &amp;&amp; newValue &gt; target)) &#123;</span><br><span class="line">      newValue = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新值设置给box1</span></span><br><span class="line">    obj.style[attr] = newValue + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    <span class="comment">//当元素移动到0px时，使其停止执行动画</span></span><br><span class="line">    <span class="keyword">if</span>(newValue == target) &#123;</span><br><span class="line">      <span class="comment">//达到目标，关闭定时器</span></span><br><span class="line">      <span class="built_in">clearInterval</span>(obj.timer);</span><br><span class="line">      <span class="comment">//动画执行完毕，调用回调函数</span></span><br><span class="line">      callback &amp;&amp; callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义一个函数，用来获取指定元素的当前的样式</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> *     obj 要获取样式的元素</span></span><br><span class="line"><span class="comment"> *     name 要获取的样式名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj, name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.getComputedStyle) &#123;</span><br><span class="line">    <span class="comment">//正常浏览器的方式，具有getComputedStyle()方法</span></span><br><span class="line">    <span class="keyword">return</span> getComputedStyle(obj, <span class="literal">null</span>)[name];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//IE8的方式，没有getComputedStyle()方法</span></span><br><span class="line">    <span class="keyword">return</span> obj.currentStyle[name];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="BFC与高度塌陷详解"><a href="#BFC与高度塌陷详解" class="headerlink" title="BFC与高度塌陷详解"></a>BFC与高度塌陷详解</h3><blockquote>
<ol start="10">
<li>BFC是什么？请尽量简要地概括。</li>
</ol>
</blockquote>
<p><a href="https://www.bilibili.com/video/BV1aZ4y1M7gW?from=search&seid=9735049591623374848">b站视频：带你用最简单的方式理解最全面的BFC</a><br><a href="https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">前端精选文摘：BFC 神奇背后的原理（没有视频好理解）</a></p>
<p>BFC的全称为Box Formatting context，即块级格式化上下文。BFC可以看作元素的一种属性，当元素开启BFC时，它可以视作隔离了的独立容器，容器内的元素不会影响到外部的元素。</p>
<hr>
<blockquote>
<ol start="11">
<li>何为 float 流式布局？遇到元素塌陷如何解决？</li>
</ol>
</blockquote>
<p>将float属性设置为left或right，来实现在水平方向上的布局。</p>
<p>如果元素塌陷，两种方式解决：</p>
<ul>
<li>开启父元素的BFC（设置overflow:hidden），由于BFC布局规则：计算BFC的高度时，浮动元素也参与计算，所以父元素的高度不会塌陷。</li>
<li>使用伪类after，开启display:block，并且开启clear:both（我的理解是：display只要是块级元素，拥有上外边距的都可以，所以display:table也行，但是不能是inline-block，原因未知）</li>
</ul>
<p>clear的作用是清除浮动元素对该元素的影响，比如两个块元素本来应该垂直分布，期中A块开启了浮动（假设是left），则B块上移动，开启clear:left后，B不受影响，还在原先的位置。clear的实现原理，是浏览器为B添加了上外边距（不过检查不到），clear:both的作用是清除较大浮动元素的影响。</p>
<p>所以对after开启clear:both后，浏览器会把浮动元素的大小转换为相同大小的上外边距给after，就能撑起父元素了。</p>
<p>完善版.clearfix：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>:table;</span></span><br><span class="line"><span class="css">    <span class="attribute">clear</span>:both;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="响应式布局详解"><a href="#响应式布局详解" class="headerlink" title="响应式布局详解"></a>响应式布局详解</h3><blockquote>
<ol start="12">
<li>请列举你所知道的响应式布局⽅案，以及如何实现响应式。</li>
</ol>
</blockquote>
<p>可参考博客：<br><a href="https://juejin.cn/post/6844903814332432397">前端响应式布局原理与方案（详细，推荐）</a><br><a href="https://segmentfault.com/a/1190000019208652">响应式布局的实现</a></p>
<ol>
<li>媒体查询：先完成非响应式布局，即页面宽度是固定大小的。在完成了非响应式后，可以通过添加媒体查询（Media Query)和响应式代码实现响应式特性。</li>
</ol>
<p>一段典型的媒体查询代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">       <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">500px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">700px</span>)&#123;</span></span><br><span class="line"><span class="css">           <span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="css">              <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css">           &#125;</span></span><br><span class="line"><span class="css">       &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<ol start="2">
<li>百分比布局：通过百分比单位，可以使得浏览器中组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果。</li>
</ol>
<p>参考博客：<a href="https://segmentfault.com/a/1190000012707337">前端小知识–为什么你写的height:100%不起作用？</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">html</span>,<span class="selector-tag">body</span></span></span><br><span class="line"><span class="css">      <span class="comment">/*注意需要同时设置根元素和body元素*/</span></span></span><br><span class="line"><span class="css">      &#123; </span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      &#125; </span></span><br><span class="line"><span class="css">      <span class="selector-id">#box1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="comment">/*background-color: red;*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: space-around;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#box2</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="comment">/*宽度固定，这样视口缩小时，box2间的距离减小*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<center>
    <img src="https://img-blog.csdnimg.cn/20210203114745279.jpg" width="70%">
    <br>
    <font size face="楷体" color="#999">窗口较大时</font>
</center>

<center>
    <img src="https://img-blog.csdnimg.cn/20210203114751477.jpg" width="70%">
    <br>
    <font size="3" face="楷体" color="#999">窗口变小时</font>
</center>

<hr>
<ol start="3">
<li>vw和rem结合布局：将根元素的font-size用vw设置，其他元素的单位都用rem。rem单位都是相对于根元素的font-size来决定大小的，当页面的视口大小发生变化时，vw的值改变，那么以rem为固定单位的元素的大小也会发生响应的变化。<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">html</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">         * 一般在适配移动端时，为了得到一个较好的浏览效果，</span></span></span><br><span class="line"><span class="comment"><span class="css">         * css像素要对应2或3个物理像素，对应的视口大小为750px或1125px</span></span></span><br><span class="line"><span class="comment"><span class="css">         * 此处以750px为例：1vw=7.5px =&gt;1px=0.1333vw =&gt;100px=13.33vw</span></span></span><br><span class="line"><span class="comment"><span class="css">         * 则设置根元素font-size:13.33vw</span></span></span><br><span class="line"><span class="comment"><span class="css">         * (根元素无法设置小于12px的字体，所以无法使用10px=1.333vw)</span></span></span><br><span class="line"><span class="comment"><span class="css">         * 其他元素的大小都用rem设置，1rem=100px</span></span></span><br><span class="line"><span class="comment"><span class="css">         * 这个大小，在全屏的浏览器窗口下，测出的宽度为255/1.25=204px</span></span></span><br><span class="line"><span class="comment"><span class="css">         */</span></span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="css">         * 如果想要在分辨率1920x1080电脑的浏览器中得到正确的100px，</span></span></span><br><span class="line"><span class="comment"><span class="css">         * 则设置font-size:13.33*100/204=6.534vw</span></span></span><br><span class="line"><span class="comment"><span class="css">         */</span></span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">13.33vw</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-id">#box1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<ol start="4">
<li>图片响应式：窗口拉伸时图片等比放大（最大不超过自身大小），窗口压缩时图片等比缩小<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-id">#img-wrapper</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/*border: 10px solid red;*/</span></span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">        <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">img</span>&#123;</span></span><br><span class="line"><span class="css">          <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">          <span class="attribute">max-width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">          <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="css">          <span class="comment">/*height不设置auto也可，因为auto是默认值*/</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;img-wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../picture/6.jpg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h3><blockquote>
<p>（补充）如何实现Grid布局？</p>
</blockquote>
<p>参考博客：<a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">CSS Grid 网格布局教程（阮一峰）</a>（以后看）</p>
<hr>
<h3 id="瀑布流"><a href="#瀑布流" class="headerlink" title="瀑布流"></a>瀑布流</h3><blockquote>
<p>（补充）如何实现瀑布流？</p>
</blockquote>
<p>参考博客：<a href="https://juejin.cn/post/6844903520680804360">纯CSS实现瀑布流布局</a>（以后看）</p>
<hr>
<blockquote>
<ol start="13">
<li>读代作画（不做）</li>
</ol>
</blockquote>
<hr>
<h3 id="text-align和vertical-align"><a href="#text-align和vertical-align" class="headerlink" title="text-align和vertical-align"></a>text-align和vertical-align</h3><blockquote>
<ol start="14">
<li>请补全以下代码，使之呈现下图。(代码中圆圈序号为填空部分，其中有⼀个为⾮必填）</li>
</ol>
</blockquote>
<center>
    <img src="https://img-blog.csdnimg.cn/20210203184633754.jpg" width=" 50%">
    <br>
    <font size="3" face="楷体" color="#999"></font>
</center>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: black;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">20px</span> solid /*①*/ yellow;</span></span><br><span class="line"><span class="css">        <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">        <span class="attribute">vertical-align</span>: /*②*/ middle;</span></span><br><span class="line"><span class="css">        <span class="comment">/*上方这句可有可无，②为非必填项*/</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.big</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.inline</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="css">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: solid <span class="number">4px</span> blue;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: /*③*/ inline-block;</span></span><br><span class="line"><span class="css">        <span class="comment">/*④*/</span><span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">        <span class="comment">/*text-align应写在父元素中，而vertical-align应写在子元素中*/</span></span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inline big&quot;</span>&gt;</span>这是盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inline&quot;</span>&gt;</span>这是盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h2><blockquote>
<ol>
<li>请写代码实现:如何在不影响 let arr = [1,2,3,4,5] 的条件下，为数组添加⼀个新元素6， 并赋值给 arr1 。</li>
</ol>
</blockquote>
<p>一道简单的考察常见数组方法的题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//最简朴的做法：</span></span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">let</span> arr1 = [];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    arr1[i]=arr[i];</span><br><span class="line">    <span class="comment">//或arr1.push(arr[i]);</span></span><br><span class="line">  &#125;</span><br><span class="line">  arr1[arr.length]=<span class="number">6</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(arr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">  <span class="comment">/*以下四行，只要有任意一行即可*/</span></span><br><span class="line">  <span class="keyword">let</span> arr1 = <span class="built_in">Array</span>.prototype.slice.apply(arr);</span><br><span class="line">  <span class="keyword">let</span> arr1 = [].slice.call(arr); </span><br><span class="line">  <span class="keyword">let</span> arr1 = arr.slice();</span><br><span class="line">  <span class="keyword">let</span> arr1 = arr.slice(<span class="number">0</span>,arr.length); </span><br><span class="line">  </span><br><span class="line">  arr1.push(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(arr1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="window-onload的灾难"><a href="#window-onload的灾难" class="headerlink" title="window.onload的灾难"></a>window.onload的灾难</h3><blockquote>
<ol start="2">
<li>请在合适的⾏尾写出输出结果，并注释原因。</li>
</ol>
</blockquote>
<p>抄代码的时候把代码抄进window.onload了，引发了灾难，参考博客：<br><a href="http://liveipool.com/blog/2017/02/25/window-onload/">window.onload 函数引发的血案</a></p>
<p>如果不加var，即便在window.onload之内声明，变量都为顶层（全局）变量；而var声明的就成了局部变量，所以window.a才为undefined。</p>
<p>第一版代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//如果去掉var，输出结果会变成2 1 1 undefined 2</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>:foo</span><br><span class="line">  &#125;</span><br><span class="line">  obj.foo();<span class="comment">//2</span></span><br><span class="line">  foo();<span class="comment">//undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span>.a);<span class="comment">//undefined</span></span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">new</span> foo();<span class="comment">//undefined</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *注意：new的时候把原函数执行了一次</span></span><br><span class="line"><span class="comment">   *此时this.a就是c.a，由于c的a未定义，</span></span><br><span class="line"><span class="comment">   *沿着原型链找回去，foo的a也未定义，所以输出undefined</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">const</span> d = <span class="built_in">Object</span>.create(obj);</span><br><span class="line">  <span class="comment">//使用create方法，d是obj的实例对象</span></span><br><span class="line">  d.foo();<span class="comment">//2</span></span><br><span class="line">  <span class="comment">//d的a未定义，但沿原型链可以找到obj.a=2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原题代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br><span class="line"><span class="comment">//2，foo作为obj的方法调用时，this指向obj</span></span><br><span class="line">foo();</span><br><span class="line"><span class="comment">//1，this指向window</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo();<span class="comment">//undefined</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *注意：new的时候把原函数执行了一次</span></span><br><span class="line"><span class="comment"> *此时this.a就是c.a，由于c的a未定义，</span></span><br><span class="line"><span class="comment"> *沿着原型链找回去，foo也是一个对象，foo的a未定义，</span></span><br><span class="line"><span class="comment"> *所以输出undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">Object</span>.create(obj);</span><br><span class="line"><span class="comment">//使用create方法，d是obj的实例对象</span></span><br><span class="line">d.foo();<span class="comment">//2</span></span><br><span class="line"><span class="comment">//d的a未定义，但沿原型链可以找到obj.a=2</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="变量与函数同名"><a href="#变量与函数同名" class="headerlink" title="变量与函数同名"></a>变量与函数同名</h3><blockquote>
<ol start="3">
<li>写出输出结果并说明原因。</li>
</ol>
<p>参考回答：<a href="https://segmentfault.com/q/1010000003951963">js变量与函数同名</a></p>
</blockquote>
<p>有如下原则：</p>
<ul>
<li>函数声明比变量声明更提前</li>
<li>变量只是提前声明，还在原来的位置赋值</li>
<li>变量只能声明一次，再次声明无效（如果再次赋值则会覆盖）</li>
<li>标识符a的值取决于最后一次赋的值（如果a为函数，其后再声明并赋值为变量，则a的值为变量的值，如果只声明不赋值，则a还是函数）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;aoe&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以上代码等价于：</span></span><br><span class="line"><span class="comment">function a()&#123;</span></span><br><span class="line"><span class="comment">  console.log(&#x27;aoe&#x27;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">var a;</span></span><br><span class="line"><span class="comment">var a;(无效)</span></span><br><span class="line"><span class="comment">a = 10；</span></span><br><span class="line"><span class="comment">console.log(a);//10</span></span><br><span class="line"><span class="comment">//如果没有a=10，则输出结果为函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<ol start="4">
<li>下⾯两个 for 语句的结果有何不同？为什么？</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;<span class="comment">// 3 3 3</span></span><br><span class="line"><span class="comment">// var声明的i为全局变量，循环结束执行定时器时，i的值已经变为3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;<span class="comment">// 0 1 2</span></span><br><span class="line"><span class="comment">// let声明的i存在块级作用域，每一轮给计时器绑定一个不同的i</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Level-2-2"><a href="#Level-2-2" class="headerlink" title="Level 2"></a>Level 2</h2><p><del>Node.js不会，做不了</del></p>
<hr>
<h3 id="判断是否处于node环境"><a href="#判断是否处于node环境" class="headerlink" title="判断是否处于node环境"></a>判断是否处于node环境</h3><blockquote>
<p>node.js 是什么？如何判断⾃⼰是否处于 node 环境中？</p>
</blockquote>
<p>node.js是运行在服务器端的javascript，它不是一种新的语言，而是js的一种运行环境</p>
<p>由于node中不包括DOM，通过判断全局对象是否为window，如果不为window，则当前脚本运行在node.js环境中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span> === <span class="built_in">window</span> ? <span class="built_in">console</span>.log(<span class="string">&#x27;browser&#x27;</span>) : <span class="built_in">console</span>.log(<span class="string">&#x27;node&#x27;</span>);</span><br></pre></td></tr></table></figure>




<h3 id="node-js运行模型"><a href="#node-js运行模型" class="headerlink" title="node.js运行模型"></a>node.js运行模型</h3><hr>
<blockquote>
<p>请按照⾃⼰的理解，描述 node.js 的运⾏模型。</p>
</blockquote>
<p>参考博客：<br><a href="https://www.jianshu.com/p/625339a4dd7c">Node.js 运行机制：Event Loop</a></p>
<p>事件循环模型 <code>Event Loop</code>：</p>
<ul>
<li>node的执行可以分为两个阶段：初始化代码阶段、事件循环</li>
<li>在初始化代码阶段，执行所有的同步操作代码（包含绑定dom事件监听、设置定时器、发送ajax请求的代码），永远一步步执行。</li>
<li>在执行完所有同步代码以后，进入<code>事件循环</code>。在事件循环里的每一个阶段都查看该阶段的任务队列是否为空，如果不为空则尝试同步执行（以先进先出顺序一个一个执行）所有队列里的任务直到队列为空。如果回调队列为空且没有需要等待完成的异步操作，这个 Node.js 进程就结束了。</li>
</ul>
<h3 id="module-export-与-exports"><a href="#module-export-与-exports" class="headerlink" title="module.export 与 exports"></a>module.export 与 exports</h3><hr>
<blockquote>
<p>在 node.js 中， module.export 与 exports 有何区别？</p>
</blockquote>
<ul>
<li>module.export可以实现导出单个成员，而exports导出整个对象，通过exports.xxx来访问每个成员</li>
<li>node在模块内加了一句：exports = modules.exports。也就是说，exports和modules.exports指向堆内存中的同一块区域，由引用数据类型的相关知识点可知，通过exports可以修改modules.exports，<strong>但最后返回的是modules.exports</strong>，所以如果直接对modules.exports赋值，比如modules.exports = “Bingyan”，它就不会指向原先的区域，而指向另一块区域，从而可以导出单个成员。</li>
</ul>
<hr>
<h3 id="setImmediate和setTimeOut"><a href="#setImmediate和setTimeOut" class="headerlink" title="setImmediate和setTimeOut"></a>setImmediate和setTimeOut</h3><blockquote>
<p>写出以下代码在 node 环境中的输出。</p>
</blockquote>
<p>参考博客：<a href="https://juejin.cn/post/6844904100195205133#comment">setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop(强推)</a></p>
<p>这题和原先一道浏览器下的js题目很像，多考了setImmediate和setTimeout的先后顺序问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> maple = &#123;</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">baz</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maple.baz; i++) &#123;</span><br><span class="line">      setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.baz; i++)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar.bind(foo).call(maple);</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; baz: 4, bar: [Function: bar] &#125;</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>解析：<br>node.js的Event Loop是分阶段的：timers、pending callbacks、idle/prepare、poll、check、close callbacks，其中setTimeout在timers阶段，而setImmediate在check阶段。在同步任务执行完成，开始执行异步任务的时候，由于setImmediate在上，且pending callbacks、idle/prepare、poll等队列都是空的，直接到check阶段，由主线程执行setImmediate中的代码，再到下一个事件循环，到timers阶段，由主线程执行setTimeout中的代码。</p>
<p>如果把setImmediate和setTimeout反过来写，则可能先进行前者，也可能先执行后者。因为会直接到timers阶段，只要此时时间到了1ms，就执行setTimeout（没到1ms就到下一个循环的timers阶段），然后到check阶段，执行setImmediate。</p>
<hr>
<h2 id="Level-3-2"><a href="#Level-3-2" class="headerlink" title="Level 3"></a>Level 3</h2><p><del>做不了</del> 我觉得自己还可以抢救一下</p>
<blockquote>
<p>阅读理解：请先通读⽂档：<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/%EF%BC%8C%E5%9B%9E%E7%AD%94%E4%BB%A5%E4%B8%8B%E9%97%AE%E9%A2%98%EF%BC%9A">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/，回答以下问题：</a></p>
</blockquote>
<h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate"></a>setImmediate</h3><blockquote>
<ol>
<li>为什么下⾯这段代码中的 setImmediate ⼀定先执⾏？</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line">fs.readFile(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>node.js的Event Loop是分阶段的：timers、pending callbacks、idle/prepare、poll、check、close callbacks，其中setTimeout在timers阶段，而setImmediate在check阶段。在同步任务执行完成，开始执行异步任务的时候，由于代码都写在fs.readFile的函数中，readFile属于I/O操作，会直接跳到poll阶段，poll结束后到了check阶段，执行setImmediate中的代码，然后到下一次循环的timers阶段，执行setTimeout中的代码</p>
<hr>
<blockquote>
<ol start="2">
<li>上⾯⼀段代码中， setTimeout 存在第⼆个参数，这个参数默认为多少？</li>
</ol>
</blockquote>
<p>默认是0，但node.js限制setTimeout时间的最小值为1ms，所以会被强制改为1ms</p>
<hr>
<h3 id="process-nextTick-与-setImmediate"><a href="#process-nextTick-与-setImmediate" class="headerlink" title="process.nextTick() 与 setImmediate()"></a>process.nextTick() 与 setImmediate()</h3><blockquote>
<ol start="3">
<li>process.nextTick() 与 setImmediate() 有何区别？</li>
</ol>
</blockquote>
<p>SetImmediate()属于check阶段，而process.nextTick是一个特殊的异步API，他不属于任何的Event Loop阶段。</p>
<p>Node在遇到这个API时，Event Loop根本就不会继续进行，会马上停下来执行process.nextTick()，这个执行完后才会继续Event Loop。</p>
<hr>
<blockquote>
<ol start="4">
<li>写出下⾯代码的执⾏结果并说明理由。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setImmediate&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">    setImmediate(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;nextImmediate&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise.then&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>先执行console.log(‘promise.then’)，它是同步代码</li>
<li>然后执行console.log(‘nextTick’)</li>
<li>接着console.log(‘setImmediate’)</li>
<li>最后console.log(‘nextImmediate’)</li>
</ul>
<p>一定要记住，同步代码最先执行，console.log(‘setImmediate’)比console.log(‘nextImmediate’)先进入任务队列</p>
<hr>
<p><del>2.4 刷题暂告一段落，感到H5/CSS/JS有了一定提升。</del><br><del>继续学习ES6和Git，练习做网页吧，Node和计网不着急。</del></p>
<p>3.10 从现在开始，补上一部分以前没做的题</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="去掉数组中的重复性数据"><a href="#去掉数组中的重复性数据" class="headerlink" title="去掉数组中的重复性数据"></a>去掉数组中的重复性数据</h2><p>参考博客：<a href="https://segmentfault.com/a/1190000016418021">JavaScript数组去重</a></p>
<ol>
<li>两层循环法</li>
</ol>
<p>这段代码性能或许不好，因为我拿它对下一段代码中的原始数组去重时，浏览器说内存不足，无法打开网页</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 1.创建一个新数组,把原数组中的第一个元素插入到新数组中</span></span><br><span class="line"><span class="comment">   * 2.遍历原数组中的每一个元素分别和新数组中的每一个元素进行比较</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">//原数组</span></span><br><span class="line">  <span class="keyword">var</span> arr = [<span class="number">8</span>,<span class="number">11</span>,<span class="number">20</span>,<span class="number">5</span>,<span class="number">20</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">8</span>];</span><br><span class="line">  <span class="comment">// 新数组</span></span><br><span class="line">  <span class="keyword">var</span>  t = [];<span class="comment">//var  t = [8,11];</span></span><br><span class="line">  t[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">//arr中的每个元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="comment">//t中的每个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>;k&lt;t.length;k++)&#123;</span><br><span class="line">      <span class="comment">//当原数组中的值和新数组中的值相同的时候,就没有必要再继续比较了,跳出内循环</span></span><br><span class="line">      <span class="keyword">if</span>(t[k] == arr[i])&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//拿原数组中的某个元素比较到新数组中的最后一个元素还没有重复</span></span><br><span class="line">      <span class="keyword">if</span>(k == t.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//将数据插入新数组</span></span><br><span class="line">        t.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(t);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;         </span><br><span class="line">                <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">                    arr.splice(j,<span class="number">1</span>);</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line">    <span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]     </span></span><br></pre></td></tr></table></figure>
<p>NaN和{}没有去重，两个null直接消失了</p>
<ol start="2">
<li><p>indexOf法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.indexOf(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</span></span><br><span class="line">            array.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;true&#x27;</span>, <span class="string">&#x27;true&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]  </span></span><br></pre></td></tr></table></figure>
<p>NaN、{}没有去重</p>
</li>
<li><p>利用sort()</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr = arr.sort()</span><br><span class="line">    <span class="keyword">var</span> arrry= [arr[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//排列好后，只需要一层循环就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] !== arr[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            arrry.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrry;</span><br><span class="line">&#125;</span><br><span class="line">     <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">        <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">// [0, 1, 15, &quot;NaN&quot;, NaN, NaN, &#123;…&#125;, &#123;…&#125;, &quot;a&quot;, false, null, true, &quot;true&quot;, undefined]     </span></span><br></pre></td></tr></table></figure>
<p>NaN、{}没有去重</p>
<ol start="4">
<li><p>利用filter() + indexOf</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item, <span class="number">0</span>) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">        <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>
<p>NaN不见了，{}没有去重</p>
</li>
<li><p>利用hasOwnProperty()<br>解释一下unique函数的原理：<br>一开始obj.hasOwnProperty(typeof item + item)必然为false，这样会执行冒号后的语句，即使得(obj[typeof item + item] = true)，当出现重复元素时，判断obj.hasOwnProperty(typeof item + item)为true，执行冒号前的语句，给filter函数返回false，就能筛选了<br>之所以是typeof item + item，是为了区分数字和字符串：</p>
<blockquote>
<p>因为object的key是string类型的，无论你传入什么，他都会解析成字符串(symbol和Map等新特性除外)，所以这就导致了数字1和字符串1，他在object中的key是相同的，而你应该不想把他们当成相同的数据给去除掉。所以这里使用了typeof来简单判断了下类型。</p>
</blockquote>
</li>
</ol>
<p>不用觉得typeof item + item很奇怪，只要明白，每个元素对应的 typeof item + item 都是不同的，只要它能起到标识每一个元素的作用，那么就足够了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">        <span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;]   //所有的都去重了</span></span><br></pre></td></tr></table></figure>
<p>全部实现去重</p>
<ol start="6">
<li>ES6 Set法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以这样写：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">  <span class="comment">//from()方法的作用是生成数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最简化的写法：</span></span><br><span class="line">[...new <span class="built_in">Set</span>(arr)] </span><br></pre></td></tr></table></figure>
缺陷：无法去除{}空对象</li>
</ol>
]]></content>
      <categories>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>前端刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 模板与STL</title>
    <url>/2021/08/22/26.c++%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/</url>
    <content><![CDATA[<h1 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h1><h2 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h2><p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h2 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h2><ul>
<li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li>
</ul>
<ul>
<li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li>
</ul>
<h3 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h3><p>函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替，推荐用class</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用模板实现交换</span></span><br><span class="line">  <span class="comment">//1、自动类型推导</span></span><br><span class="line">  <span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、显示指定类型</span></span><br><span class="line">  mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h3 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h3><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T，才可以使用</li>
</ul>
<ul>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">  <span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//func();    //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">  func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h3 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h3><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span> </span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[max] &lt; arr[j]) &#123;</span><br><span class="line">        max = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">      <span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//测试char数组</span></span><br><span class="line">  <span class="keyword">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(charArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>);</span><br><span class="line">  <span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">  <span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//测试int数组</span></span><br><span class="line">  <span class="keyword">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(intArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">  <span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">  <span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h3><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">  myAdd02&lt;<span class="keyword">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
</blockquote>
<h3 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h3><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span>&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">  <span class="comment">// 注意：如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">  myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">  <span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">  <span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="comment">//如果调用普通函数，存在隐式类型转换，而函数模板不需要，所以模板的匹配性更好</span></span><br><span class="line">  <span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h3 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h3><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显式具体化的原型和定义以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">  <span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">  <span class="keyword">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h2 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h2><h3 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h3><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">  Person&lt;string, <span class="keyword">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">  P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h3 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h3><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mAge = age; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">  Person &lt;string ,<span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表，可以指定默认参数</span></span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h3 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyClass&lt;Person1&gt; m;</span><br><span class="line">  </span><br><span class="line">  m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h3 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h3><p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//参数变为了T1，T2，即参数模板化了，为了让编译器认识T1和T2，上边添加模板的语法</span></span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;	<span class="comment">//typeid(...).name()可以查看类型的名称，string类型的输出很长</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">//int类型只输出int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">  <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line">  <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型（第二三种 类模板配合函数模板，过于复杂）</li>
</ul>
<h3 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h3><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son2</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h3 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//成员函数类内声明</span></span><br><span class="line">  <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T1 m_Name;</span><br><span class="line">  T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> </span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123; <span class="comment">//模板参数列表&lt;T1,T2&gt;不能少</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123; <span class="comment">//模板参数列表&lt;T1,T2&gt;不能少</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h3 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h3><p>问题：当源文件引入test.h（声明），test.cpp（实现）也引入test.h时，编译运行时报错</p>
<p>原因：类模板中成员函数创建时机是在调用阶段，源文件只引入了.h文件，而.h文件不会去调用.cpp文件</p>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件（不常用）</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">//防止头文件重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T1 m_Name;</span><br><span class="line">  T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将声明和实现写在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person&lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h3 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h3><p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现复杂且不常用，不作记录</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="comment">//1、全局函数配合友元 类内实现</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T1 m_Name;</span><br><span class="line">  T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h1><h2 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h2><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
</li>
</ul>
<h2 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h2><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h2 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h2><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h2 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h2><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>  <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>  <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h2 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h2><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h3 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h3><p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="comment">//向容器中放数据</span></span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">  <span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">  <span class="comment">//v.end() 返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">  <span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一种遍历方式：</span></span><br><span class="line">  <span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">    cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">    pBegin++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二种遍历方式：</span></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第三种遍历方式：</span></span><br><span class="line">  <span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint); <span class="comment">//MyPrint是回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h3><blockquote>
<p>小技巧：迭代器可以视作指针，以==vector<Person>::iterator it==为例，&lt;&gt;内的部分是*it得到的数据类型</Person></p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">//由&lt;Person&gt;可知，*it得到的数据类型是Person</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">//由&lt;Person*&gt;可知，*it得到的数据类型是Person*，所以之后还要用-&gt;访问属性</span></span><br><span class="line">    Person * p = (*it);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h3><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">    v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">    v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">  v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">//由&lt;vector&lt;int&gt;&gt;可知，*it得到的数据类型是vector&lt;int&gt;，所以之后还要进行一轮迭代</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">      cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h1><h2 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h2><h3 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h3><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h3 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h3><p>构造函数原型：</p>
<ul>
<li><code>string();</code>                            创建一个空的字符串 例如: string str;</li>
<li><code>string(const char* s);</code>         使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>   使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>         使用n个字符c初始化 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c语言风格string转换成了string</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>; <span class="comment">//10个a字符</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h3><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>          把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                       字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                 把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>       把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>               把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str1;</span><br><span class="line">  str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str2;</span><br><span class="line">  str2 = str1;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str3;</span><br><span class="line">  str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str4;</span><br><span class="line">  str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str5;</span><br><span class="line">  str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str6;</span><br><span class="line">  str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str7;</span><br><span class="line">  str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                    重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                  重载+=操作符</li>
<li><code>string&amp; append(const char *s); </code>                             把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                   把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>   字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">  str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">  str1 += str2;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">  str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">  str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="comment">//str3.append(str2);</span></span><br><span class="line">  str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                    查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>                从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                      查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>         查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>               查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>               从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                     查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>          替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>); <span class="comment">//rfind是从字符串右侧开始找的</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">//7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//替换</span></span><br><span class="line">  string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">  str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl; <span class="comment">//a1111efgde</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h3 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h3><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回   0</p>
<p>&gt; 返回   1 </p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>    与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>       与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h3 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h3><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>      通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                  通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字符修改</span></span><br><span class="line">  str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h3 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>          插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                   删除从Pos开始的n个字符 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h3 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h3><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">  string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">  string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos); <span class="comment">//获取用户名</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h2 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h2><h3 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h3><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/08/24/hFMYdA.jpg" alt="说明: 2015-11-10_151152"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h3 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>                           采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>      将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                      构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>        拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">v2</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v3);</span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">v4</span>(v3);</span><br><span class="line">  <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h3 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&amp; operator=(const vector &amp;vec);</code>   重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>       将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>        将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;   <span class="comment">//无参构造</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">  v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">  v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h3 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty(); </code>                      判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>                  容器的容量</p>
</li>
<li><p><code>size();</code>                        返回容器中元素的个数</p>
</li>
<li><p><code>resize(int num);</code>           重新指定容器的长度为num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
<li><p><code>resize(int num, elem);</code>  重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="keyword">if</span> (v1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resize 重新指定大小，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">  v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resize 重新指定大小，若指定的更小，超出部分元素被删除</span></span><br><span class="line">  v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h3 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                                  尾部插入元素ele</li>
<li><code>pop_back();</code>                                                        删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>                          迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>            迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                                   删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>   删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                             删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  <span class="comment">//尾插</span></span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="comment">//尾删</span></span><br><span class="line">  v1.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">  v1.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear  </li>
</ul>
<h3 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     返回索引idx所指的数据</li>
<li><code>operator[]; </code>       返回索引idx所指的数据</li>
<li><code>front(); </code>           返回容器中第一个数据元素</li>
<li><code>back();</code>             返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h3 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
<li>实现内存收缩（见代码）</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>   将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//互换容器</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">  v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//收缩内存：有时vector的容量很大，当使用resize将它的大小变得很小时，浪费了容量</span></span><br><span class="line">  <span class="comment">//此时应该将该vector和一个匿名的vector交换，交换后的vector的大小和容量相同，这一行执行完毕后，匿名vector被释放，达到收缩内存的目的</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//先创建匿名对象，再与原来的vector交换</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h3 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h3><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>  容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//预留空间</span></span><br><span class="line">  v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">      p = &amp;v[<span class="number">0</span>];</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h2 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h2><h3 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h3><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/08/24/hkiHNF.jpg" alt="说明: 2015-11-19_204101"></p>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hkibh4.jpg" alt="clip_image002-1547547896341"></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h3 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt; deqT</code>;                      默认构造形式</li>
<li><code>deque(beg, end);</code>                   构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                     构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>        拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line">  <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">  <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d4 = d3;</span><br><span class="line">  <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&amp; operator=(const deque &amp;deq); </code>       重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>                                 将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                   将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">  d2 = d1;</span><br><span class="line">  <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">  d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">  d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code>                   判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>                     返回容器中元素的个数</p>
</li>
<li><p><code>deque.resize(num);</code>              重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>deque.resize(num, elem);</code>     重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断容器是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//统计大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重新指定大小</span></span><br><span class="line">  d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">  d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>deque没有容量capacity的概念，和实现方式有关</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h3 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        在容器头部插入一个数据</li>
<li><code>pop_back();</code>                 删除容器最后一个数据</li>
<li><code>pop_front();</code>                删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code>         在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p><code>insert(pos,n,elem);</code>      在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p><code>insert(pos,beg,end);</code>     在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>                      清空容器的所有数据</p>
</li>
<li><p><code>erase(beg,end);</code>            删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p><code>erase(pos);</code>                  删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  <span class="comment">//尾插</span></span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="comment">//头插</span></span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尾删</span></span><br><span class="line">  d.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="comment">//头删</span></span><br><span class="line">  d.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">  d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">  d.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h3 id="3-3-6-deque数据存取"><a href="#3-3-6-deque数据存取" class="headerlink" title="3.3.6 deque数据存取"></a>3.3.6 deque数据存取</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     返回索引idx所指的数据</li>
<li><code>operator[]; </code>       返回索引idx所指的数据</li>
<li><code>front(); </code>           返回容器中第一个数据元素</li>
<li><code>back();</code>             返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h3 id="3-3-7-deque排序"><a href="#3-3-7-deque排序" class="headerlink" title="3.3.7  deque排序"></a>3.3.7  deque排序</h3><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  对beg和end区间内元素进行排序</li>
<li>只要迭代器满足随机访问，就可以使用sort，所以vector也可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">  <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h2><h3 id="3-5-1-stack常用接口"><a href="#3-5-1-stack常用接口" class="headerlink" title="3.5.1 stack常用接口"></a>3.5.1 stack常用接口</h3><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                             stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>             拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>     重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      向栈顶添加元素</li>
<li><code>pop();</code>             从栈顶移除第一个元素</li>
<li><code>top(); </code>             返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>          判断堆栈是否为空</li>
<li><code>size(); </code>            返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">  stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">//输出栈顶元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//弹出栈顶元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h2 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h2><h3 id="3-6-1-queue常用接口"><a href="#3-6-1-queue常用接口" class="headerlink" title="3.6.1 queue常用接口"></a>3.6.1 queue常用接口</h3><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                            queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>   重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      往队尾添加元素</li>
<li><code>pop();</code>              从队头移除第一个元素</li>
<li><code>back();</code>            返回最后一个元素</li>
<li><code>front(); </code>           返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>           判断队列是否为空</li>
<li><code>size(); </code>             返回队列的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建队列</span></span><br><span class="line">  queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//准备数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">  q.<span class="built_in">push</span>(p1);</span><br><span class="line">  q.<span class="built_in">push</span>(p2);</span><br><span class="line">  q.<span class="built_in">push</span>(p3);</span><br><span class="line">  q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//队列不提供迭代器，更不支持随机访问  </span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">//输出队头元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//弹出队头元素</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h2 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h2><h3 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h3><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<p><img src="https://z3.ax1x.com/2021/08/25/hEe94x.jpg" alt="说明: 2015-11-15_225145"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p><strong>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</strong></p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h3 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                          list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                       构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                         构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">  <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-3-list赋值和交换"><a href="#3-7-3-list赋值和交换" class="headerlink" title="3.7.3 list赋值和交换"></a>3.7.3 list赋值和交换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>                               将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                 将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>        重载等号操作符</li>
<li><code>swap(lst);</code>                                          将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">  L2 = L1;</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">  L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">  L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">  L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-4-list大小操作"><a href="#3-7-4-list大小操作" class="headerlink" title="3.7.4 list大小操作"></a>3.7.4 list大小操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size(); </code>                      返回容器中元素的个数</p>
</li>
<li><p><code>empty(); </code>                     判断容器是否为空</p>
</li>
<li><p><code>resize(num);</code>               重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(num, elem); </code>      重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (L1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重新指定大小</span></span><br><span class="line">  L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">  L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h3 id="3-7-5-list插入和删除"><a href="#3-7-5-list插入和删除" class="headerlink" title="3.7.5 list插入和删除"></a>3.7.5 list插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(elem);</code>           在容器尾部加入一个元素</li>
<li><code>pop_back(); </code>                  删除容器中最后一个元素</li>
<li><code>push_front(elem); </code>          在容器开头插入一个元素</li>
<li><code>pop_front();</code>                 从容器开头移除第一个元素</li>
<li><code>insert(pos,elem);</code>          在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li><code>insert(pos,n,elem);</code>       在pos位置插入n个elem数据，无返回值。</li>
<li><code>insert(pos,beg,end);</code>      在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li><code>clear();</code>                       移除容器的所有数据</li>
<li><code>erase(beg,end);</code>             删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li><code>erase(pos);</code>                   删除pos位置的数据，返回下一个数据的位置。</li>
<li><code>remove(elem);</code>                删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">  <span class="comment">//尾插</span></span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  <span class="comment">//头插</span></span><br><span class="line">  L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">  L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尾删</span></span><br><span class="line">  L.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//头删</span></span><br><span class="line">  L.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">  L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  it = L.<span class="built_in">begin</span>();</span><br><span class="line">  L.<span class="built_in">erase</span>(++it);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除</span></span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">  L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  L.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h3 id="3-7-6-list数据存取"><a href="#3-7-6-list数据存取" class="headerlink" title="3.7.6 list数据存取"></a>3.7.6 list数据存取</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>       返回第一个元素。</li>
<li><code>back();</code>         返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl; //错误 不支持at访问数据</span></span><br><span class="line">  <span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl;    //错误  不支持[]方式访问数据</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="comment">//it = it + 1; //错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h3 id="3-7-7-list反转和排序"><a href="#3-7-7-list反转和排序" class="headerlink" title="3.7.7 list反转和排序"></a>3.7.7 list反转和排序</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   反转链表</li>
<li><code>sort();</code>        链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反转容器的元素</span></span><br><span class="line">  L.<span class="built_in">reverse</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//排序</span></span><br><span class="line">  L.<span class="built_in">sort</span>();          <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h3 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h3><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) &#123;</span><br><span class="line">    m_Name = name;</span><br><span class="line">    m_Age = age;</span><br><span class="line">    m_Height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">  <span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">  <span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">    <span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
</ul>
<ul>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<h2 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h2><h3 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h3><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h3 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h3><p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                     默认构造函数：</li>
<li><code>set(const set &amp;st);</code>        拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//拷贝构造</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">  <span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">  s3 = s2;</span><br><span class="line">  <span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h3 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          返回容器中元素的数目</li>
<li><code>empty();</code>         判断容器是否为空</li>
<li><code>swap(st);</code>        交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  </span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line">  <span class="built_in">printSet</span>(s2);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">  s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line">  <span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h3 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>            在容器中插入元素。</li>
<li><code>clear();</code>                   清除所有元素</li>
<li><code>erase(pos);</code>               删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>        删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>              删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  <span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">  s1.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h3 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>            查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>           统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//统计</span></span><br><span class="line">  <span class="keyword">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h3 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h3><p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// set插入后会返回pair，pair的第二个参数是判断插入是否成功的布尔值</span></span><br><span class="line">  <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//multiset</span></span><br><span class="line">  multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">  ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (multiset&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h3 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h3><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">pair&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  pair&lt;string, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h3><p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123; <span class="comment">//重载()，仿函数</span></span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认从小到大</span></span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定排序规则</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>,MyCompare&gt; s2; <span class="comment">//将MyCompare类作为第二个参数传入</span></span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123; <span class="comment">//将MyCompare类作为第二个参数传入</span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span> &#123;</span> <span class="comment">//重载()，仿函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照年龄进行降序排序</span></span><br><span class="line">    <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;Person, comparePerson&gt; s; <span class="comment">//将comparePerson类作为第二个参数传入</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">insert</span>(p1);</span><br><span class="line">  s.<span class="built_in">insert</span>(p2);</span><br><span class="line">  s.<span class="built_in">insert</span>(p3);</span><br><span class="line">  s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123; <span class="comment">//将comparePerson类作为第二个参数传入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h2 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h2><h3 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h3><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的<strong>键值</strong>自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h3 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>            map默认构造函数:</li>
<li><code>map(const map &amp;mp);</code>       拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">  <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">  m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">  <span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h3 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          返回容器中元素的数目</li>
<li><code>empty();</code>         判断容器是否为空</li>
<li><code>swap(st);</code>       交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">  m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">  m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">  m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line">  <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">  m.<span class="built_in">swap</span>(m2);</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line">  <span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h3 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           在容器中插入元素。</li>
<li><code>clear();</code>                  清除所有元素</li>
<li><code>erase(pos);</code>              删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>       删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>              删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">  <span class="comment">//第一种插入方式</span></span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  <span class="comment">//第二种插入方式</span></span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  <span class="comment">//第三种插入方式</span></span><br><span class="line">  m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">  <span class="comment">//第四种插入方式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果用这种方式访问了不存在的键名，键会被自动创建，键值为0</span></span><br><span class="line">  m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">  m.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — insert </li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h3 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>               查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>             统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//统计</span></span><br><span class="line">  <span class="keyword">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于map，结果为0或者1）</li>
</ul>
<h3 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h3><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认从小到大排序</span></span><br><span class="line">  <span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m; <span class="comment">//将MyCompare类作为第三个参数传入</span></span><br><span class="line"></span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123; <span class="comment">//将MyCompare类作为第三个参数传入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则，同set容器</li>
</ul>
<h1 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h1><h2 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h2><h3 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h3><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h3 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h3><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li><strong>函数对象超出普通函数的概念，函数对象可以有自己的状态</strong></li>
<li><strong>函数对象可以作为参数传递</strong></li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyAdd myAdd;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyPrint</span>() &#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    count++; <span class="comment">//统计使用次数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyPrint myPrint;</span><br><span class="line">  <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyPrint myPrint;</span><br><span class="line">  <span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line">  <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h2><h3 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h3><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h3 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());   <span class="comment">//find_if的第三个参数要求传入函数对象，它的返回值是迭代器</span></span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认从小到大</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>()); <span class="comment">//第三个参数传入函数对象</span></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h2><h3 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h3><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p>
</li>
<li><p>关系仿函数</p>
</li>
<li><p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h3 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>               加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>       乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>           除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>           取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>             取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h3 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>              不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                     大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>            大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                         小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>                 小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//STL内建仿函数——大于仿函数</span></span><br><span class="line">  <span class="comment">//在前面，第三个参数是自己写了MyCompare再传入的，也可以使用STL提供的大于仿函数</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h3 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">  v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">//搬运之前必须提前开辟空间，见5.1.2</span></span><br><span class="line">  <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), logical_not&lt;<span class="keyword">bool</span>&gt;()); <span class="comment">//transform是遍历函数，搬运过去的时候顺便执行逻辑非运算</span></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h1 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h1><p><strong>概述</strong>:</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
</ul>
<ul>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h2 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     遍历容器</li>
<li><code>transform</code>    搬运容器到另一个容器中</li>
</ul>
<h3 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>遍历算法 遍历容器元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历算法</span></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h3 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h3><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></p>
<p>beg1 源容器开始迭代器</p>
<p>end1 源容器结束迭代器</p>
<p>beg2 目标容器开始迭代器</p>
<p>_func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在搬过去时可以对每个数进行处理</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">  vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h2 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     查找元素</li>
<li><code>find_if</code>                 按条件查找元素</li>
<li><code>adjacent_find</code>         查找相邻重复元素</li>
<li><code>binary_search</code>         二分查找法</li>
<li><code>count</code>                    统计元素个数</li>
<li><code>count_if</code>                按条件统计元素个数</li>
</ul>
<h3 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);  </code></p>
<p> 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p> beg 开始迭代器</p>
<p> end 结束迭代器</p>
<p> value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">// 第三个参数直接传入5</span></span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重载==</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">  vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h3 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h3><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>()); <span class="comment">// 第三个参数传入函数体</span></span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">  vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h3 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找相邻重复元素</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>查找指定的元素，查到 返回true  否则false，注意: 在<strong>无序序列中不可用</strong></p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//二分查找</span></span><br><span class="line">  <span class="keyword">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h3><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);  </code></p>
<p>统计元素出现次数</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重载==</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//先插入容器</span></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p); <span class="comment">//查找和诸葛亮年龄相同的人数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h3 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h3><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>按条件统计元素出现次数</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_Pred 谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>()); <span class="comment">//第三个参数传入函数体</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>()); <span class="comment">//第三个参数传入函数体</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h2 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             //对容器内元素进行排序</li>
<li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       // 反转指定范围的元素</li>
</ul>
<h3 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>beg    开始迭代器</p>
<p>end    结束迭代器</p>
<p>_Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sort默认从小到大排序</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从大到小排序</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h3 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h3><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌，指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//根据系统的时间，随机生成种子，每次的排列顺序都不同</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打乱顺序</span></span><br><span class="line">  <span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h3 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h3><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>容器元素合并，并存储到另一容器中，注意: 两个容器必须是<strong>有序的</strong></p>
<p>beg1   容器1开始迭代器<br>end1   容器1结束迭代器<br>beg2   容器2开始迭代器<br>end2   容器2结束迭代器<br>dest    目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">  <span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">  vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">  <span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">  for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h3 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);  </code></p>
<p>反转指定范围的元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>reverse反转区间内元素</p>
<h2 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                  将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>              容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                      互换两个容器的元素</li>
</ul>
<h3 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h3><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>beg  开始迭代器</p>
<p>end  结束迭代器</p>
<p>dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">  for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间。copy不常用，拷贝都在构造时用=</p>
<h3 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>将区间内旧元素 替换成 新元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>oldvalue 旧元素</p>
<p>newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h3 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h3><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>按条件替换元素，满足条件的替换成指定元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_pred 谓词</p>
<p>newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h3 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h3><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);  </code></p>
<p>互换两个容器的元素</p>
<p>c1容器1</p>
<p>c2容器2</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">swap</span>(v1, v2);</span><br><span class="line">  for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>swap交换容器时，注意交换的<strong>容器要同种类型</strong></p>
<h2 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h2><p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code>      计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>               向容器中添加元素</p>
</li>
</ul>
<h3 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h3><p><strong>功能描述：</strong></p>
<ul>
<li> 计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>计算容器元素累计总和</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//起始值为0</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric</p>
<h3 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h3><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>向容器中填充元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">//填充</span></span><br><span class="line">  <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为指定的值</p>
<h2 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code>         求两个容器的交集</p>
</li>
<li><p><code>set_union</code>                   求两个容器的并集</p>
</li>
<li><p><code>set_difference </code>            求两个容器的差集</p>
</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>求两个集合的交j集，<strong>注意：两个集合必须是有序序列</strong></p>
<p>beg1 容器1开始迭代器<br>end1 容器1结束迭代器<br>beg2 容器2开始迭代器<br>end2 容器2结束迭代器<br>dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">  <span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">  vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>()); <span class="comment">//itEnd作为第二个参数</span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>求两个集合的并集，<strong>注意:两个集合必须是有序序列</strong></p>
<p>beg1 容器1开始迭代器<br>end1 容器1结束迭代器<br>beg2 容器2开始迭代器<br>end2 容器2结束迭代器<br>dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">  <span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">  vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>求两个集合的差集，<strong>注意:两个集合必须是有序序列</strong></p>
<p>beg1 容器1开始迭代器<br>end1 容器1结束迭代器<br>beg2 容器2开始迭代器<br>end2 容器2结束迭代器<br>dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">  <span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">  vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
<h2 id="5-7-其他算法"><a href="#5-7-其他算法" class="headerlink" title="5.7 其他算法"></a>5.7 其他算法</h2><p>min，max函数需要包含<code>&lt;algorithm&gt;</code>头文件</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P1381 单词背诵</title>
    <url>/2021/08/26/40.%E6%B4%9B%E8%B0%B7-P1381%20%E5%8D%95%E8%AF%8D%E8%83%8C%E8%AF%B5/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1381">https://www.luogu.com.cn/problem/P1381</a></p>
<p>思路：</p>
<ul>
<li><p>首先，字符串哈希可以把一个字符串变成唯一的值，从而匹配每一个单词</p>
</li>
<li><p>尺取法：<a href="https://www.cnblogs.com/fusiwei/p/11313817.html">https://www.cnblogs.com/fusiwei/p/11313817.html</a></p>
<p>它可以避免暴力枚举左右端点，达到优化区间枚举的作用</p>
<p>本质就是设置l（左端点）和r（右端点），通过移动二者来求出最优解</p>
</li>
<li><p>对于本题，整个区间在不断向右移动，只要当前的区间内包括了所有单词就会退出循环，计算并更新ans的值，最后的ans即为最小值</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, ans = INF, l, r;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxm], appear[mod];</span><br><span class="line"><span class="keyword">char</span> input[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> need[mod], v[mod];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">char</span> s[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ll ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        ret *= p;</span><br><span class="line">        ret += s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        ret %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        a[i] = <span class="built_in">Hash</span>(input);</span><br><span class="line">        need[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">        b[i] = <span class="built_in">Hash</span>(input);</span><br><span class="line">        <span class="keyword">if</span> (need[b[i]] &amp;&amp; !v[b[i]]) &#123;</span><br><span class="line">            <span class="comment">// 课文中的单词和要背的单词匹配</span></span><br><span class="line">            cnt++;</span><br><span class="line">            v[b[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cnt) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);         <span class="comment">// 匹配的单词数</span></span><br><span class="line">    &#125;</span><br><span class="line">    l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r &gt; m) &#123;             <span class="comment">// 尺取法——右区间</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (need[b[r]]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!appear[b[r]]) &#123; <span class="comment">// 单词第一次出现</span></span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                appear[b[r]]++;      <span class="comment">// 单词出现次数增加</span></span><br><span class="line">            &#125;</span><br><span class="line">            r++;                     <span class="comment">// 下一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!need[b[l]]) &#123;    <span class="comment">// 目前的单词不是需要背的</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &gt; m) &#123;             <span class="comment">// 尺取法——左区间</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, r - l);   <span class="comment">// 更新ans</span></span><br><span class="line">            <span class="keyword">if</span> (appear[b[l]] == <span class="number">1</span>) &#123;</span><br><span class="line">                cnt++;               <span class="comment">// 让右指针继续右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (appear[b[l]] &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                appear[b[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);  <span class="comment">//包含最多要背单词的最短的连续段的长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>尺取法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>dart + flutter笔记</title>
    <url>/2021/08/26/42.flutter%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>SDK：指一些被软件工程师用于为特定的软件包、软件框架、硬性平台及作业系统等建立应用软件的开发工具之集合。</p>
</blockquote>
<h1 id="dart"><a href="#dart" class="headerlink" title="dart"></a>dart</h1><h2 id="入口方法"><a href="#入口方法" class="headerlink" title="入口方法"></a>入口方法</h2><p>Hello world程序的两种写法：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;hello dart&#x27;</span>); <span class="comment">// 分号不可省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;hello dart&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>可以不预先定义变量类型，用<code>var</code>定义变量，类型会自动推导</li>
<li>也可以定义变量类型</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> str1 = <span class="string">&#x27;hello dart1&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">123</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">String</span> str2 = <span class="string">&#x27;hello dart2&#x27;</span>;</span><br><span class="line">  <span class="built_in">int</span> num2 = <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dart存在类型校验，类型确定后，再给变量赋值为另一个类型，会报错</li>
</ul>
<h3 id="final和const的区别"><a href="#final和const的区别" class="headerlink" title="final和const的区别"></a>final和const的区别</h3><ul>
<li>final可以开始不赋值，之后只能赋值一次</li>
<li>final不仅有const的编译时常量的特性，最重要的是它是<code>运行时常量</code>，并且final是惰性初始化，即在运行时第一次使用前才初始化</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> a = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now(); <span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">DateTime</span>.now(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<h1 id="flutter"><a href="#flutter" class="headerlink" title="flutter"></a>flutter</h1>]]></content>
      <categories>
        <category>web开发</category>
        <category>dart/flutter</category>
      </categories>
      <tags>
        <tag>dart</tag>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷——P1090 合并果子</title>
    <url>/2021/08/26/41.%E6%B4%9B%E8%B0%B7-P1090%20%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1090">https://www.luogu.com.cn/problem/P1090</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// 第一个参数是存储对象的类型，第二个参数是存储元素的底层容器，第三个参数是函数对象</span></span><br><span class="line"><span class="comment">// 优先队列，在入队时会自动作排序</span></span><br><span class="line"><span class="comment">// 使用greater，则容器中最小的元素会排在队列前面</span></span><br><span class="line">priority_queue&lt; <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pri_q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> x,b1, b2;</span><br><span class="line"> ll sum = <span class="number">0</span>;</span><br><span class="line"> cin &gt;&gt; n;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  cin &gt;&gt; x;</span><br><span class="line">  pri_q.<span class="built_in">push</span>(x);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">  b1 = pri_q.<span class="built_in">top</span>();         <span class="comment">// 返回优先队列中第一个元素的引用</span></span><br><span class="line">  pri_q.<span class="built_in">pop</span>();              <span class="comment">// 出队</span></span><br><span class="line">  b2 = pri_q.<span class="built_in">top</span>();</span><br><span class="line">  pri_q.<span class="built_in">pop</span>();</span><br><span class="line">  sum += (b1 + b2);</span><br><span class="line">  pri_q.<span class="built_in">push</span>(b1 + b2);      <span class="comment">// 把合并的堆放回队列</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>本题使用了STL中的优先队列</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
</search>
