<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《你不知道的JS》读书笔记</title>
    <url>/2021/05/24/01.%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习方式：一边看书，一边学习他人的博客，把一些关键的部分记录在此，其他的贴出他人博客的链接。此外，本文并非仅是《你不知道的JS》笔记，还额外补充一些内容。</p>
<span id="more"></span>

<h1 id="最佳实践-原则"><a href="#最佳实践-原则" class="headerlink" title="最佳实践/原则"></a>最佳实践/原则</h1><ul>
<li>最小特权原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计</li>
<li>始终给函数表达式命名</li>
<li>对不再必要的全局变量或全局对象的属性，将其设置为null</li>
</ul>
<h1 id="上卷"><a href="#上卷" class="headerlink" title="上卷"></a>上卷</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><a href="https://blog.csdn.net/weixin_44659458/article/details/109356598">1.Javascript引擎，编译器，作用域三者之间的关系及LHS和RHS的区别</a><br><a href="https://www.jianshu.com/p/36f5bfc6b7e6/">2.聊聊JavaScript 编译器，引擎，作用域</a></p>
<h3 id="JS的编译"><a href="#JS的编译" class="headerlink" title="JS的编译"></a>JS的编译</h3><p>JS代码片在执行前要先编译：它的编译过程（通常）是在实际执行前进行的，而且也不会产生可移植的编译结果。</p>
<p>通常的编译步骤：</p>
<ol>
<li><code>分词与词法分析</code>：把输入的字符串分解为一些对编程语言有意义的代码块（词法单元）。</li>
<li><code>解析与语法分析</code>：将上一步的词法单元集合分析并最终转换为一个由元素逐级嵌套所组成的代表了程序语法结构的树，称为<code>抽象语法树</code>（Abstract Syntax Tree，AST）。</li>
<li><code>代码生成</code>：将上一步的AST转换为可执行代码。</li>
</ol>
<p>由于JS编译的特殊性，编译执行效率就要比一般静态语言敏感的多，故而也非常复杂。JS引擎在这一部分做了非常多的优化，一是针对语法分析和代码生成阶段进行优化（例如针对冗余元素进行优化等），目的是提高编译后的执行效率。二是针对编译过程进行优化（如JIT，延迟编译甚至重编译），目的是缩短编译过程，保证性能最佳。</p>
<h4 id="引擎、编译器和作用域"><a href="#引擎、编译器和作用域" class="headerlink" title="引擎、编译器和作用域"></a>引擎、编译器和作用域</h4><p>引擎：   负责整个Javascript程序的编译及执行过程。<br>编译器：负责语法分析及代码生成。<br>作用域：负责收集并维护有所有声明的标识符组成的一系列查询。</p>
<h4 id="var-a-1的编译过程"><a href="#var-a-1的编译过程" class="headerlink" title="var a=1的编译过程"></a>var a=1的编译过程</h4><ol>
<li><code>编译器</code>首先会将这段代码分解成词法单元，然后将词法单元解析成树结构。</li>
<li>对词法单元进行解析，解析到var a时，<code>编译器</code>会询问作用域是否存在一个变量名为a在同一作用域的集合中。如果有，编译器就忽略此声明。反之，在要求的作用域下声明变量。<br>第三步：生成可以运行代码(=1)给<code>引擎</code>执行，生成代码的这个过程就涉及到LHS和RHS两种赋值概念。<br>第四步：<code>引擎</code>运行编译器生成的代码时，会询问<code>作用域</code>是否存在在当前作用域下变量名为a的集合，如果没有，则在向上一级作用域查找变量名a。如果有，引擎则对变量名为a的集合赋值。</li>
</ol>
<h4 id="LHS和RHS"><a href="#LHS和RHS" class="headerlink" title="LHS和RHS"></a>LHS和RHS</h4><p>LHS（left-hand-side）：找到变量的容器本身，从而可以对其赋值<br>RHS（rigjt-hand-side）：查找某个变量的值</p>
<h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><h4 id="最小特权原则"><a href="#最小特权原则" class="headerlink" title="最小特权原则"></a>最小特权原则</h4><p>最小特权原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计</p>
<h4 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h4><h5 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h5><p>（可以实践）</p>
<p>在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会称为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p>
<h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>把IIFE当作函数调用并传递参数进去，可以改进代码风格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"><span class="built_in">global</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);	<span class="comment">//3</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">global</span>.a);	<span class="comment">//2</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);	<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>好处：在代码风格上对全局对象的引用，变得比引用一个没有”全局”字样的变量更加清晰</p>
<p>倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去<br>（思考：这种方式或许能在某处派上用场）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">def</span>) </span>&#123;</span><br><span class="line">	def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"><span class="built_in">global</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);	<span class="comment">//3</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">global</span>.a);	<span class="comment">//2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="with和try-catch（放着）"><a href="#with和try-catch（放着）" class="headerlink" title="with和try/catch（放着）"></a>with和try/catch（放着）</h4><h4 id="垃圾回收（补充）"><a href="#垃圾回收（补充）" class="headerlink" title="垃圾回收（补充）"></a>垃圾回收（补充）</h4><p><a href="https://segmentfault.com/a/1190000018605776">前端面试：谈谈 JS 垃圾回收机制</a><br><a href="https://www.yuque.com/bingyan-studio/isz3cs/up15ft">浏览器垃圾回收与内存管理</a></p>
<p>引用计数法由于循环引用问题而遭到废弃，此处只记录标记清理法：</p>
<ul>
<li>垃圾回收程序运行的时候，会标记内存中存储的所有变量</li>
<li>程序会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的，因为任何在上下文中的变量都访问不到它们了</li>
<li>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存</li>
</ul>
<p>关于垃圾回收更详细的内容，请猛戳第二篇博文</p>
<h5 id="V8垃圾回收"><a href="#V8垃圾回收" class="headerlink" title="V8垃圾回收"></a>V8垃圾回收</h5><p>V8三种回收算法的比较：</p>
<table>
<thead>
<tr>
<th>回收算法</th>
<th>标记清除（Mark-Sweep）</th>
<th>标记整理</th>
<th>Scavange</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（有碎片）</td>
<td>少（无碎片）</td>
<td>双倍空间（无碎片）</td>
</tr>
<tr>
<td>是否移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="模块（放着）"><a href="#模块（放着）" class="headerlink" title="模块（放着）"></a>模块（放着）</h4><p><a href="https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a><br><a href="https://blog.csdn.net/m0_51235736/article/details/116904464">前端模块化详解-笔记</a></p>
<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><ul>
<li>词法作用域：在写代码或者说定义时确定，关注函数在何处声明</li>
<li>动态作用域：在运行时确定，关注函数在何处调用，作用域基于调用栈</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="往日结论"><a href="#往日结论" class="headerlink" title="往日结论"></a>往日结论</h3><p>先说以前记的结论：<br>1.以函数形式调用时，this永远都是window<br>2.以方法的形式调用时，this是调用方法的对象<br>3.以构造函数的形式调用时，this是新创建的那个对象<br>4.使用call和apply调用时，this是指定的那个对象</p>
<h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><ul>
<li>this在运行时进行绑定，它的上下文取决于函数调用时的各种条件。</li>
<li>当一个函数被调用时，会创建一个活动记录（执行上下文），它包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this是执行上下文的一个属性，会在函数执行的过程中用到</li>
</ul>
<h3 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h3><p>显示强制绑定：一旦绑定this后不可以再通过call或apply修改this，比如ES添加的bind</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ol>
<li>new（构造调用）</li>
<li>显示绑定/硬绑定调用（call、apply/bind）</li>
<li>隐式绑定（对象的方法）</li>
<li>默认绑定（全局对象）</li>
</ol>
<p>对默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this会被绑定到全局对象。</p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><h5 id="将null或undefined作为绑定对象"><a href="#将null或undefined作为绑定对象" class="headerlink" title="将null或undefined作为绑定对象"></a>将null或undefined作为绑定对象</h5><p>这些情况下，函数并不关心this是什么，传入的null仅仅作为占位值</p>
<p>情况一：展开数组；情况二：柯里化（减少返回的函数要求传入参数的个数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span> + a + <span class="string">&quot;, b:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数组展开</span></span><br><span class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>,<span class="number">3</span>]);	<span class="comment">// a: 2, b: 3</span></span><br><span class="line"><span class="comment">//ES6中可以用...操作符来替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.bind(<span class="literal">null</span>, <span class="number">2</span>);<span class="comment">//对bar，以后就只用传入b这个参数了</span></span><br><span class="line">bar(<span class="number">3</span>);	<span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>

<p>以上的方式有一定安全隐患，并不推荐</p>
<h5 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h5><p>创建空的非委托对象，即DMZ（非军事区）对象</p>
<blockquote>
<p>Object.create(null)和{}很像，但是并不会创建Object.prototype这个委托，因此比{}更空。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span> + a + <span class="string">&quot;, b&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们的DMZ空对象，使用空集符号可以增强可读性</span></span><br><span class="line"><span class="keyword">let</span> Ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数组展开</span></span><br><span class="line">foo.apply(Ø, [<span class="number">2</span>,<span class="number">3</span>]);	<span class="comment">// a: 2, b: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.bind(Ø, <span class="number">2</span>);<span class="comment">//对bar，以后就只用传入b这个参数了</span></span><br><span class="line">bar(<span class="number">3</span>);	<span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>
<h5 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h5><p>创建函数的间接引用时，调用该函数会应用默认绑定规则，间接引用最容易在赋值时发生</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="keyword">let</span> p = &#123;<span class="attr">a</span>: <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值表达式p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或o.foo() </span></span><br></pre></td></tr></table></figure>
<h4 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h4><p>由以上可知，硬绑定后隐式绑定或显示绑定会无效</p>
<p>软绑定：可以给默认绑定指定一个全局对象和undefined以外的值，同时保留隐式绑定或者显式绑定修改this的能力</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一段代码，暂时不能完全看懂</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">	<span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">let</span> fn = <span class="built_in">this</span>;</span><br><span class="line">		<span class="comment">// 捕获所有curried参数</span></span><br><span class="line">		<span class="keyword">let</span> curried = [].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> fn.apply(</span><br><span class="line">				(!<span class="built_in">this</span> || <span class="built_in">this</span> === (<span class="built_in">window</span> || <span class="built_in">global</span>)) ? </span><br><span class="line">					obj: <span class="built_in">this</span>,</span><br><span class="line">					curried.concat.apply(curried, <span class="built_in">arguments</span>)</span><br><span class="line">			);</span><br><span class="line">		&#125;;</span><br><span class="line">		bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">		<span class="keyword">return</span> bound;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;name: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>&#125;, obj2 = &#123;<span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>&#125;, obj3 = &#123;<span class="attr">name</span>: <span class="string">&quot;obj3&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fooOBJ = foo.softBind(obj); <span class="comment">//软绑定，此时默认绑定了obj对象</span></span><br><span class="line">fooOBJ(); <span class="comment">// name: obj</span></span><br><span class="line">obj2.foo = foo.softBind(obj); <span class="comment">//软绑定，此时默认绑定了obj对象</span></span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2 此时隐式绑定仍然生效</span></span><br><span class="line">fooOBJ.call(obj3); <span class="comment">// name: obj3 此时显示绑定仍然生效</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj2.foo, <span class="number">10</span>); <span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数不使用this的四种标准规则，而是根据外层作用域来决定this</p>
<p>箭头函数的绑定无法被修改，new也不行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = foo.call(obj1); </span><br><span class="line"><span class="comment">//foo的this被绑定为obj1，由this词法，bar的this受到foo的影响，也是obj1</span></span><br><span class="line">bar.call(obj2); <span class="comment">// 2， 一旦绑定，就不可被修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中卷"><a href="#中卷" class="headerlink" title="中卷"></a>中卷</h1><h1 id="下卷"><a href="#下卷" class="headerlink" title="下卷"></a>下卷</h1>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的rem布局</title>
    <url>/2021/05/28/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84rem%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>移动端的rem布局实践</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> designWidth = <span class="number">375</span>;  		<span class="comment">// 设计稿宽度</span></span><br><span class="line"><span class="keyword">const</span> remPx = <span class="number">100</span>;               <span class="comment">// 在屏幕宽度375px的时候，设置根元素字体大小 100px</span></span><br><span class="line"><span class="keyword">let</span> scale = <span class="built_in">window</span>.innerWidth / designWidth; <span class="comment">// 计算当前屏幕的宽度与设计稿比例</span></span><br><span class="line"><span class="comment">// 根据屏幕宽度动态计算根元素的字体大小</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = scale * remPx + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我为了保险，还在css中设置了根元素字体大小是100px，为了不影因为字体太大而影响布局，我又设置了body字体大小为16px</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，其他元素都用rem即可</p>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>超出后省略剩余部分</title>
    <url>/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>效果如下：</p>
<p><img src="/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/1.jpg"></p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>美国顶级传染病专家福奇称「不确信新冠病毒来自大自然，应该继续调查中国」，他为何突然改口？<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>环球时报 ：我们都知道，自去年新冠肺炎疫情在美国暴发<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2.02rem</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0.16rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0.04rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.14rem</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*这三个需要一起用*/</span></span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/2.jpg"></p>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端和PC端设置不同页面</title>
    <url>/2021/05/28/04.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%92%8CPC%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>在服务端添加以下代码（以express为例）</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMachine</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deviceAgent = req.headers[<span class="string">&quot;user-agent&quot;</span>].toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> agentID = deviceAgent.match(<span class="regexp">/(iphone|ipod|ipad|android)/</span>);</span><br><span class="line">  <span class="keyword">if</span> (agentID) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 移动端</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// PC端</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> machine = getMachine(req);</span><br><span class="line">  <span class="keyword">if</span> (machine) &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./pe-views/index.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./pc-views/index.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack笔记</title>
    <url>/2021/05/24/02.webpack%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>一边啃JS和计网的书，一边来学webpack，学习完后就可以学习框架了，实战搞起来，理论补起来</p>
<span id="more"></span>

<h1 id="简介（P2）"><a href="#简介（P2）" class="headerlink" title="简介（P2）"></a>简介（P2）</h1><ul>
<li>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。</li>
<li>在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。</li>
<li>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</li>
</ul>
<h1 id="五个核心概念（P3）"><a href="#五个核心概念（P3）" class="headerlink" title="五个核心概念（P3）"></a>五个核心概念（P3）</h1><ul>
<li>Entry：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图</li>
<li>Output：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名</li>
<li>Loader： 让 webpack 能够去处理那些非JavaScript文件（翻译）</li>
<li>Plugins：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，<br>一直到重新定义环境中的变量等。</li>
<li>Mode：指示 webpack 使用相应模式的配置，分为development和production</li>
</ul>
<h1 id="初体验（P4）"><a href="#初体验（P4）" class="headerlink" title="初体验（P4）"></a>初体验（P4）</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>新建文件夹：webpack初体验</li>
<li>npm init</li>
<li>npm i webpack webpack-cli -g</li>
<li>npm i webpack webpack-cli -D</li>
</ul>
<h2 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h2><h3 id="设置powershell"><a href="#设置powershell" class="headerlink" title="设置powershell"></a>设置powershell</h3><p>在执行以下指令以前，先设置powershell：<a href="https://blog.csdn.net/Piconjo/article/details/105716451">解决webpack : 无法加载文件 C:\Users\XXX\AppData\Roaming\npm\webpack.ps1因为在此系统上禁止运行脚本</a></p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><img src="https://img-blog.csdnimg.cn/20210509105459275.jpg#pic_center"></p>
<h3 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h3><ul>
<li>开发环境指令：webpack src/index.js -o ./build/built.js –mode=development<br>功能：webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成<br>浏览器能识别的语法。</li>
<li>生产环境指令：webpack src/index.js -o ./build/built.js –mode=production<br>功能：在开发配置功能上多一个功能，压缩代码。</li>
</ul>
<blockquote>
<p>备注：老师执行完开发环境指令后，在build目录下生成了built.js文件，而我执行完指令后，在build目录下生成了built.js目录，在该目录下有main.js文件，我猜测是配置方面的问题，因此我使用的指令是webpack src/index.js -o ./build –mode=development</p>
</blockquote>
<h3 id="实践（js）"><a href="#实践（js）" class="headerlink" title="实践（js）"></a>实践（js）</h3><p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>main.js(development):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ATTENTION: The &quot;eval&quot; devtool has been used (maybe by default in mode: &quot;development&quot;).</span></span><br><span class="line"><span class="comment"> * This devtool is neither made for production nor for readable output files.</span></span><br><span class="line"><span class="comment"> * It uses &quot;eval()&quot; calls to create a separate source file in the browser devtools.</span></span><br><span class="line"><span class="comment"> * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span></span><br><span class="line"><span class="comment"> * or disable the default devtool with &quot;devtool: false&quot;.</span></span><br><span class="line"><span class="comment"> * If you are looking for production-ready output files, see mode: &quot;production&quot; (https://webpack.js.org/configuration/mode/).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function add(x,y)&#123;\r\n  return x+y;\r\n&#125;\r\nconsole.log(add(1,2));\n\n//# sourceURL=webpack://webpack_test/./src/index.js?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> 	&#125;);</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> 	</span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// startup</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// This entry module can&#x27;t be inlined because the eval devtool is used.</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span> 	__webpack_modules__[<span class="string">&quot;./src/index.js&quot;</span>]();</span><br><span class="line"><span class="comment">/******/</span> 	</span><br><span class="line"><span class="comment">/******/</span> &#125;)()</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>main.js(production):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//这里和老师的也不一样</span></span><br></pre></td></tr></table></figure>
<p>无论是开发环境产生的main.js，还是生产环境产生的main.js，都可以运行（node或浏览器内）：<br><img src="https://img-blog.csdnimg.cn/20210509104516739.jpg#pic_center"></p>
<h3 id="实践（json）"><a href="#实践（json）" class="headerlink" title="实践（json）"></a>实践（json）</h3><p>data.json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改index.js，再打包生成main.js文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&#x27;./data.json&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210509105129855.jpg#pic_center"><br>还是可以正常执行，说明webpack可以处理json</p>
<h1 id="打包样式资源（P5）"><a href="#打包样式资源（P5）" class="headerlink" title="打包样式资源（P5）"></a>打包样式资源（P5）</h1><p>注意，所有loader都需要用npm下载</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>webpack.config.js是webpack的配置文件</li>
<li>作用: 指示 webpack 干哪些活（当运行 webpack 指令时，会加载里面的配置）</li>
</ul>
<p>所有构建工具都是基于nodejs平台运行的，模块化默认采用commonjs。<br>（模块化分为ES6模块和commonjs）</p>
<p><img src="https://img-blog.csdnimg.cn/20210509163511553.jpg#pic_center"><br>配置文件和src目录在同一层级</p>
<p>配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法（不懂照做，以后深入学node）</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="comment">// __dirname nodejs的变量，代表当前文件的目录绝对路径（不懂照做）</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader的配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 匹配哪些文件（正则表达式）</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上 依次执行（很重要）</span></span><br><span class="line">          <span class="comment">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将less文件编译成css文件</span></span><br><span class="line">          <span class="comment">// 需要下载 less-loader和less</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugins的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 详细plugins的配置</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// mode: &#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h2><p>此处以css为主，就不写less文件了</p>
<p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入样式资源</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.less&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><ul>
<li>首先通过entry加载index.js</li>
<li>加载index.js后，发现它依赖了index.css</li>
<li>现在有js和css两个资源，每个资源都要经过rules中的loader处理</li>
<li>根据test，css资源匹配，会使用其中的loader对css资源进行处理</li>
<li>loader从下往上进行处理</li>
<li>css-loader将css文件变成commonjs模块加载js中，里面内容是样式字符串，可以在输出的built.js文件中检查到</li>
<li>style-loader在页面打开时，创建style标签，将js中的样式资源插入style标签，再添加到head中生效</li>
</ul>
<p>想要查看效果，只需把built.js文件引入html即可</p>
<h1 id="打包html资源"><a href="#打包html资源" class="headerlink" title="打包html资源"></a>打包html资源</h1><p>重点是配置plugins，记得下载和引用plugins</p>
<p>下载：npm i html-webpack-plugin -D</p>
<p>config:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  loader: 1. 下载   2. 使用（配置loader）</span></span><br><span class="line"><span class="comment">  plugins: 1. 下载  2. 引入  3. 使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// loader的配置</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// plugins的配置</span></span><br><span class="line">    <span class="comment">// html-webpack-plugin</span></span><br><span class="line">    <span class="comment">// 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">// 需求：需要有结构的HTML文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 复制 &#x27;./src/index.html&#x27; 文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.html:（没有引入index.js）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>hello html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包后，在build目录下生成了index.html:<br>（这里老师直接在终端输入webpack就可以打包了，我也不知道为什么）</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化详解笔记</title>
    <url>/2021/05/24/03.%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>参考博客：<a href="https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a></p>
<span id="more"></span>


<h1 id="模块化理解"><a href="#模块化理解" class="headerlink" title="模块化理解"></a>模块化理解</h1><h2 id="IIFE模式"><a href="#IIFE模式" class="headerlink" title="IIFE模式"></a>IIFE模式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//操作数据的函数</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//用于暴露有函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//用于暴露有函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">        otherFun() <span class="comment">//内部调用</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//内部私有的函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//暴露行为</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.myModule = &#123;foo,bar&#125; <span class="comment">//ES6写法</span></span></span><br><span class="line"><span class="javascript">    &#125;)(<span class="built_in">window</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    myModule.foo()</span></span><br><span class="line"><span class="javascript">    myModule.bar()</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span></span><br><span class="line"><span class="javascript">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span><br><span class="line"><span class="javascript">    myModule.foo() <span class="comment">//没有改变</span></span></span><br><span class="line"><span class="javascript">    myModule.foo = <span class="string">&#x27;xxxx&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    myModule.foo(); <span class="comment">//myModule.foo is not a function</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>起初看到这一段代码，不理解为什么修改data后再调用myModule.foo()，输出没有改变，以下是心路历程：</p>
<ul>
<li>应该是在return中没有暴露data吧，我暴露试试</li>
<li>暴露data之后，console.log(myModule.data)可以正确输出了，不是undefined，但是myModule.foo()的输出依然没有改变，为什么？</li>
<li>修改myModule.data后再console.log没有问题，修改myModule.foo后也可以修改成功，为什么会出现上一条的状况？</li>
<li>因为IIFE只执行一次，执行的时候闭包（foo和bar）就已经确定好了对原始的data（即’<a href="http://www.baidu.com&/#39;%EF%BC%89%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E6%89%80%E4%BB%A5%E8%B0%83myModule.foo()%E5%B0%B1%E4%BC%9A%E8%BE%93%E5%87%BA%E5%8E%9Fdata%EF%BC%8C%E5%86%8D%E6%94%B9data%E4%B9%9F%E6%97%A0%E7%94%A8">www.baidu.com&#39;）的引用，所以调myModule.foo()就会输出原data，再改data也无用</a></li>
<li>以上的实践表明，使用该方法，由于闭包的特性，外部不可以直接修改内部的数据</li>
</ul>
<h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦把模块内的一个值赋值给一个变量，模块内部的变化就影响不到这个变量的值，除非写成一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node1.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(counter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">  <span class="attr">printCounter</span>: printCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node2.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).counter;</span><br><span class="line"><span class="comment">// 从赋值之后开始 counter 变量的任何变化都与导出对象的 counter 属性毫无关系</span></span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).incCounter;</span><br><span class="line"><span class="keyword">var</span> printCounter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).printCounter;</span><br><span class="line"></span><br><span class="line">printCounter(); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line">printCounter(); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>其他的以后再记</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
</search>
