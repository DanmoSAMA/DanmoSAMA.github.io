<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SQL Murder Mystery</title>
    <url>/2022/10/13/sql/</url>
    <content><![CDATA[<p><a href="https://mystery.knightlab.com/">SQL Murder Mystery</a></p>
<h1 id="Select-Star-Sql"><a href="#Select-Star-Sql" class="headerlink" title="Select Star Sql"></a>Select Star Sql</h1><h2 id="Beazley’s-Last-Statement"><a href="#Beazley’s-Last-Statement" class="headerlink" title="Beazley’s Last Statement"></a>Beazley’s Last Statement</h2><p>查找此人的遗言：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name, last_statement</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;_apoleon&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%ley&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Claims-of-Innocence"><a href="#Claims-of-Innocence" class="headerlink" title="Claims of Innocence"></a>Claims of Innocence</h2><p>查找所有拒绝遗言的人：（第二种写法可以查询符合该条件的数量，但需要遍历全表）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- WHERE --</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="keyword">WHERE</span> last_statement <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- COUNT CASE WHEN --</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> last_statement <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>)</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"></span><br><span class="line"><span class="comment">-- COUNT functions --</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">-</span> <span class="built_in">COUNT</span>(last_statement) <span class="keyword">FROM</span> executions</span><br></pre></td></tr></table></figure>

<p>平均遗言长度：<strong>LENGTH</strong> 统计字符串长度</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(LENGTH(last_statement))</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br></pre></td></tr></table></figure>

<hr>
<p>去重：DISTINCT</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> county</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br></pre></td></tr></table></figure>

<p>也可以用 GROUP BY：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> county</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> county</span><br></pre></td></tr></table></figure>

<hr>
<p>查询喊冤的人数比：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="number">1.0</span> <span class="operator">*</span> <span class="built_in">COUNT</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> last_statement <span class="keyword">LIKE</span> <span class="string">&#x27;%innocent%&#x27;</span></span><br><span class="line">    <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br></pre></td></tr></table></figure>

<h2 id="The-long-tail"><a href="#The-long-tail" class="headerlink" title="The long tail"></a>The long tail</h2><h3 id="Strange-Query"><a href="#Strange-Query" class="headerlink" title="Strange Query"></a>Strange Query</h3><p>如果查找的其中一列是聚合，<strong>另一列既不是聚合，又不是 GROUP BY 的列</strong>，这种现象称作“Strange Query”。比如第一列是 Count，第二列是 first_name，那么查询得到的表格中，first_name 列对应最后一个表项的值。</p>
<blockquote>
<p>In this case, our database picks the first name <strong>from the last entry in our table.</strong></p>
</blockquote>
<hr>
<p>WHERE 在聚合前执行，而 HAVING 可以看作拿到了聚合的结果，在聚合后执行。</p>
<p>查找 年龄大于50岁被处刑的人数大于2 的县：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> county, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> number_over_50</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="keyword">WHERE</span> ex_age <span class="operator">&gt;</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> county</span><br><span class="line"><span class="keyword">HAVING</span> number_over_50 <span class="operator">&gt;</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Nest-select"><a href="#Nest-select" class="headerlink" title="Nest select"></a>Nest select</h3><p>查找遗言最长的人：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="keyword">WHERE</span> LENGTH(last_statement) <span class="operator">=</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(LENGTH(last_statement))</span><br><span class="line">   <span class="keyword">FROM</span> executions)</span><br></pre></td></tr></table></figure>

<hr>
<p>查找各县被处决人数占比：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  county,</span><br><span class="line">  <span class="number">100.0</span> <span class="operator">*</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">/</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> executions</span><br><span class="line">    <span class="keyword">AS</span> percentage</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> county</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> percentage <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h2 id="Execution-Hiatuses"><a href="#Execution-Hiatuses" class="headerlink" title="Execution Hiatuses"></a>Execution Hiatuses</h2><p>计算经过了多少天：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> JULIANDAY(<span class="string">&#x27;1993-08-10&#x27;</span>) <span class="operator">-</span> JULIANDAY(<span class="string">&#x27;1989-07-07&#x27;</span>) <span class="keyword">AS</span> day_difference</span><br></pre></td></tr></table></figure>

<p>计算每次处决人的天数间隔：</p>
<blockquote>
<p><code>previous</code> is derived from <code>executions</code>, so we’re effectively joining <code>executions</code> to itself. This is called a “self join” and is a powerful technique for <strong>allowing rows to get information from other parts of the same table.</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  last_ex_date <span class="keyword">AS</span> <span class="keyword">start</span>,</span><br><span class="line">  ex_date <span class="keyword">AS</span> <span class="keyword">end</span>,</span><br><span class="line">  <span class="comment">-- 计算天数间隔 --</span></span><br><span class="line">  JULIANDAY(ex_date) <span class="operator">-</span> JULIANDAY(last_ex_date) </span><br><span class="line">    <span class="keyword">AS</span> day_difference</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">  <span class="comment">-- self join --</span></span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">    <span class="comment">-- 相邻 ex_number 间的天数间隔，因此是 ex_number + 1 --</span></span><br><span class="line">    ex_number <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> ex_number,</span><br><span class="line">    ex_date <span class="keyword">as</span> last_ex_date</span><br><span class="line">  <span class="keyword">FROM</span> executions</span><br><span class="line">  <span class="keyword">WHERE</span> ex_number <span class="operator">&lt;</span> <span class="number">553</span> </span><br><span class="line">) previous</span><br><span class="line">  <span class="keyword">ON</span> executions.ex_number <span class="operator">=</span> previous.ex_number</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> day_difference <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>更加优雅的写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  previous.ex_date <span class="keyword">AS</span> <span class="keyword">start</span>,</span><br><span class="line">  executions.ex_date <span class="keyword">AS</span> <span class="keyword">end</span>,</span><br><span class="line">  JULIANDAY(executions.ex_date) <span class="operator">-</span> JULIANDAY(previous.ex_date)</span><br><span class="line">    <span class="keyword">AS</span> day_difference</span><br><span class="line"><span class="keyword">FROM</span> executions</span><br><span class="line"><span class="comment">-- alias --</span></span><br><span class="line"><span class="keyword">JOIN</span> executions previous</span><br><span class="line">  <span class="keyword">ON</span> executions.ex_number <span class="operator">=</span> previous.ex_number <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> day_difference <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h1 id="Sql-murder-mystery"><a href="#Sql-murder-mystery" class="headerlink" title="Sql murder mystery"></a>Sql murder mystery</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>查找案件信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> crime_scene_report</span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">date</span> <span class="operator">=</span> <span class="number">20180115</span></span><br><span class="line">  <span class="keyword">AND</span> type <span class="operator">=</span> <span class="string">&#x27;murder&#x27;</span> </span><br><span class="line">  <span class="keyword">AND</span> city <span class="operator">=</span> <span class="string">&#x27;SQL City&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>date</th>
<th>type</th>
<th>description</th>
<th>city</th>
</tr>
</thead>
<tbody><tr>
<td>20180115</td>
<td>murder</td>
<td>Security footage shows that there were 2 witnesses. The first witness lives at the last house on “Northwestern Dr”. The second witness, named Annabel, lives somewhere on “Franklin Ave”.</td>
<td>SQL City</td>
</tr>
</tbody></table>
<p>第一个目击者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> person</span><br><span class="line"><span class="keyword">WHERE</span> address_street_name <span class="operator">=</span> <span class="string">&#x27;Northwestern Dr&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> address_number <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">1</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>license_id</th>
<th>address_number</th>
<th>address_street_name</th>
<th>ssn</th>
</tr>
</thead>
<tbody><tr>
<td>14887</td>
<td>Morty Schapiro</td>
<td>118009</td>
<td>4919</td>
<td>Northwestern Dr</td>
<td>111564949</td>
</tr>
</tbody></table>
<p>第二个目击者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> person</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%Annabel%&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> address_street_name <span class="operator">=</span> <span class="string">&#x27;Franklin Ave&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>license_id</th>
<th>address_number</th>
<th>address_street_name</th>
<th>ssn</th>
</tr>
</thead>
<tbody><tr>
<td>16371</td>
<td>Annabel Miller</td>
<td>490173</td>
<td>103</td>
<td>Franklin Ave</td>
<td>318771143</td>
</tr>
</tbody></table>
<p>拿到 id 后，可以去 interviews 中查找：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> interview</span><br><span class="line"><span class="keyword">WHERE</span> person_id <span class="operator">=</span> <span class="number">14887</span></span><br><span class="line"><span class="keyword">OR</span> person_id <span class="operator">=</span> <span class="number">16371</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>person_id</th>
<th>transcript</th>
</tr>
</thead>
<tbody><tr>
<td>14887</td>
<td>I heard a gunshot and then saw a man run out. He had a “Get Fit Now Gym” bag. The membership number on the bag started with “48Z”. Only gold members have those bags. The man got into a car with a plate that included “H42W”.</td>
</tr>
<tr>
<td>16371</td>
<td>I saw the murder happen, and I recognized the killer from my gym when I was working out last week on January the 9th.</td>
</tr>
</tbody></table>
<p>由此处信息可知，凶手有以下特征：</p>
<ul>
<li>拥有 “Get Fit Now Gym” 包，进出 Gym，并且有一次是 1 月 9 日。</li>
<li>包号码以”48Z”开头。</li>
<li>车牌号包含 “H42W”。</li>
</ul>
<p>先从 “48Z” 入手：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> get_fit_now_member</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">LIKE</span> <span class="string">&#x27;48Z%&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>person_id</th>
<th>name</th>
<th>membership_start_date</th>
<th>membership_status</th>
</tr>
</thead>
<tbody><tr>
<td>48Z38</td>
<td>49550</td>
<td>Tomas Baisley</td>
<td>20170203</td>
<td>silver</td>
</tr>
<tr>
<td>48Z7A</td>
<td>28819</td>
<td>Joe Germuska</td>
<td>20160305</td>
<td>gold</td>
</tr>
<tr>
<td>48Z55</td>
<td>67318</td>
<td>Jeremy Bowers</td>
<td>20160101</td>
<td>gold</td>
</tr>
</tbody></table>
<p>再查找车牌号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> drivers_license</span><br><span class="line"><span class="keyword">WHERE</span> plate_number <span class="keyword">LIKE</span> <span class="string">&#x27;%H42W%&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
<th>height</th>
<th>eye_color</th>
<th>hair_color</th>
<th>gender</th>
<th>plate_number</th>
<th>car_make</th>
<th>car_model</th>
</tr>
</thead>
<tbody><tr>
<td>183779</td>
<td>21</td>
<td>65</td>
<td>blue</td>
<td>blonde</td>
<td>female</td>
<td>H42W0X</td>
<td>Toyota</td>
<td>Prius</td>
</tr>
<tr>
<td><strong>423327</strong></td>
<td>30</td>
<td>70</td>
<td>brown</td>
<td>brown</td>
<td>male</td>
<td>0H42W2</td>
<td>Chevrolet</td>
<td>Spark LS</td>
</tr>
<tr>
<td>664760</td>
<td>21</td>
<td>71</td>
<td>black</td>
<td>black</td>
<td>male</td>
<td>4H42WR</td>
<td>Nissan</td>
<td>Altima</td>
</tr>
</tbody></table>
<p>最后看看进出日期：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> get_fit_now_check_in</span><br><span class="line"><span class="keyword">WHERE</span> check_in_date <span class="operator">=</span> <span class="number">20180109</span></span><br><span class="line"><span class="keyword">AND</span> membership_id <span class="keyword">LIKE</span> <span class="string">&#x27;48Z%&#x27;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>membership_id</th>
<th>check_in_date</th>
<th>check_in_time</th>
<th>check_out_time</th>
</tr>
</thead>
<tbody><tr>
<td>48Z7A</td>
<td>20180109</td>
<td>1600</td>
<td>1730</td>
</tr>
<tr>
<td>48Z55</td>
<td>20180109</td>
<td>1530</td>
<td>1700</td>
</tr>
</tbody></table>
<p>这样直接把凶手范围缩小到两个人了。</p>
<p>看一下这两个人的个人信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> person </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">28819</span></span><br><span class="line"><span class="keyword">OR</span> id <span class="operator">=</span> <span class="number">67318</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>license_id</th>
<th>address_number</th>
<th>address_street_name</th>
<th>ssn</th>
</tr>
</thead>
<tbody><tr>
<td>28819</td>
<td>Joe Germuska</td>
<td>173289</td>
<td>111</td>
<td>Fisk Rd</td>
<td>138909730</td>
</tr>
<tr>
<td>67318</td>
<td>Jeremy Bowers</td>
<td><strong>423327</strong></td>
<td>530</td>
<td>Washington Pl, Apt 3A</td>
<td>871539279</td>
</tr>
</tbody></table>
<p>第二个人的 license_id 和前面对上了，说明凶手是他！</p>
<blockquote>
<p>Congrats, you found the murderer! But wait, there’s more… If you think you’re up for a challenge, try querying the interview transcript of the murderer to find the real villain behind this crime. If you feel especially confident in your SQL skills, try to complete this final step with no more than 2 queries. Use this same INSERT statement with your new suspect to check your answer.</p>
</blockquote>
<p>案件还有幕后黑手，查找凶手的 interview，挑战是使用两次以内的查询。</p>
<h2 id="第二步（多步查询）"><a href="#第二步（多步查询）" class="headerlink" title="第二步（多步查询）"></a>第二步（多步查询）</h2><p>先用笨办法查一查：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> interview</span><br><span class="line"><span class="keyword">WHERE</span> person_id <span class="operator">=</span> <span class="number">67318</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>person_id</th>
<th>transcript</th>
</tr>
</thead>
<tbody><tr>
<td>67318</td>
<td>I was hired by a woman with a lot of money. I don’t know her name but I know she’s around 5’5” (65”) or 5’7” (67”). She has red hair and she drives a Tesla Model S. I know that she attended the SQL Symphony Concert 3 times in December 2017.</td>
</tr>
</tbody></table>
<p>查找 drivers_license 表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> drivers_license</span><br><span class="line"><span class="keyword">WHERE</span> car_make <span class="operator">=</span> <span class="string">&#x27;Tesla&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> car_model <span class="operator">=</span> <span class="string">&#x27;Model S&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> hair_color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> gender <span class="operator">=</span> <span class="string">&#x27;female&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> age <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">70</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>age</th>
<th>height</th>
<th>eye_color</th>
<th>hair_color</th>
<th>gender</th>
<th>plate_number</th>
<th>car_make</th>
<th>car_model</th>
</tr>
</thead>
<tbody><tr>
<td>202298</td>
<td>68</td>
<td>66</td>
<td>green</td>
<td>red</td>
<td>female</td>
<td>500123</td>
<td>Tesla</td>
<td>Model S</td>
</tr>
<tr>
<td>291182</td>
<td>65</td>
<td>66</td>
<td>blue</td>
<td>red</td>
<td>female</td>
<td>08CM64</td>
<td>Tesla</td>
<td>Model S</td>
</tr>
</tbody></table>
<p>从 license_id 得到人的 id：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;person&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> license_id <span class="operator">=</span> <span class="number">202298</span></span><br><span class="line">   <span class="keyword">OR</span> license_id <span class="operator">=</span> <span class="number">291182</span> </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>license_id</th>
<th>address_number</th>
<th>address_street_name</th>
<th>ssn</th>
</tr>
</thead>
<tbody><tr>
<td>90700</td>
<td>Regina George</td>
<td>291182</td>
<td>332</td>
<td>Maple Ave</td>
<td>337169072</td>
</tr>
<tr>
<td>99716</td>
<td>Miranda Priestly</td>
<td>202298</td>
<td>1883</td>
<td>Golden Ave</td>
<td>987756388</td>
</tr>
</tbody></table>
<p>最后使用”参加音乐会”的条件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> facebook_event_checkin</span><br><span class="line"><span class="keyword">WHERE</span> <span class="type">date</span> <span class="operator">&gt;=</span> <span class="number">20171201</span></span><br><span class="line">  <span class="keyword">AND</span> <span class="type">date</span> <span class="operator">&lt;=</span> <span class="number">20171231</span></span><br><span class="line">  <span class="keyword">AND</span> event_name <span class="operator">=</span> <span class="string">&#x27;SQL Symphony Concert&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> person_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(person_id) <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>person_id</th>
<th>event_id</th>
<th>event_name</th>
<th>date</th>
</tr>
</thead>
<tbody><tr>
<td>24556</td>
<td>1143</td>
<td>SQL Symphony Concert</td>
<td>20171224</td>
</tr>
<tr>
<td>99716</td>
<td>1143</td>
<td>SQL Symphony Concert</td>
<td>20171229</td>
</tr>
</tbody></table>
<p>对比可知幕后黑手是 Miranda Priestly。</p>
<h2 id="第二步（两步查询）"><a href="#第二步（两步查询）" class="headerlink" title="第二步（两步查询）"></a>第二步（两步查询）</h2><p>先查找 interview，因为信息蕴含在他的话语中，这一步没法被合并。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> interview</span><br><span class="line"><span class="keyword">WHERE</span> person_id <span class="operator">=</span> <span class="number">67318</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>person_id</th>
<th>transcript</th>
</tr>
</thead>
<tbody><tr>
<td>67318</td>
<td>I was hired by a woman with a lot of money. I don’t know her name but I know she’s around 5’5” (65”) or 5’7” (67”). She has red hair and she drives a Tesla Model S. I know that she attended the SQL Symphony Concert 3 times in December 2017.</td>
</tr>
</tbody></table>
<p>接下来的查询用一次完成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> drivers_license l</span><br><span class="line"><span class="comment">-- 连接写在 WHERE 前面 --</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> person p	</span><br><span class="line"><span class="keyword">ON</span> p.license_id <span class="operator">=</span> l.id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> facebook_event_checkin</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="type">date</span> <span class="operator">&gt;=</span> <span class="number">20171201</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="type">date</span> <span class="operator">&lt;=</span> <span class="number">20171231</span></span><br><span class="line">    <span class="keyword">AND</span> event_name <span class="operator">=</span> <span class="string">&#x27;SQL Symphony Concert&#x27;</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> person_id</span><br><span class="line">  <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(person_id) <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">) f </span><br><span class="line"><span class="keyword">ON</span> p.id <span class="operator">=</span> f.person_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> car_make <span class="operator">=</span> <span class="string">&#x27;Tesla&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> car_model <span class="operator">=</span> <span class="string">&#x27;Model S&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> hair_color <span class="operator">=</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> gender <span class="operator">=</span> <span class="string">&#x27;female&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> age <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line"><span class="keyword">AND</span> age <span class="operator">&lt;=</span> <span class="number">70</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>Miranda Priestly</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>hrbrid</tag>
      </tags>
  </entry>
  <entry>
    <title>JSBridge</title>
    <url>/2022/10/13/jsb/</url>
    <content><![CDATA[<h1 id="JSBridge"><a href="#JSBridge" class="headerlink" title="JSBridge"></a>JSBridge</h1><h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>在讲JSBridge前，先回顾一下JSONP的知识，因为它们的思想有共通之处：</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JSONP是<code>JSON with Padding</code>的略称，前端定义好回调函数，函数名放在url中传给后端，后端拿到函数名，构造出执行函数的字符串返回给前端，前端收到后便会执行该回调，回调函数中可以拿到后端传过来的数据。</p>
<p>原理：src属性不受同源策略的限制，<code>img</code>、<code>script</code>等标签都不受同源策略的影响。</p>
<p>缺点：由于JSONP只支持get请求，且具有一定安全漏洞，一般不在实际场景中使用。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以最简单的场景为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;amount&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>Btn<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.btn&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> amount = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.amount&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 创建script标签</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 随机生成回调函数名</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> functionName = <span class="string">&#x27;func&#x27;</span> + <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10000</span>, <span class="number">10</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 将回调函数绑在window对象上</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">window</span>[functionName] = <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="built_in">console</span>.log(result)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">if</span> (result.name === <span class="string">&#x27;success&#x27;</span>) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            amount.innerText = amount.innerText - <span class="number">1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">          &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 设置src，请求的url带上回调函数名</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        script.src = <span class="string">`http://127.0.0.1:3000?callback=<span class="subst">$&#123;functionName&#125;</span>`</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 发送请求</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">document</span>.body.appendChild(script)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="comment">// 请求结束，从window上移除绑定的回调函数</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        script.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          e.currentTarget.remove()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">delete</span> <span class="built_in">window</span>[functionName]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        script.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          alert(<span class="string">&#x27;Fail&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          e.currentTarget.remove()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">          <span class="keyword">delete</span> <span class="built_in">window</span>[functionName]</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      &#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> http <span class="keyword">from</span> <span class="string">&#x27;http&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> url <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 解析得到params</span></span><br><span class="line">  <span class="keyword">const</span> &#123; query &#125; = url.parse(req.url)</span><br><span class="line">  <span class="keyword">const</span> params = qs.parse(query)</span><br><span class="line">  <span class="comment">// 后端要传的数据</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;success&#x27;</span> &#125;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (params.callback) &#123;</span><br><span class="line">    <span class="comment">// 构造出执行函数的字符串</span></span><br><span class="line">    str = <span class="string">`<span class="subst">$&#123;params.callback&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span></span><br><span class="line">    <span class="comment">// 返回给前端</span></span><br><span class="line">    res.end(str)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Server is running on port 3000...&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>前端发送请求的url可以是：<code>http://127.0.0.1:3000?callback=func1234</code></p>
<p>后端获取回调函数名<code>func1234</code>，构造好字符串<code>func1234(&#123; name: &#39;success&#39; &#125;)</code></p>
<p>前端拿到该字符串后，就会调用回调函数，拿到后端传的数据。</p>
<p>可见，JSONP的模式大概是：<strong>前端随机生成了回调函数名，把函数名告诉后端，后端从url中解析出函数名，完成自身的逻辑后，将构造好的字符串返回给前端，前端执行回调。</strong></p>
<h2 id="JSB"><a href="#JSB" class="headerlink" title="JSB"></a>JSB</h2><blockquote>
<p>H5 -&gt; 前端，Native/原生 -&gt; 客户端</p>
<p>安卓 -&gt; Java/Kotlin，IOS -&gt; OC/Swift</p>
<p>webview 是一个基于 webkit 的引擎，可以解析 DOM 元素，展示 html 页面的控件。</p>
<ul>
<li>显示和渲染Web页面</li>
<li>直接使用html文件（网络上或本地assets中）作布局</li>
<li>可和JavaScript交互调用</li>
</ul>
<p>—— <a href="https://www.jianshu.com/p/3c94ae673e2a">Carson带你学Android：最全面、易懂的Webview使用教程</a></p>
</blockquote>
<p>现在市面上的 App，基本上不是纯 Native 实现，客户端内置 webview，不少页面都嵌入了 H5，这种称作<code>Hybrid App</code>，那么 H5 和 Native 必然要进行通信。</p>
<p>JSBridge，是沟通 JS 和 Native 的桥梁，为<strong>双向信道</strong>，使 JS 可以调 Native 的 Api，从而拥有部分原生的能力。这样，页面中的 H5 部分就可以使用地址位置、摄像头等原生才有的功能。同时，Native 也可以调用JS。</p>
<p>我们要实现的 JSB，功能大致为：前端向客户端发送请求，意在调用客户端的某方法，达到前端使用客户端能力的效果，前端也定义了回调函数，并且把回调函数名告知客户端。客户端拦截请求，执行对应的方法，然后通过<strong>特定 API</strong>（如下），调用前端的回调函数。</p>
<h3 id="Native-调用-JS"><a href="#Native-调用-JS" class="headerlink" title="Native 调用 JS"></a>Native 调用 JS</h3><p>安卓和IOS都提供了调用JS的方法，<strong>被调用的方法需要在 JS 全局上下文上</strong>。</p>
<p>其中安卓有两种方法可供选择：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loadUrl</span></span><br><span class="line">webview.loadUrl(<span class="string">&quot;javascript: func()&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// evaluateJavascript</span></span><br><span class="line">webView.evaluateJavascript(</span><br><span class="line">  <span class="string">&quot;javascript:func()&quot;</span>,</span><br><span class="line">  <span class="comment">// @函数名 可以确定从哪个函数体中返回</span></span><br><span class="line">  <span class="comment">// 如果函数写成嵌套形式，内层的函数想要返回上一层，必须加@函数名</span></span><br><span class="line">  ValueCallback &#123; <span class="keyword">return</span><span class="symbol">@ValueCallback</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>可见，客户端想调用前端只需要直接调用这些方法，把JS代码字符串传入即可。</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>loadUrl</td>
<td>兼容性好</td>
<td>1. 会刷新页面 2. 无法获取 js 方法执行结果</td>
</tr>
<tr>
<td>evaluateJavascript</td>
<td>1. 性能好 2. 可获取 js 执行后的返回值</td>
<td>仅在安卓 4.4 以上可用</td>
</tr>
</tbody></table>
<p>由于现在98%以上的手机安卓版本&gt;=5，所以采用 evaluateJavascript。</p>
<h3 id="JS-调用-Native"><a href="#JS-调用-Native" class="headerlink" title="JS 调用 Native"></a>JS 调用 Native</h3><p>JS 调用 Native 的实现方式一般至少有两种，分别是：拦截 URL Schema、注入 JS 上下文，本文介绍拦截 URL Schema的安卓实现。</p>
<p><strong>拦截 URL SCHEME 的主要流程是：前端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</strong></p>
<h4 id="URL-SCHEME"><a href="#URL-SCHEME" class="headerlink" title="URL SCHEME"></a>URL SCHEME</h4><p>URL SCHEME 是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: <code>jsbridge://showToast?msg=hello</code>，protocol 是 jsbridge，host 是 showToast。</p>
<p>jsbridge:// 只是一种规则，可以<strong>根据业务进行制定，使其具有含义</strong>。</p>
<p>在下面实现的时候，参数使用了JSON的形式，如<code>jsbridge://showToast?&#123;&quot;data&quot;: &#123;&quot;msg&quot;: &quot;hello&quot;&#125;, &quot;callbackName&quot;: &quot;callback1234&quot;&#125;</code></p>
<h4 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h4><p>接下来分别看看前端和客户端应该如何配合，实现相互通信：</p>
<p>规定 protocol 为 jsbridge，即 URL SCHEME 以 jsbridge:// 开头，客户端拿到 url 后进行解析，如果以 jsbridge 开头，则执行对应逻辑。</p>
<p>前端和 JSONP 一样，随机生成一个回调函数名，把回调函数绑定在 window 上，URL SCHEME 作为请求的 url，URL SCHEME 中包含了数据、以及回调函数名，然后使用 iframe 发送请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSBridge</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 要请求Native的方法名，参数，回调</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">call</span>(<span class="params">methodName, arg, callback</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// &#123; data: &#123;msg: &quot;hello&quot;&#125;&#125;</span></span><br><span class="line">    <span class="keyword">const</span> args = &#123;</span><br><span class="line">      <span class="attr">data</span>: arg === <span class="literal">undefined</span> ? <span class="literal">null</span> : <span class="built_in">JSON</span>.stringify(arg),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 生成回调函数名</span></span><br><span class="line">      <span class="keyword">const</span> callbackName = <span class="string">&#x27;CALLBACK&#x27;</span> + <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">10000</span>)</span><br><span class="line">      <span class="comment">// 被调用的方法需要在 JS 全局上下文上</span></span><br><span class="line">      <span class="built_in">window</span>[callbackName] = callback</span><br><span class="line">      <span class="comment">// &#123; data: &#123;msg: &quot;hello&quot;&#125;, callbackName: &quot;CALLBACK1234&quot;&#125;</span></span><br><span class="line">      args[<span class="string">&#x27;callbackName&#x27;</span>] = callbackName</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// URL SCHEME，协议为jsbridge，方法名作为host</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="string">&#x27;jsbridge://&#x27;</span> + methodName + <span class="string">&#x27;?&#x27;</span> + <span class="built_in">JSON</span>.stringify(args)</span><br><span class="line">    <span class="comment">// 使用iframe发送请求，不要使用window.location.href，据说是因为多次请求会被合并为一次</span></span><br><span class="line">    <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line">    iframe.src = url</span><br><span class="line">    iframe.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line">    <span class="built_in">window</span>.setTimeout(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(iframe)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arg = &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&quot;The message is from JS!&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 请求Native的showToast方法</span></span><br><span class="line">JSBridge.call(<span class="string">&#x27;showToast&#x27;</span>, arg, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  alert(res.msg);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="安卓实现"><a href="#安卓实现" class="headerlink" title="安卓实现"></a>安卓实现</h4><h5 id="NativeMethods"><a href="#NativeMethods" class="headerlink" title="NativeMethods"></a>NativeMethods</h5><p>既然前端请求了客户端的 showToast 方法，先来实现该方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showToast</span><span class="params">(view: <span class="type">WebView</span>, arg: <span class="type">JSONObject</span>, callBack: <span class="type">CallBack</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 拿到h5传过来的msg，展示在Toast中</span></span><br><span class="line">        <span class="keyword">val</span> message = arg.optString(<span class="string">&quot;msg&quot;</span>)</span><br><span class="line">        Toast.makeText(view.context, message, Toast.LENGTH_SHORT).show()</span><br><span class="line">        <span class="comment">// 执行h5的回调</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建hashMap，作为res data返回给h5</span></span><br><span class="line">            <span class="comment">// &#123; msg: &quot;js 调用 native 成功！&quot;&#125;</span></span><br><span class="line">            <span class="keyword">val</span> result = JSONObject()</span><br><span class="line">            result.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;js 调用 native 成功！&quot;</span>)</span><br><span class="line">            <span class="comment">// 执行回调，h5弹出alert</span></span><br><span class="line">            callBack.apply(result)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理很简单，拿到前端传过来的 msg，展示在 Toast 里，然后调用 JS 的回调函数，此处使用了 callBack.apply 方法，来看看该方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallBack</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> mWebView: WebView?, <span class="keyword">private</span> <span class="keyword">val</span> callbackName: String) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(jsonObject: <span class="type">JSONObject</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// native调用js</span></span><br><span class="line">        mWebView?.evaluateJavascript(</span><br><span class="line">          <span class="comment">// 此处 $变量名 类似于js的$&#123;&#125;</span></span><br><span class="line">            <span class="string">&quot;javascript:<span class="variable">$callbackName</span>(<span class="variable">$jsonObject</span>)&quot;</span>,</span><br><span class="line">            ValueCallback &#123; <span class="keyword">return</span><span class="symbol">@ValueCallback</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CallBack 类仅仅是作了一层封装，唯一做的事就是调了 evaluateJavascript 方法，即 Native 调 JS。</p>
<p>callbackName 是在别的地方传给 CallBack 类的，见下文。</p>
<h5 id="JSBridge-register"><a href="#JSBridge-register" class="headerlink" title="JSBridge.register"></a>JSBridge.register</h5><p>然后看看客户端的 JSBridge 类，其主要有 register 和 call 两个方法。</p>
<p>register 用于将客户端暴露出来的方法塞到 hashmap 中，为一个双层的 map 结构，里层 map 的 key 为方法名，val 为 method 的反射。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exposeMethods 数据结构如下，JSBridge是类名，下边有 showToast 等方法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 为什么这里不叫NativeMthods，而要注册成JSBridge呢，个人理解是，可能和业务有关</span></span><br><span class="line">  <span class="comment">// 可能多个类下的方法，在业务上属于JSBridge，所以把这些类的方法都打包进来</span></span><br><span class="line">  JSBridge: &#123;</span><br><span class="line">    showToast: (showToast方法的反射)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// object 声明单例，同时该类下的所有方法成为静态方法</span></span><br><span class="line"><span class="keyword">object</span> JSBridge &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> exposeMethods: MutableMap&lt;String, HashMap&lt;String?, Method&gt;&gt; = HashMap()</span><br><span class="line">    <span class="comment">// 这个map是为了查出方法所属类的类名，原因之后讲</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> classAndMethods: MutableMap&lt;String, HashMap&lt;String?, Method&gt;&gt; = HashMap()</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">(exposeName: <span class="type">String</span>, classz: <span class="type">Class</span>&lt;*&gt;, className: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> allMethods = getAllMethod(classz)</span><br><span class="line">        <span class="keyword">if</span> (!exposeMethods.containsKey(exposeName)) &#123;</span><br><span class="line">            exposeMethods[exposeName] = allMethods</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!classAndMethods.containsKey((className))) &#123;</span><br><span class="line">            classAndMethods[className] = allMethods</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// register的辅助方法，收集一个类下符合条件的方法，打包成一个hashmap返回</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAllMethod</span><span class="params">(injectedCls: <span class="type">Class</span>&lt;*&gt;)</span></span>: HashMap&lt;String?, Method&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> methodHashMap = HashMap&lt;String?, Method&gt;()</span><br><span class="line">        <span class="comment">// 该类下声明的全部方法的反射</span></span><br><span class="line">        <span class="keyword">val</span> methods = injectedCls.declaredMethods</span><br><span class="line">        <span class="keyword">for</span> (method <span class="keyword">in</span> methods) &#123;</span><br><span class="line">            <span class="comment">// 判断是公有方法，如果是private，肯定不希望暴露出去被h5调用</span></span><br><span class="line">            <span class="keyword">val</span> modifiers = method.modifiers</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(modifiers)) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个参数为 Webview 类的实例</span></span><br><span class="line">            <span class="comment">// 第二个参数为 JSONObject 类的实例</span></span><br><span class="line">            <span class="comment">// 第三个参数为 CallBack 类的实例</span></span><br><span class="line">            <span class="keyword">val</span> parameters = method.parameterTypes</span><br><span class="line">            <span class="keyword">if</span> (parameters.size == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parameters[<span class="number">0</span>] == WebView::<span class="keyword">class</span>.java &amp;&amp; parameters[<span class="number">1</span>] == JSONObject::<span class="keyword">class</span>.java &amp;&amp; parameters[<span class="number">2</span>] == CallBack::<span class="keyword">class</span>.java) &#123;</span><br><span class="line">                    <span class="comment">// 以上条件都满足，则加入 methodHashMap</span></span><br><span class="line">                    <span class="comment">// 该method为反射，需要用invoke调用</span></span><br><span class="line">                    methodHashMap[method.name] = method</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> methodHashMap</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">call</span> <span class="params">()</span></span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JSBridge-call"><a href="#JSBridge-call" class="headerlink" title="JSBridge.call"></a>JSBridge.call</h5><p>call 用来响应前端的请求，由上文可知，从 URL SCHEME 中可以拿到方法名，然后可以在 hashmap 中查找，拿到方法的反射，最后使用 <code>method.invoke()</code>来调用该方法。</p>
<blockquote>
<p>注意前面声明了变量 classAndMethods，这个数据结构和 exposeMethods 类似，只不过 key 就是类名，设立这个数据结构的原因是，method.invoke() 的第一个参数要求传<code>所调用方法所属类的实例对象</code>，此处 showToast 属于 NativeMethods 类，所以要传入它的实例对象，而我实在没搞懂如何根据方法的反射，获取该类的实例对象，因此使用了不优雅的实现，即先创建了 hashmap，然后用两层 for 循环去查出类名，最后获取实例对象，当作 invoke 的第一个参数传入。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">(webView: <span class="type">WebView</span>?, urlString: <span class="type">String</span>?)</span></span>: String? &#123;</span><br><span class="line">        <span class="comment">// 判断字符串是否以 jsbridge 开头</span></span><br><span class="line">        <span class="keyword">if</span> (urlString != <span class="string">&quot;&quot;</span> &amp;&amp; urlString != <span class="literal">null</span> &amp;&amp; urlString.startsWith(<span class="string">&quot;jsbridge&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 将该字符串转成 Uri 格式</span></span><br><span class="line">            <span class="keyword">val</span> uri = Uri.parse(urlString)</span><br><span class="line">            <span class="comment">// 获取其中的 host名，即方法名</span></span><br><span class="line">            <span class="keyword">val</span> methodName = uri.host</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 query，即方法参数和 js 回调函数名组合的对象</span></span><br><span class="line">                <span class="keyword">val</span> args = JSONObject(uri.query)</span><br><span class="line">                <span class="comment">// 方法参数，加工后的arg是对象的形式，arg.msg就能拿到属性</span></span><br><span class="line">                <span class="keyword">val</span> arg = JSONObject(args.getString(<span class="string">&quot;data&quot;</span>))</span><br><span class="line">                <span class="comment">// 回调函数名</span></span><br><span class="line">                <span class="keyword">val</span> callbackName = args.getString(<span class="string">&quot;callbackName&quot;</span>)</span><br><span class="line">                <span class="comment">// 查找 exposeMethods 的映射，找到对应的方法并执行该方法</span></span><br><span class="line">                <span class="keyword">if</span> (exposeMethods.containsKey(<span class="string">&quot;JSBridge&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 此处我们假设所有jsb相关方法都定义在JSBridge这个类中</span></span><br><span class="line">                    <span class="comment">// 当协议不同时，则去别的类中找方法</span></span><br><span class="line">                    <span class="keyword">val</span> methodHashMap = exposeMethods[<span class="string">&quot;JSBridge&quot;</span>]</span><br><span class="line">                    <span class="keyword">if</span> (methodHashMap != <span class="literal">null</span> &amp;&amp; methodHashMap.size != <span class="number">0</span> &amp;&amp; methodHashMap.containsKey(</span><br><span class="line">                            methodName</span><br><span class="line">                        )</span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">val</span> method = methodHashMap[methodName]</span><br><span class="line">                        <span class="keyword">var</span> className = <span class="string">&quot;&quot;</span></span><br><span class="line">                        <span class="keyword">for</span> ((_className, methods) <span class="keyword">in</span> classAndMethods)&#123;</span><br><span class="line">                            <span class="keyword">for</span> ((_, methodReflection) <span class="keyword">in</span> methods) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (methodReflection == method) &#123;</span><br><span class="line">                                    className = _className</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">val</span> instance = Class.forName(className).newInstance()</span><br><span class="line">                        <span class="comment">// NativeMethods 下的方法都注册到了JSBridge中，这里调用的是showToast</span></span><br><span class="line">                        <span class="comment">// 第一个参数传null会遇到 null receiver 异常，因此又弄了一个map</span></span><br><span class="line">                        <span class="comment">// 该map的最外层key是类的名字，这样可以把类名查出来，然后构造一个实例对象，传入第一个参数</span></span><br><span class="line">                        <span class="comment">// Java中应该没有这个问题，直接传null就行了</span></span><br><span class="line">                        method?.invoke(instance, webView, arg, CallBack(webView, callbackName))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>到这一步，还有一个问题，就是如何在哪里执行 call 方法。</p>
<p>webview 当收到跳转请求时，会经过 WebViewClient 类的 shouldOverrideUrlLoading 方法，因此我们需要覆写该方法。假设我们请求的 url 为<code>https://www.baidu.com</code> 如果 return false，webview 会继续加载百度的页面，如果 return true，则会拦截该请求，停止加载，这里应该将请求拦截，调用 JSBridge.call 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.urlschema.JSBridge.call</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSBridgeViewClient</span> : <span class="type">WebViewClient</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 通过覆盖 WebViewClient 类的 shouldOverrideUrlLoading 方法进行拦截</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(view: <span class="type">WebView</span>, url: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        call(view, url)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一切都完成后，JSBridge 就可以正常工作了，如图：</p>
<img src="https://s1.ax1x.com/2022/09/01/v5G0EV.jpg" style="zoom: 50%;">

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>JSONP 和 JSB 还是有一定相似之处的，都是由前端发起请求，构造url，告诉了对方回调函数的名称，经过 客户端/后端 的处理，再执行前端的回调函数。</p>
<p>由于笔者对安卓只是初步入门的水平，Java/Kotlin 也只是了解的程度，不准确的地方希望大家谅解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/mcuking/JSBridge">mcuking/JSBridge</a></p>
<p><a href="https://github.com/SDBridge/SDBridgeKotlin">SDBridge/SDBridgeKotlin</a></p>
<p><a href="https://juejin.cn/post/6844903640520474637">Hybrid App技术解析 – 原理篇</a></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/DanmoSAMA/kotlin-jsb">Demo，需要使用Android Studio运行</a></p>
]]></content>
      <categories>
        <category>hybrid</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>hrbrid</tag>
      </tags>
  </entry>
  <entry>
    <title>git 笔记</title>
    <url>/2022/10/13/git%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p><code>git status -s</code> 或者 –short 可以查看简略状态信息：</p>
<p>左侧的状态一共有两列。</p>
<ul>
<li><p>?? 表示还没有被追踪的文件。</p>
</li>
<li><p>左侧的M，或者说绿色的M，表示该文件有修改被添加到暂存区 。</p>
</li>
<li><p>右侧的M，或者说红色的M，表示该文件在工作区有修改，未添加到暂存区。</p>
<p>综上，MM 表示文件先修改了一部分，add，再修改了一部分。</p>
</li>
<li><p>D 表示文件被删除。</p>
</li>
</ul>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p><code>git diff</code> 直接使用，可以查看工作区具体有哪些修改。</p>
<p><code>git diff --staged</code> 可以对比暂存区和最近的一次修改，–cached 选项用法与此相同。</p>
<p>我们想知道 B 相对 A 多了哪些提交，如果 A 是 B 的祖先，直接 diff 即可。如果 A 和 B 分叉过，diff 会同时显示 A 中新增的内容“已删除”。为了避免这个现象，需要先找到 A 和 B 的公共祖先，再进行 diff。</p>
<p><code>git merge-base B A </code> 会输出两个分支最近公共祖先的 Hash，目测交换顺序也可以，然后 diff，或者合并为一步。</p>
<p><code>git diff $(git merge-base B A)</code></p>
<p><code>git diff A...B</code> 上边的语法糖，也会找最近公共祖先，不能交换 A B 的顺序。</p>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p><code>git commit -v</code> 会在编辑 message 界面时，列举出当前的 diff 信息，表明当前要提交哪些修改。</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p><code>git rm</code> 会直接从硬盘删除文件，如果文件在工作区或暂存区有修改，需要加 -f 强制删除。</p>
<p>如果想在硬盘中保留，但不想让 git 继续追踪，可以加 –cached，这样文件会变为 untracked file。</p>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p><code>git mv &lt;old_name&gt; &lt;new_name&gt;</code> 可以用于文件改名，修改会被直接添加到暂存区，git 会认为这是一个 renamed file。</p>
<p>如果是直接在 vscode 对文件进行改名，则 git 认为原来的文件被删除，新的文件成为 untracked file。</p>
<p>不过，mv 只是一个语法糖，修改的本质还是先删后增，如果先 mv，再 git restore –staged，能观察到和上一行一样的效果。</p>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>git log 选项：</p>
<p><code>-p</code>：详细显示每次提交都有哪些修改。</p>
<p><code>-&lt;n&gt;</code>：限制 log 的条数，只显示最新 n 次修改的 log。</p>
<p><code>--stat</code>：显示每次提交都有哪些修改的缩略信息，只能看到每个文件的++–符号。</p>
<p><code>--pretty</code>：指明格式，值可以是 oneline，如 –pretty=online。这里还可以使用 format。</p>
<p><code>--oneline</code>：是上边的缩略写法，同时也包括了<code>--abbrev-commit</code> 的作用，即不显示完整哈希值。</p>
<p><code>--graph</code>：显示分支和合并图。</p>
<p><code>--since</code>：指定时间。值可以是：2.weeks，”2008-01-15”，”2 years 1 day 3 minutes ago”。</p>
<p><code>--author</code>：指定作者。</p>
<p><code>--grep</code>：在 message 中搜索关键词。</p>
<p><code>-S</code>：提供一个字符串，只列举增删了该字符串的提交。比如我在 a.txt 里新增了 Danmo 后提交，然后 git log -S “Danmo”，就能找到我的这一次提交。</p>
<p><code>--</code>：提供文件路径，查找和该文件相关的提交的 log。</p>
<p><code>--all-match</code>：如果指定了多个筛选条件，需要加这个选项，拿多个 –grep 举例，如果不加，只有第一个生效。</p>
<p><code>--decorate</code>：查看分支和 HEAD 指向哪次 commit。</p>
<p>一般 git log 只显示该分支指向的 commit 及之前的记录，<code>git log &lt;branch_name&gt;</code>  查看特定分支的记录，–all 显示所有记录。</p>
<p><code>git log --no-merges issue54..origin/master</code> 不显示合并记录，后面的参数表示 commit range，后者没有包含在前者中的记录。</p>
<p><code>git log branchA --not branchB</code> 显示 branchA 中没有包括在 branchB 中的提交，用来查看他人新的提交。</p>
<h2 id="amend"><a href="#amend" class="headerlink" title="amend"></a>amend</h2><p>如果刚刚完成了一次提交，发现有 forgotten_file 忘了提交，此时可以把它加入暂存区，然后 git commit –amend。</p>
<p>这种方式同样适用于修改 commit message。</p>
<p>–amend 会更改最后一次提交的 HASH，如果已经 push 就不要再更改。</p>
<p>如果不想修改 commit message 还可以添加 <code>--no-edit</code> 选项。</p>
<h1 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h1><p><code>git remote</code> 显示远程服务器 shortname，如果是 clone，默认名为 origin。</p>
<p><code>git remote -v</code> 可以显示 shortname 和 URL，可见只是用 origin 指代远程服务器 URL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">origin  https://github.com/DanmoSAMA/remote-sensing (fetch)</span><br><span class="line">origin  https://github.com/DanmoSAMA/remote-sensing (push)</span><br><span class="line"></span><br><span class="line">git push https://github.com/DanmoSAMA/remote-sensing == git push origin</span><br></pre></td></tr></table></figure>

<p>origin/master 可以访问 shortname 为 origin 的仓库的 master 分支。</p>
<p><code>git remote add &lt;shortname&gt; &lt;url&gt;</code> add 后面可以自定义 shortname。</p>
<p><code>git remote show &lt;remote&gt;</code> 查看 remote 的详细信息。</p>
<blockquote>
<p>This command shows which branch is automatically pushed to when you run <code>git push</code> while on certain branches. It also shows you which remote branches on the server you don’t yet have, which remote branches you have that have been removed from the server, and multiple local branches that are able to merge automatically with their remote-tracking branch when you run <code>git pull</code>.</p>
</blockquote>
<p><code>git remote rename &lt;old_name&gt; &lt;new_name&gt;</code> 更改 shortname。</p>
<p><code>git remote remove &lt;shortname&gt;</code> <code>git remote add &lt;shortname&gt; &lt;url&gt;</code></p>
<h1 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h1><p><code>git tag -l &quot;v1.8.5*&quot;</code> 使用通配符来筛 tag 列表，-l 指定通配符。</p>
<p><code>git tag -a v1.0 -m &lt;message&gt;</code> 创建 annotated tag，并附注信息。</p>
<p>-d 选项可以删除 tag。</p>
<p><code>git show &lt;tag_name&gt; </code>  可以连同对应的提交一起，查看某个 tag 信息。</p>
<p>Lightweight tag 仅仅用于标记某次 commit，创建时无需添加任何选项，git show 也只能看到 commit 信息。</p>
<p>如果想要对之前的 commit 打 tag，只需 <code>git tab -a v1.0 &lt;commit_hash&gt;</code>。</p>
<p><code> git push &lt;remote&gt; tags</code> 可以将所有 tags 发送到 remote。</p>
<p><code>git push &lt;remote&gt; --follow-tags</code> 仅发送 annotated tag。</p>
<p><code>git push &lt;remote&gt; --delete &lt;tagname&gt;</code> 删除 remote tag。</p>
<p>由于 tag 是指向 commit 的指针，因此可以应用于 detached HEAD 模式，<code>git checkout -b version2 v2.0.0</code> 从该 commit 分出了一个分支。</p>
<h1 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h1><h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><p><code>git switch -</code> 回到上一次切换前的分支。</p>
<p><code>git branch -v</code> 查看每个分支上的最后一次提交。</p>
<p><code>git branch -vv</code> 在上方基础上，查看 tracking branch。</p>
<p><code>git branch --merge</code> 查看哪些分支已经合并到了当前分支，–no-merge 查看没合并的分支。</p>
<p>没合并的分支，用 git branch -d 无法删除，需要用 -D 强行删除。</p>
<p><code>git branch --merge &lt;branch_name&gt;</code> 同上，但无需先切换到那个分支上。</p>
<p><strong><code>git branch --move &lt;old_name&gt; &lt;new_name&gt;</code> 修改本地分支名。</strong></p>
<p><code>git merge --abort</code> 终止 merge。</p>
<h2 id="remote-1"><a href="#remote-1" class="headerlink" title="remote"></a>remote</h2><p><code>git push --set-upstream origin &lt;new_name&gt; </code> 将此修改推到远程。</p>
<p><strong><code>git push origin --delete &lt;old_name&gt;</code> 删除远程的旧分支。</strong></p>
<p><code>git ls-remote &lt;remote&gt;</code>  列举远程分支。</p>
<p><code>git push origin 本地分支名:远程分支名</code>  push 时希望修改分支名称。</p>
<p>git fetch 后，本地会新增 origin/xxx 分支，这个分支不能修改，可以把它合并到本地已有分支，也可以新建一个分支，拥有和它一样的指向：<code>git checkout -b xxx origin/xxx</code>。</p>
<p><code>git switch -c &lt;branch&gt; --track &lt;remote&gt;/&lt;branch&gt;</code> 同理，<code>git switch --guess &lt;branch&gt;</code> 为其简写。</p>
<p>上面的做法，新建的分支会成为 tracking branch，追踪远程的 origin/xxx 分支。</p>
<p><code>git checkout --track origin/xxx</code> 是简写。</p>
<p><code>git branch -u origin/xxx</code> 已有分支，更改上游。</p>
<p>如果存在上游分支，在 merge 的时候可以用 <code>@&#123;u&#125;</code> 指代上游，如：git merge @{u}</p>
<p><code>git fetch --all</code> 拉取所有分支的更新。</p>
<p><code>git remote set-head origin &lt;origin_branch_name&gt;</code> 设置远程 HEAD 指向。</p>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p><code>git rebase master server</code> 把 server 分支 rebase 到 master 上，这样的好处是不需要先切到 server 分支。</p>
<p><code>git rebase --onto master server client</code>  先找到 client 分支，将 client 从 server 分叉之后的部分 rebase 到 master。</p>
<h3 id="perils-of-rebase"><a href="#perils-of-rebase" class="headerlink" title="perils of rebase"></a>perils of rebase</h3><p>如果对已经提交的分支进行 rebase，并且 push -f 强行提交，会出现问题。结合 git book 里面的图更好理解。</p>
<blockquote>
<p>If you only ever rebase commits that have never left your own computer, you’ll be just fine. If you rebase commits that have been pushed, but that no one else has based commits from, you’ll also be fine. If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble, and the scorn of your teammates.</p>
</blockquote>
<p>别人可能 fetch 过这个分支，并且合并到了自己的分支上（相当于 pull），假设这个分支包含了 C1 的修改。</p>
<p>此时，把 包含 C1 的分支 rebase，并且使用 push -f 提交。</p>
<p>别人再用 pull 时，把 rebase 后的分支与本地合并，此时 git log 会看到有两个一模一样的 C1 的提交，造成困惑。</p>
<p>如果团队中有成员进行过这样的操作，应该：You rebase, and I rebase.</p>
<p>如果是分步进行，则先 fetch，再 <code>git rebase origin/xxx</code>，直接把当前分支 rebase 到远程分支的后面，git 会智能地帮我们处理好一切。</p>
<p>如果是合并进行，则 <code>git pull --rebase</code>，可以设置 –rebase 为默认：<code>git config --global pull.rebase true</code>。</p>
<h1 id="distributed-git"><a href="#distributed-git" class="headerlink" title="distributed git"></a>distributed git</h1><p><code>git diff --check</code> 在提交之前，检查是否存在 “whitespace issues”。</p>
<blockquote>
<p>The <code>--squash</code> option takes all the work on the merged branch and squashes it into one changeset producing the repository state as if a real merge happened, without actually making a merge commit. This means your future commit will have one parent only and allows you to introduce all the changes from another branch and then make more changes before recording the new commit. Also the <code>--no-commit</code> option can be useful to delay the merge commit in case of the default merge process.</p>
</blockquote>
<p>假设要把分支 B 合并到分支 A 上，–squash 可以把 B 的变化直接拿过来，放到 A 上，不产生新的 commit，需要人工进行 commit。此后在查看 log 时，只能看到一个 parent，即 A。</p>
<h1 id="HEAD-“-”-vs-“-”-vs-“-”"><a href="#HEAD-“-”-vs-“-”-vs-“-”" class="headerlink" title="HEAD “^” vs “~” vs “@{}”"></a>HEAD “^” vs “~” vs “@{}”</h1><p>在空白目录下运行以下 shell 脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">git init</span><br><span class="line">git branch --move master main</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 构建分支</span></span><br><span class="line">echo 1 &gt;&gt; file</span><br><span class="line">git add file</span><br><span class="line">git commit -m &quot;main-commit-1&quot; -a</span><br><span class="line">echo 1 &gt;&gt; file</span><br><span class="line">git commit -m &quot;main-commit-2&quot; -a</span><br><span class="line">git checkout -b dev</span><br><span class="line">echo 1 &gt;&gt; dev</span><br><span class="line">git add dev</span><br><span class="line">git commit -m &quot;dev-commit-1&quot; -a</span><br><span class="line">git checkout -b prod</span><br><span class="line">echo 1 &gt;&gt; prod</span><br><span class="line">git add prod</span><br><span class="line">git commit -m &quot;prod-commit-1&quot; -a</span><br><span class="line">git switch main</span><br><span class="line">echo 1 &gt;&gt; file</span><br><span class="line">git commit -m &quot;main-commit-3&quot; -a</span><br><span class="line">git switch dev</span><br><span class="line">echo 1 &gt;&gt; dev</span><br><span class="line">git commit -m &quot;dev-commit-2&quot; -a</span><br><span class="line">git switch prod</span><br><span class="line">echo 1 &gt;&gt; prod</span><br><span class="line">git commit -m &quot;prod-commit-2&quot; -a</span><br><span class="line">git switch main</span><br><span class="line">git merge -m &quot;Merged dev&quot; dev</span><br><span class="line">echo 1 &gt;&gt; file</span><br><span class="line">git commit -m &quot;main-commit-4&quot; -a</span><br><span class="line">git merge -m &quot;Merged prod&quot; prod</span><br></pre></td></tr></table></figure>

<p>备注：图片中用的是 master 分支，没有改名为 main，不影响。</p>
<img src="https://s1.ax1x.com/2022/09/26/xVt1bt.jpg" style="zoom: 60%;">

<p>上结论：</p>
<ul>
<li><p>HEAD^ HEAD^^… HEAD~ HEAD~~… HEAD<del>1 HEAD</del>2 <code>HEAD~&lt;n&gt;</code>… 都是在当前分支上找父结点，比如此时在 main 分支上 ，就只沿着 main 这条分支的父节点往前找。或者按 Git book 的说法来理解，<strong>每个 ^ 或 ~ 表示寻找其第一个父结点</strong>，多个叠加即寻找”第一个父结点的第一个父结点”。</p>
<blockquote>
<p>You can also specify a number after the <code>^</code> to identify <em>which</em> parent you want;</p>
<p>This syntax is useful only for merge commits, which have more than one parent — the <em>first</em> parent of a merge commit is from the branch you were on when you merged (frequently <code>master</code>), while the <em>second</em> parent of a merge commit is from the branch that was merged (say, <code>topic</code>):</p>
<p><code>HEAD~2</code> means “<strong>the first parent</strong> of <strong>the first parent</strong>,” or “the grandparent” — it traverses the first parents the number of times you specify.</p>
</blockquote>
</li>
<li><p><code>HEAD^&lt;n&gt;</code> 针对有 merge 的情况，HEAD^1 表示第一个父结点，HEAD^2 表示第二个父结点。如果当前 HEAD 不是 merge 得到的结点，那么它只有 HEAD^1，试图找 HEAD^2 会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: ambiguous argument &#x27;19588e4^2&#x27;: unknown revision or path not in the working tree.</span><br></pre></td></tr></table></figure></li>
<li><p><code>HEAD@&#123;&lt;n&gt;&#125;</code> 针对 reflog，与操作的次序有关。以下是特殊用法：</p>
<p><code>git log --no-walk HEAD^@</code> 可以列出当前结点的父结点，–no-walk 表示不显示祖先结点。比如 HEAD 在 merge-prod，该指令可以查看 merge 的两个父结点。如果不加 –no-walk，可以看到所有祖先结点。</p>
<p><code>git show HEAD^@</code> 可以查看父结点的详细信息，不需要 –no-walk 也不显示祖先。</p>
</li>
</ul>
<img src="https://s1.ax1x.com/2022/09/26/xVt8VP.jpg" style="zoom: 50%;">

<ul>
<li>^ 和 ~ 也可以打组合拳，明确了 ^ 和 ~ 的语义后不难理解，^ 是纵向的第几个 parent，~ 是横向的第几个 parent，HEAD^^^ 这种属于特殊情况，可以这样看待：由于 HEAD^1 和 HEAD^ 等价，可以做拆分：((HEAD^)^)^，而 HEAD^ 和 HEAD~ 等价，所以多个 ^ 也和 ~ 等价。</li>
</ul>
<img src="https://s1.ax1x.com/2022/09/26/xVN4Sg.jpg" style="zoom:42%;">

<h1 id="tools"><a href="#tools" class="headerlink" title="tools"></a>tools</h1><p><code>git show &lt;commit&gt;</code> 具体查看某一次提交。</p>
<p><code>git rev-parse &lt;branch&gt;</code> 查看分支指向结点的 Hash。</p>
<h2 id="double-dot"><a href="#double-dot" class="headerlink" title="double dot"></a>double dot</h2><blockquote>
<p>You can ask Git to show you a log of just those commits with <code>master..experiment</code> — **that means “all commits reachable from <code>experiment</code> that aren’t reachable from <code>master</code>.**”</p>
</blockquote>
<p><code>git log origin/master..HEAD</code> 可以查看 HEAD 拥有而 origin/master 没有的提交，从而确认本次 push 有哪些 commit。HEAD 可以省略。</p>
<blockquote>
<p>You can also leave off one side of the syntax to have Git assume <code>HEAD</code>. For example, you can get the same results as in the previous example by typing <code>git log origin/master..</code> — Git substitutes <code>HEAD</code> if one side is missing.</p>
</blockquote>
<h2 id="multiple-points"><a href="#multiple-points" class="headerlink" title="multiple points"></a>multiple points</h2><p>查看 B 有 A 没有的提交，有如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log refA..refB</span><br><span class="line">$ git log ^refA refB</span><br><span class="line">$ git log refB --not refA</span><br></pre></td></tr></table></figure>

<p>第二、三行的语法可以对比更多分支，查找对应的提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log refA refB ^refC</span><br><span class="line">$ git log refA refB --not refC</span><br></pre></td></tr></table></figure>

<h2 id="triple-dot"><a href="#triple-dot" class="headerlink" title="triple dot"></a>triple dot</h2><p>… 可以查看两个分支的“异或”，即只能被某一分之访问的提交。</p>
<p>可以搭配 –left-right 选项使用，<code>git log --left-right A...B</code>： &lt; 表示只能被 A 访问，&gt; 表示只能被 B 访问。</p>
<h2 id="patch-mode"><a href="#patch-mode" class="headerlink" title="patch mode"></a>patch mode</h2><p><code>add -p </code> 可以把一个文件分成多个 chunk，然后可将部分 chunk 添加到暂存区，如果 chunk 分得不够细，应用 s。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?</span><br><span class="line">y - stage this hunk</span><br><span class="line">n - do not stage this hunk</span><br><span class="line">a - stage this and all the remaining hunks in the file</span><br><span class="line">d - do not stage this hunk nor any of the remaining hunks in the file</span><br><span class="line">g - select a hunk to go to</span><br><span class="line">/ - search for a hunk matching the given regex</span><br><span class="line">j - leave this hunk undecided, see next undecided hunk</span><br><span class="line">J - leave this hunk undecided, see next hunk</span><br><span class="line">k - leave this hunk undecided, see previous undecided hunk</span><br><span class="line">K - leave this hunk undecided, see previous hunk</span><br><span class="line">s - split the current hunk into smaller hunks</span><br><span class="line">e - manually edit the current hunk</span><br><span class="line">? - print help</span><br></pre></td></tr></table></figure>

<p>同样可以应用 patch mode 的还有 reset / checkout / stash，参考 7.2 节。</p>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p><code>git stash list</code> 查看 stash 列表。</p>
<p><code>git stash apply stash@&#123;&lt;n&gt;&#125;</code> 应用 stash，如果不指定，应用最新的 stash，应用后不会删除 stash。</p>
<p>添加 –index 选项，可以恢复 stash 之前的暂存区。</p>
<p><code>git stash drop stash@&#123;&lt;n&gt;&#125;</code> 删除 stash。</p>
<p><code>git stash clear</code> 清除所有 stash。</p>
<p><code>git stash pop stash@&#123;&lt;n&gt;&#125;</code>  是 apply 和 drop 的结合，需要注意的是，pop 也可以接 stash 名称，不只是可以 pop 最新的 stash。</p>
<p>如果要连续应用两次 stash，并且存在冲突，需要先把第一次的 stash 添加到暂存区，再执行一次 pop，此时才能解决冲突。</p>
<p>否则报错：error: Your local changes to the following files would be overwritten by merge.</p>
<p><code>git stash --keep-index</code> 仅把工作区的修改添加到 stash，不影响暂存区。</p>
<p>–include-untracked 或 -u 会把 untracked files 也加入 stash，但不会加入明确 ignored 的 file，如果要把它们也包含进来，用 -a 或 –all。</p>
<p>如果 stash 后在该分支上继续工作，应用 stash 的时候可能会遇到很多冲突，最佳实践是切到一个新的分支上应用 stash，可以简写为：<code>git stash branch &lt;branchname&gt; [&lt;stash&gt;]</code>。</p>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><code>git grep &lt;content / regExp / wildcard&gt;</code>  查找。</p>
<p>选项需要加在 grep 后面，-c 显示数量，-n 显示行号，–and 指定多个条件。</p>
<h2 id="rebase-i"><a href="#rebase-i" class="headerlink" title="rebase -i"></a>rebase -i</h2><p><code>git rebase -i &lt;commit&gt;</code> 可以修改 commit 之前所有提交的记录。 </p>
<h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><p>将动词修改为 e 或 edit，保存并退出。</p>
<p>接下来，在需要 edit 的地方会停止，此时执行 git commit –amend 来修改，修改完后 git rebase –continue 继续。</p>
<h3 id="reorder-remove"><a href="#reorder-remove" class="headerlink" title="reorder / remove"></a>reorder / remove</h3><p>remove 就是把对应 pick 行删除，reorder 就是改变 pick 行顺序。</p>
<p>但我发现一个问题，先看看 shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir try-git</span><br><span class="line">cd try-git</span><br><span class="line">git init</span><br><span class="line">git branch --move master main</span><br><span class="line"></span><br><span class="line">echo 1 &gt;&gt; file</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;commit-1&quot;</span><br><span class="line">echo 2 &gt;&gt; file</span><br><span class="line">git commit -m &quot;commit-2&quot; -a</span><br><span class="line">echo 3 &gt;&gt; file</span><br><span class="line">git commit -m &quot;commit-3&quot; -a</span><br><span class="line">echo 4 &gt;&gt; file</span><br><span class="line">git commit -m &quot;commit-4&quot; -a</span><br><span class="line">echo 5 &gt;&gt; file</span><br><span class="line">git commit -m &quot;commit-5&quot; -a</span><br><span class="line">echo 6 &gt;&gt; file</span><br><span class="line">git commit -m &quot;commit-6&quot; -a</span><br></pre></td></tr></table></figure>

<p>使用 rebase -i 删除 commit-4，需要解决冲突，此时发现，即使 commit-4 删除了，所做的修改仍然保留着，并且<strong>在合 commit-5 的时候，把 commit-4 的修改也包含进来了</strong>，如果要丢弃此修改，需要细心甄别。</p>
<p>使用 drop 和直接删除某一行的效果类似。</p>
<h3 id="squash"><a href="#squash" class="headerlink" title="squash"></a>squash</h3><p>如果此时有三条 pick 记录，A B C，想要把 B C 合到 A，则保持 pick A 不变，修改 B、C 为 squash。</p>
<p>之后编辑新的 commit message，保存即可。</p>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>把想要拆分的 commit，改成 edit。</p>
<p>在这条 commit 处停下时，使用 <code>git reset HEAD^</code> 使修改进入工作区，然后 split 成多次提交，完成之后 rebase –continue 即可。</p>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>git reset 如果后接 commit，工作流程：</p>
<ol>
<li><strong>当前分支随 HEAD 一起</strong>指向新的 commit。&lt;= <code>--soft </code> 停在这里</li>
<li>将版本库的内容复制到暂存区（index）。&lt;= <code>--mixed</code> 停在这里，默认选项</li>
<li>将暂存区的内容复制到工作区。&lt;= <code>--hard</code> </li>
</ol>
<p>git status 的原理是对比 HEAD、暂存区、工作区。</p>
<p>因此，使用 –soft 时，由于 HEAD 指向曾经的 commit，并且暂存区不变，因此暂存区和 HEAD 存在差异，新的暂存还未提交，所以 status 显示<strong>绿色</strong>。</p>
<p>使用 –mixed 时，由于 HEAD 的内容复制到了暂存区，现在暂存区和 HEAD 相同，但是工作区没有修改，所以工作区和暂存区有差异，status 显示<strong>红色</strong>。</p>
<p>使用 –hard 时，status 显示没有新的改变。</p>
<p>如果先使用 –mixed 回退，再使用 –soft 恢复到之前的 commit，那么会出现版本库和工作区一致，暂存区落后的情况，status 又红又绿。</p>
<p>git reset <strong>如果后接 path，那么不会发生上方第一步</strong>。</p>
<p>git reset file 会执行第二步，相当于回退了暂存区，因此此时 reset 的功能相当于 restore。</p>
<p><code>git reset &lt;commit&gt; &lt;file&gt;</code> 同样不会发生第一步，它会用该 commit 中的 file 去覆盖此时暂存区的 file，不影响工作区。此时只需要 提交即可。</p>
<p>reset 也可以用于合并多次 commit，只需要先 reset –soft 回退到某一版本，由于此时暂存区不变，只需要提交一次，即可把后面多次提交的内容合并为本次提交。当然不加 –soft 也可以，需要多加一次暂存区。</p>
<h2 id="rerere"><a href="#rerere" class="headerlink" title="rerere"></a>rerere</h2><p>revere 是 reuse / recorded / resolution 的缩写，意为”复用冲突解决的记录”。</p>
<p>rerere 可以复用之前的 merge conflict resolution。</p>
<p><code>git config --global rerere.enabled true</code> 打开 rerere。</p>
<p>此后，第一次 merge 时，会被 rerere cache 记录，merge 后的信息多了一行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Recorded preimage for &#x27;&lt;filename&gt;&#x27; </span><br></pre></td></tr></table></figure>

<p><code>git rerere diff</code> 可以查看当前 resolution 的状态。</p>
<p>然后解决冲突并提交，使用 <code>reset --hard HEAD~</code> 回退，再次 merge，发现之前的 resolution 会自动生效。</p>
<p>如果需要恢复冲突状态，使用 <code>git checkout --conflict=merge &lt;filename&gt;</code>。</p>
<p>在冲突状态下重新应用 rerere，使用 <code>git rerere</code>。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/10/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>校验Account，要求：账号以字母开头，由小写英文字母和数字组成的4-16位字符。</p>
<p>不知道怎么判断“由小写英文字母和数字组成”，<code>(/^[0-9a-z]+$/</code>不行，因为纯小写字母或数字也能通过。</p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>策略：<a href="https://stackoverflow.com/questions/31761565/require-both-letters-and-numbers-regexp">Require both letters and numbers - regExp</a></p>
<h2 id="Look-Ahead"><a href="#Look-Ahead" class="headerlink" title="Look Ahead"></a>Look Ahead</h2><p>Look Ahead 指形如<code>(?=)</code>的正则。</p>
<p>Look Ahead：利用<strong>先行断言</strong>，当使用了这种技术后，可以有多个并列的正则如<code>(?=)()</code>，先校验第一个正则，Look Ahead的作用是，它不占据空间，到第二个正则时还可以从同样的位置开始校验。</p>
<p>参考这里的第二篇回答：<a href="https://stackoverflow.com/questions/2973436/regex-lookahead-lookbehind-and-atomic-groups">Regex lookahead, lookbehind and atomic groups</a></p>
<h2 id><a href="#" class="headerlink" title=".*?"></a>.*?</h2><p>一般情况下，.表示任意字符，*表示{0, }，?表示{0,1}。</p>
<p>需要注意，<code>?</code>一般采取贪婪模式，即匹配尽可能多的字符（这些匹配上的字符的空间就被占据了）</p>
<p>由mdn：</p>
<blockquote>
<p>如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符）</p>
</blockquote>
<p>所以<code>.*?</code>的意思是：甭管这里有什么字符，都匹配0次。</p>
<p>光看这些可能还是无法理解其必要性，我们看看解决策略里的写法：<code>/^(?=.*?\d)(?=.*?[a-zA-Z])[a-zA-Z\d]+$/</code></p>
<p>首先最前面有<code>^</code>，说明从头开始匹配，关注第一个Look Ahead，它的作用是从头开始检查，保证至少有一个数字。</p>
<p>如果直接写成<code>(?=\d)</code>，开头有小写字母就会失效，不可行。</p>
<p>如果写成<code>(?=.*\d)</code>，由于量词的贪心匹配原则，.*会把所有数字匹配走，而\d匹配不上。</p>
<p>所以既要兼顾开头是字母的情况，又要破坏贪心匹配原则，使用<code>.*?</code>。</p>
<h2 id="成功实践"><a href="#成功实践" class="headerlink" title="成功实践"></a>成功实践</h2><p>根据实践，我上边对.*?的必要性解释是错的，其实没有?也可以。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^(?=.*[a-z])(?=.*\d)[a-z]&#123;<span class="number">1</span>&#125;[a-z\d]&#123;<span class="number">3</span>,<span class="number">15</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意&#123;3,15&#125;这里不能有空格！</span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式-MDN</a></p>
<p><a href="https://www.regular-expressions.info/lookaround.html">Regular-Expressions.info</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>预加载</tag>
      </tags>
  </entry>
  <entry>
    <title>预加载</title>
    <url>/2022/10/13/%E9%A2%84%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="什么是预加载"><a href="#什么是预加载" class="headerlink" title="什么是预加载"></a>什么是预加载</h1><p>提前请求图片等资源，等到真正要用的时候，直接从缓存拿，而不用发送请求，从而缩短图片显示的用时，优化用户体验</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>在React中实现预加载一般借助 useEffect，在初次渲染组件时进行预加载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const preloadImages = []</span><br><span class="line">  // 可以把 ProjectStore.imgs换成url数组...</span><br><span class="line">  for (let i = 0; i &lt; ProjectStore.imgs.length; i++) &#123;</span><br><span class="line">    const img = new Image()</span><br><span class="line">    // 将img从数组中移除，减少内存占用</span><br><span class="line">    img.onload = function () &#123;</span><br><span class="line">      const index = preloadImages.indexOf(this)</span><br><span class="line">      if (index !== 1) &#123;</span><br><span class="line">        preloadImages.splice(index, 1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    img.src = ProjectStore.imgs[i].url</span><br><span class="line">    preloadImages.push(img)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>这样，之后在任意页面用到这些图片资源时，都可以直接从缓存拿取，从而大大提升用户体验</p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p><img src="https://s1.ax1x.com/2022/06/09/XsbqJ0.jpg"></p>
<p>注意开发时不要勾选 <code>Disable cache</code>，一开始没注意被坑了…</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>预加载</tag>
      </tags>
  </entry>
  <entry>
    <title>异步任务调度器</title>
    <url>/2022/10/13/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<p>JS 实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个。完善代码中Scheduler类，使得以下程序能正确输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">promiseCreator</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeout = <span class="function">(<span class="params">time</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, time);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scheduler = <span class="keyword">new</span> Scheduler();</span><br><span class="line"><span class="keyword">const</span> addTask = <span class="function">(<span class="params">time, order</span>) =&gt;</span> &#123;</span><br><span class="line">  scheduler.add(<span class="function">() =&gt;</span> timeout(time)).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(order));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">addTask(<span class="number">1000</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">addTask(<span class="number">500</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">addTask(<span class="number">300</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">addTask(<span class="number">400</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 2 3 1 4</span></span><br><span class="line"><span class="comment">// 一开始，1、2两个任务进入队列</span></span><br><span class="line"><span class="comment">// 500ms时，2完成，输出2，任务3进队</span></span><br><span class="line"><span class="comment">// 800ms时，3完成，输出3，任务4进队</span></span><br><span class="line"><span class="comment">// 1000ms时，1完成，输出1</span></span><br><span class="line"><span class="comment">// 1200ms时，4完成，输出4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>题解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.unwork = [];</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">promiseCreator</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      promiseCreator.resolve = resolve;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.runTask(promiseCreator);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.unwork.push(promiseCreator);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">runTask</span>(<span class="params">promiseCreator</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">    promiseCreator().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      promiseCreator.resolve();</span><br><span class="line">      <span class="built_in">this</span>.count--;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.unwork.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newTask = <span class="built_in">this</span>.unwork.shift();</span><br><span class="line">        <span class="built_in">this</span>.runTask(newTask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>formData</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2022/10/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>最近项目中有上传图片文件的需求：</p>
<h1 id="点击选择图片的按钮"><a href="#点击选择图片的按钮" class="headerlink" title="点击选择图片的按钮"></a>点击选择图片的按钮</h1><p>mui的实现是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  accept=&quot;image/*&quot;</span><br><span class="line">  id=&quot;contained-button-file&quot;</span><br><span class="line">  style=&#123;&#123; display: &#x27;none&#x27; &#125;&#125;</span><br><span class="line">  // 选多张图片</span><br><span class="line">  multiple</span><br><span class="line">  type=&quot;file&quot;</span><br><span class="line">  onChange=&#123;(e) =&gt; &#123;</span><br><span class="line">    // 下面讲</span><br><span class="line">    clickToUploadFile(e.target.files)</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;label</span><br><span class="line">  htmlFor=&quot;contained-button-file&quot;</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;Button</span><br><span class="line">    variant=&quot;contained&quot;</span><br><span class="line">    // 必须加这一行</span><br><span class="line">    component=&quot;span&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    导入图片</span><br><span class="line">  &lt;/Button&gt;</span><br><span class="line">&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<h1 id="formData"><a href="#formData" class="headerlink" title="formData"></a>formData</h1><p>后端要求使用formData，于是快速上手了formData，主要用到.append方法。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fileList =&gt; input onChange callback =&gt; e.target.files</span></span><br><span class="line"><span class="comment">// 是一个对象，&#123;1: file1, 2: file2, length: 2, ...&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clickToUploadFile</span>(<span class="params">fileList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reqData = <span class="keyword">new</span> FormData()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 项目id</span></span><br><span class="line">  reqData.append(<span class="string">&#x27;projectID&#x27;</span>, id)</span><br><span class="line">  <span class="comment">// 上传图片数量</span></span><br><span class="line">  reqData.append(<span class="string">&#x27;imgNum&#x27;</span>, <span class="string">`<span class="subst">$&#123;fileList.length&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> fileList) &#123;</span><br><span class="line">    <span class="comment">// 图片</span></span><br><span class="line">    reqData.append(<span class="string">`img<span class="subst">$&#123;<span class="built_in">parseInt</span>(key) + <span class="number">1</span>&#125;</span>`</span>, fileList[key])</span><br><span class="line">    <span class="comment">// uuid(下边讲)</span></span><br><span class="line">    <span class="keyword">const</span> uuid = generateUUID(fileList[key])</span><br><span class="line">    reqData.append(<span class="string">`uuid<span class="subst">$&#123;<span class="built_in">parseInt</span>(key) + <span class="number">1</span>&#125;</span>`</span>, <span class="string">`<span class="subst">$&#123;uuid&#125;</span>`</span>)</span><br><span class="line">    <span class="comment">// 图片名</span></span><br><span class="line">    reqData.append(<span class="string">`name<span class="subst">$&#123;<span class="built_in">parseInt</span>(key) + <span class="number">1</span>&#125;</span>`</span>, fileList[key].name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只取file，不要length以及之后的属性</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(key) === fileList.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>formData的实例对象不能直接通过console.log查看，需要这样做：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FormData.entries：返回一个包含所有键值对的interator对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> reqData.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair[<span class="number">0</span>] + <span class="string">&#x27;, &#x27;</span> + pair[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="uuid的生成"><a href="#uuid的生成" class="headerlink" title="uuid的生成"></a>uuid的生成</h1><p>UUID (Universally unique identifier)，通用唯一识别码。</p>
<p>前端需要为每个图片生成独一无二的uuid，并放在formData中传给后端，就像刚才做的那样。</p>
<p>我直接采用<code>图片时间戳 * 图片大小 / 大质数</code>的方式，保证在低并发情况下，每个图片都拥有独一无二的uuid。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData">MDN-formData</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>formData</tag>
      </tags>
  </entry>
  <entry>
    <title>初探 nginx</title>
    <url>/2022/10/13/%E5%88%9D%E6%8E%A2%20nginx/</url>
    <content><![CDATA[<h1 id="速查"><a href="#速查" class="headerlink" title="速查"></a>速查</h1><p>配置文件路径：<code>/etc/nginx/nginx.conf</code></p>
<p>日志路径：<code>/var/log/nginx/</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  root;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里写成绝对路径，因为编译生成的 prefix 错误，如果写相对路径，会报错找不到日志文件</span></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># pid logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># $scheme 表示 access 时的协议</span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$scheme - &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">tcp_nopush</span>     <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前端 nginx 只配了 http，然后配置 cdn + https，这样也可以用 https 来访问</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  api.danmoits.com;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl ipv6only=<span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span>  api.danmoits.com;</span><br><span class="line">        <span class="attribute">index</span> index.js;</span><br><span class="line">        <span class="attribute">root</span> /home/Milestone-be/be/src;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /milestone/ &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 核心，证书配置</span></span><br><span class="line">        <span class="attribute">ssl_certificate</span>      /etc/nginx/cert/api.danmoits.com.pem;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>  /etc/nginx/cert/api.danmoits.com.key;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_session_cache</span>    shared:SSL:<span class="number">1m</span>;</span><br><span class="line">        <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">        <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCSHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> milestone.danmoits.com;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">        <span class="attribute">root</span> /home/Milestone-fe;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br><span class="line">          <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> zichen.danmoits.com;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">        <span class="attribute">root</span> /home/remote-sensing;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br><span class="line">          <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="location路径替换"><a href="#location路径替换" class="headerlink" title="location路径替换"></a>location路径替换</h1><p>我只需要购买一个域名，创建很多二级域名，每个二级域名映射到服务器的一个端口上。实现起来，就是在<code>server_name</code>处写上域名，再在下面location中的<code>proxy_pass</code>指明代理到哪个端口。当然只有后端服务才需要这么做，前端只需要把静态资源放上去，指明 server_name 就行了，不需要配置反向代理。</p>
<p>问题：当我请求 api/danmoits.com/milestone/post 时，我希望后端那边收到的请求不带 milestone。</p>
<p>参考: <a href="https://blog.csdn.net/hongtaolong/article/details/103936173">nginx中proxy_pass的使用</a></p>
<p>假设http的请求路径为：<a href="http://123.25.95.148:9998/nginx/hello?name=taolong">http://123.25.95.148:9998/nginx/hello?name=taolong</a></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#匹配规则</span></span><br><span class="line"><span class="attribute">location</span> /nginx &#123;</span><br><span class="line">  <span class="comment">#注意这里是“/”结尾，请求url中未匹配的内容：/hello?name=taolong</span></span><br><span class="line">  <span class="attribute">proxy_pass</span> http://123.25.95.148:10010/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#此时上面输出的结果：http://123.25.95.148:10010/hello?name=taolong</span></span><br></pre></td></tr></table></figure>

<p>所以我只需要在 /nginx 处写成 /milestone/ （此处必须加 /，不然后端会多一个/，如 <code>//post</code>）</p>
<p>proxy_pass 处写成 http:127.0.0.1/ （以 / 结尾）</p>
<p>这样就会把未匹配内容加在 http:127.0.0.1/ 后面</p>
<h1 id="try-files"><a href="#try-files" class="headerlink" title="try_files"></a>try_files</h1><p><strong>踩坑：刚进入页面时正常，刷新后显示404</strong></p>
<p>由于nginx本质上还是一个托管静态资源的web服务器，当访问<code>domain/url</code>时，会去我指定的root目录下查找是否有资源。</p>
<p>比如说，<code>milestone.danmoits.com/posts?page=0</code>，我指定的root是服务器的<code>/home/Milestone-fe</code>，那么会找<code>/home/Milestone-fe/posts?page=0</code>，很显然此时找不到，那么就会报404。</p>
<p>为什么刚进入页面时不报404呢？因为我一开始访问的是根目录，请求会打到index.html上，随后前端把url重定向，而<code>/home/Milestone-fe/index.html</code>是真实存在的，所以没有404，这里的前端重定向，被学长称作’fake router’。</p>
<p>因此，需要配置try_files：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当用户请求 <code>http://localhost/example</code> 时，这里的 <code>$uri</code> 就是 <code>/example</code>，try_files 会到硬盘里尝试找这个文件；<br>如果存在名为 <code>/$root/example</code>（其中 <code>$root</code> 是项目代码安装目录）的文件，就直接把这个文件的内容发送给用户；</p>
</blockquote>
<p>如果这样写，其实try_files前面的<code>$uri</code>做的事和上边描述的一样，关键在于最后的参数。</p>
<blockquote>
<p>如果给出的file都没有匹配到，则会进行一个内部重定向到最后一个参数给定的uri，就是新的location匹配。</p>
</blockquote>
<p>即前面都没匹配到，就会去找<code>/index.html</code>，而它是能找到的，就不会报404了。</p>
<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>前端配置 https 借助来 cdn，而后端只能配 nginx.conf。</p>
<p>前端需要明白 cdn 的原理，我们要访问的域名配置了 CNAME 解析，从而访问 cdn 域名，我们发送 https 请求是向 cdn 服务器发送 https 请求，cdn 可能会回源，此时我配置回源协议是 http，所以 nginx 这边就不用配 https 了，当然也可以配，这样的话回源协议需要设置为 https。</p>
<p>以前用 certbot 生成的一份配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  root;</span><br><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="comment"># error_log  logs/error.log;</span></span><br><span class="line"><span class="comment"># error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment"># error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="attribute">error_log</span> /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># SSL Settings</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>; <span class="comment"># Dropping SSLv3, ref: POODLE</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>           <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#################</span></span><br><span class="line">    <span class="comment"># milestone</span></span><br><span class="line">    <span class="comment">#################</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">server_name</span> milestone.danmoits.com;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/milestone.danmoits.com/fullchain.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">include</span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">ssl_dhparam</span> /etc/letsencrypt/ssl-dhparams.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /home/Milestone-fe;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> milestone.danmoits.com;</span><br><span class="line">        <span class="attribute">if</span> ($host = milestone.danmoits.com) &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">        &#125; <span class="comment"># managed by Certbot</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>; <span class="comment"># managed by Certbot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#################</span></span><br><span class="line">    <span class="comment"># API</span></span><br><span class="line">    <span class="comment">#################</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl ipv6only=<span class="literal">on</span>; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">server_name</span>  api.danmoits.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/api.danmoits.com/fullchain.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/api.danmoits.com/privkey.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">include</span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">ssl_dhparam</span> /etc/letsencrypt/ssl-dhparams.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">index</span> index.js;</span><br><span class="line">        <span class="attribute">root</span> /home/Milestone-be/be/src;</span><br><span class="line">        <span class="attribute">location</span> /milestone/ &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span>  api.danmoits.com;</span><br><span class="line">        <span class="attribute">if</span> ($host = api.danmoits.com) &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">        &#125; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>; <span class="comment"># managed by Certbot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#################</span></span><br><span class="line">    <span class="comment"># cmind</span></span><br><span class="line">    <span class="comment">#################</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">server_name</span> cmind.danmoits.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/cmind.danmoits.com/fullchain.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/cmind.danmoits.com/privkey.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">include</span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="comment"># managed by Certbot</span></span><br><span class="line">        <span class="attribute">ssl_dhparam</span> /etc/letsencrypt/ssl-dhparams.pem; <span class="comment"># managed by Certbot</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /home/cMind;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br><span class="line">          <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span>  [::]:<span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">server_name</span> cmind.danmoits.com;</span><br><span class="line">        <span class="attribute">if</span> ($host = cmind.danmoits.com) &#123;</span><br><span class="line">            <span class="attribute">return</span> <span class="number">301</span> https://$host$request_uri;</span><br><span class="line">        &#125; <span class="comment"># managed by Certbot</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">return</span> <span class="number">404</span>; <span class="comment"># managed by Certbot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后来自己尝试配 https，参考以下资料：</p>
<p><a href="http://nginx.org/en/docs/http/configuring_https_servers.html">Configuring HTTPS servers</a></p>
<p><a href="https://help.aliyun.com/document_detail/98728.html">在Nginx或Tengine服务器上安装证书</a></p>
<p>然后就有了开头那份 nginx.conf。</p>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 ~ 2022</title>
    <url>/2022/06/10/2021~2022/</url>
    <content><![CDATA[<h1 id="步入联创"><a href="#步入联创" class="headerlink" title="步入联创"></a>步入联创</h1><p>开学的第二天我就来到了811，那时候在场的有 xylonx 和 zcy 学长，刚来的我非常拘谨，在忐忑中度过了刚开始的那段时期，然后就开始做新人任务，共三期。</p>
<p>个人觉得，我每期任务都做得很赶，即使好像一周的所有时间都砸在任务上，完成度也只是一般般，不过这可能只是我自己的感觉，说不定是给自己的期望值太高或者压力太大。</p>
<p>最难受的是第0期，那时候我觉得 git 和 linux 都学过，于是把重点放在了装 arch 和配置 arch 上，结果时间分配不当，一下就整了三四天，查的时候根本不看，问了一堆我没准备的 git 和 linux 的问题。datalab的话，我以为自己不动手，看看别人的然后将其理解也是可以的，结果现场写异或交换两数没写出来。第0期被锤让我难受了半个月。</p>
<p>做vdom的时候，联创开始秋招，我就强行充了一波面试官，不过也问不出什么，学长向面试者提的一些问题，我都不知道答案。后来有一批新人加入了我们，看着他们做新人任务，有些人一周似乎一直在上课，没有花多少时间，最后也能将新人任务完成，我就想到了自己一开始的那段经历，然后又忍不住开始自我怀疑，再加上和其他团队成员的比较，不自信更甚。</p>
<p><strong>我本来以为，进入团队是增长自信的一种途径，结果发现自己照旧不自信。</strong></p>
<p>大二上，学得毫无章法，偏离了我一开始想要做产品的初心。刚开始的时候，我想从头开始做 hackweek 的产品。后来做 datalab，我想到自己之前想打计算机基础，就接着看 CSAPP，顺便看一下设计模式，之后我又开始看计网自顶向下，再次复习了上边的两层，并且看了部分网络层，一度想要学抓包和 socket，之后放弃。和兔兔聊了一下，就又开始看算导，一直看到红黑树，觉得这些东西也暂时用不上，又开始去刷力扣。中间穿插了个腾讯文档菁英班，就看文档学了一下 react，复习 ts，看 sass 文档，最后做项目的时候又看了下 mobx。还有就是实现了两次 vdom（尝试了 list-diff，但还是做得不够好），看了 koa 源码和洋葱模型源码，写了 koa-router。</p>
<p>这学期的学习几乎以理论为主，甚至一度让我感到有些枯燥，效率也不是很高，虽然去811的频率很高，可我究竟收获了多少呢？要不是最后被拉去和 xiong35 学长他们组队做腾讯课的项目，这学期的实践能力几乎是没什么提高，我还是不知道一个网站的前后端是怎么写出来的，我的学习几乎没有实感。</p>
<p>再多说一些加入团队的体验吧，其实加入团队前后，我的心态并没有太大不同，不会因为自己是团队人而觉得有种不一样的感觉。不一样的大学生活中，确实收获到了，整天翘课去启明学习，聚餐频率增加，外卖频率增加……</p>
<h1 id="腾讯文档菁英班"><a href="#腾讯文档菁英班" class="headerlink" title="腾讯文档菁英班"></a>腾讯文档菁英班</h1><p>10月份的时候，大萝卜和辅导员在通知群发布了腾讯文档菁英班的推文，既然是学习前端的班，是腾讯组织的，还有奖金和实习名额，我想都没想就报名了。一共四节课，两次作业和最后的大作业，课我意料之中的没听几节，作业和一次考试也就那样 A 过去了。最后的项目被 xiong35 学长拉去组队，技术栈大概是 react + ts，没怎么做过项目的我，在动手之前真的十分迷茫，还发了条负能说说，之后就和学长聊了很多，也笃定了我寒假和第二学期要做项目的决心。</p>
<p>我们的选题是复刻网易云音乐，有了学长学姐的帮助，我终于知道了怎么用 git 多人协作，怎么请求数据，保存数据并响应式渲染在页面上，如何拆分组件，如何正确 git commit，怎样解耦，代码服从什么规范。答辩的时候不小心暴露出一点 bug……虽然最后没拿奖，但是挺有收获，这算是项目之始。</p>
<p>最后拿了大二选手中第二高的分数，当然实习嘛，大二的不配。</p>
<h1 id="离谱的寒假"><a href="#离谱的寒假" class="headerlink" title="离谱的寒假"></a>离谱的寒假</h1><p>寒假去海南骑了一趟车，圆满了大一的梦想，但是倒霉的是，住酒店时被舍友传染了水痘……寒假的后半段就在这种水痘的痛苦中度过。</p>
<p>在万宁的时候，晚上在酒店临时打算参加冬令营，在三亚的时候，接了一个小程序的锅，大概就是合成头像框。</p>
<p>1月19日晚上，海南之旅结束，于是当晚三亚→昆明，在长水机场的一家餐厅熬了一晚，第二天又昆明→成都，成都下飞机后，从机场感到火车站，又坐火车回的汉中，这大概是我目前为止最为曲折的一段旅程了。</p>
<p>一回家就被 ddl 驱使，几天搞定小程序，然后就连着冬令营的锅，那几天的我极度疲惫，到冬令营 check 的那一天，水痘引发的低烧开始出现，于是我直接鸽了 check。</p>
<p>之后就是难熬的水痘日子了，什么症状就不描述，反正每天都要给浑身的疙瘩上药，开始的一周苦不堪言，也无心思学习，先刷完了《双城之战》，之后又刷完了《开端》。</p>
<p>寒假之前，我想过要怎么好好做项目、背面经、刷力扣，应付随之而来的面试的，一切计划都被打乱了。</p>
<p>那段时间，<strong>由于受到身心双重压迫，我开始怀疑自己的初心，觉得被这样 push 真的太累了，我是不是以后受不了996云云。</strong>萌生了学医更好、或者将来去国企的想法，也和家长聊过这个问题，但最后还是觉得，应该先去大厂实习看看，感受一下。</p>
<p>最后，寒假开始着手前后端博客的开发，并刷了五十道左右力扣，算是没有完全荒废。</p>
<h1 id="意料之喜"><a href="#意料之喜" class="headerlink" title="意料之喜"></a>意料之喜</h1><p>第二学期开学，我继续保持刷力扣的节奏，完成了前后端博客 milestone，进行了小程序的迭代。</p>
<p>写小程序令我十分痛苦，设计一直要求我修改颜色和字体大小，整个开发小程序的感受稀烂，没有什么技术含量，纯粹是搬砖，有了这两次写小程序的经历，我决定以后尽量不碰这个东西。</p>
<p>由于 peer pressure，向身边强者看齐，我还是向字节投出了自己的简历。感觉自己此时还是挺菜，并且荒废了寒假，就只是想试一试，结果居然过了。</p>
<h1 id="错误决定"><a href="#错误决定" class="headerlink" title="错误决定"></a>错误决定</h1><p>字节的三面时，面试官问我“你之后的打算是什么”，我回答：阅读 React / Vue 源码、写一个狼人杀的项目。事实上我确实也打算这样做，狼人杀已经开了个头。因为上一学期的学习比较杂乱，这一学期我打算以实践为主，多做点项目。</p>
<p>这时候，我做了大二下最错误的一个决定。一个学长拉我打中国软件杯，一开始我持观望态度，但内心对参加比赛的好奇，以及学长“组件库几天就能搞定”的话语，无不推动着我。之前我没用过组件库，也很好奇用组件库写项目会有怎样的体验，于是我接受了。</p>
<p>这个项目大致是一个遥感系统，前端上传一些图片，后端对这些图片进行“变化监测”、“地物分类”等操作，前端将处理后的图片呈现出来，并提供轴侧 / 平面视角供用户操作等等。右侧有一个图片的 List，围绕着这个列表存在各种各样的操作。这个项目的操作逻辑比我之前遇到的任何一个都复杂，首先我对 canvas 比较陌生，这个通过查资料不难解决。其次是各种各样的图层操作，当我发现时间紧迫，开始赶 ddl 的时候，就开始在 mobx 的 store 里堆屎山，写出各种难以维护，自己以后都看不懂的代码，并且对大量的 ts 报错置之不理。</p>
<p>并且，组件库也用得不爽，因为所有的样式都写成了行内样式，并且没有好的 css 语法提示。对于存在设计的项目，不宜使用组件库，组件库适用于无设计，且需要保持风格一致的场景。</p>
<p>最终结果是，这个项目一直持续了两三个月，中间穿插了很多考试打乱节奏（都是突击），由于这个赛道太卷，一共几百个队伍，就十几个有省奖，我们拿了省二倒一，升级到了国三，这个操作比较玄学。如果再来一次，我一定好好利用这段时间干点别的，因为时间紧，没有思考怎么写优雅的代码，一直在想怎么搞出功能，写这个软件杯纯搬砖。</p>
<h1 id="捡起日语"><a href="#捡起日语" class="headerlink" title="捡起日语"></a>捡起日语</h1><p>学习日语是我从中学时代就开始的目标，初一我就开始学习五十音，初三毕业买了新标日初级，高一的时候趁着午休在寝室啃新标日，断断续续地学了半本书。高三毕业速通了初级上下册，但是学得很不扎实。于是大二上我一直在回顾 N4 的语法，读课文。我思考，如果继续拖下去，可能大学都学不成日语了，于是大二下，我先是自学课本，然后买了沪江网课，把 N3 和 N2 的内容也速通了，这次词汇也跟着背，沪江开心词场上四本书的词汇都完成一遍记忆。这次我的目标是——12月考过 N2！</p>
<h1 id="字节实习"><a href="#字节实习" class="headerlink" title="字节实习"></a>字节实习</h1><p>当初向学长要内推的时候，他问我是选择偏业务还是技术，我毫不犹豫地选择了技术，这次实习能学到什么呢，还是蛮期待的。</p>
<p>7- 3，上海 - 松江 - 九亭，我和两位学长一起租房，出门就是九号线，船新的体验。</p>
<p>隔天我来到字节，成为互娱研发-前端架构-跨平台部门的一员。刚来的一周阅读各种文档，和 mentor 完成一次 1 on 1，大概了解了部门的组成，有哪些细分方向，大家大概在做什么。</p>
<p>到了第二周，正式开始干活。我的 mentor 把我分给了一个女同事，之后的一个多月，我就一直在这个女同事的手下干活（姑且称其为 L），成为了 R 平台的开发者。大家的工作都很忙，L 也不例外，她的工作都是整块并且比较紧急，很难给我拆分任务。一个多月，我做的都是“微调页面”、“调用现成API”、“临时改个小 bug”等没什么技术含量的活，并且很多时间处于无活可干的状态，这时候我就学学自己想学的，因为部门业务相关的缘故，我还看了一点 Android。一般作息是每天11点到，7点多走，或者偶尔自习到八九点。</p>
<p>到了八月底，我有点受不了这种工作，怀疑这样的实习不能充实自己的简历，就和同事聊了一下，他推荐我把 R 这个平台搞懂，但是这个平台上有各种各样的操作，而文档不够清楚。字节内部很多组有“新人串讲”流程，是转正的一环，我就去找我们组的文档，发现不存在串讲而只有分享（类似于联创内部的分享），对理解 R 没什么帮助。<strong>同事说：“你直接来做技术的部门确实会有这样的情况，L 就是从做业务的部门转过来的，所以她知道业务有哪些痛点，我们这些平台和技术可以解决什么问题。你没有遇到过这些问题，理解不了也正常。”</strong> 或许第一次，还是应该去“搬砖”的业务部门？</p>
<p>到了九月，因为公司楼里阳了一个，被拉去佘山隔离了10天，隔离期中跟 mentor 聊了一次，表示自己想换到别的方向去，mentor 客套地对我的自我反省表示出了赞赏，把我换到了他在做的客户端容器方向上。这个大概就是开发 Native 的容器，容器要为前端提供端能力。结果从这时，一直到实习期结束，我一共就接了两三个小需求，还只有一个是需要写安卓代码的，并且代码量都很小。整个九月约等于没有干活，最后谈 remote 失败，实习就这样结束了。</p>
<p>个人认为，这次实习的硬性提升不大，主要是软性的，首先是熟悉公司和互联网行业，体会作为社会人和学生有什么区别，还有就是对实习的一些感悟，如上所述。在公司，我发现自己解决问题的能力不怎么样，经常需要请教 L，后来我就告诫自己“工程师一定要提高自己解决问题的能力”。<strong>并且从这以后，我不希望自己逃避，要让精神变得更加强大，负起责任来，作为公司的一员，联创 web 的一员，思考“计算机是不是不适合自己”根本没有意义。</strong></p>
<p>实习生在公司的地位很低，我 mentor 跟我商量一个开会的时间，到点了他也可以一拖再拖。并且面试和干的活，确实很不匹配。面试面那么多，分配的活就这？实习也没什么了不起的嘛。</p>
<p>最后夸一夸字节，福利真的不错，免费伙食（外卖）下午茶健身房，各种礼包礼盒，甚至隔离还发$，吹爆好嘛。十月我回到了学校，正式开始了大三的生涯。</p>
<p>其他想说的嘛，感觉人有稍微变自信一点，参加团队招新，在面试时也更加从容。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 ~ 2021</title>
    <url>/2022/05/18/2020~2021/</url>
    <content><![CDATA[<h1 id="挣扎与彷徨"><a href="#挣扎与彷徨" class="headerlink" title="挣扎与彷徨"></a>挣扎与彷徨</h1><h2 id="高三之前"><a href="#高三之前" class="headerlink" title="高三之前"></a>高三之前</h2><p>高中的往事已回忆数次，无非就是这样的开局：不自信/想要变强→怀抱着不切实际要当科学家的妄想→逼迫自己，强迫症/形体化→后悔，无力改变现状。那个时候，基本是个人我都会感到羡慕，我沉沦于无止境的痛苦之中，每天都感觉过得浑浑噩噩，觉得自己的青春和人生就这么被强迫症给废掉了。不论我怎么努力，都感觉自己被限制住了，就是发挥不出来自己的能力，考试也极少进年级前50，比起我初中玩着考入班级前十，现在的我稳在班级前50%都困难。</p>
<p>现在觉得一切不过都是借口，强迫症也并没有那么可怕，虽然它让我的生活变得不太舒服，形体化的后患仍然存在，但并不影响我掌控自己的人生。当时成绩上不去，是我做了太多琐碎的事，摘抄或总结了很多笔记却很少复习且断断续续，自发刷题只坚持了英语，总之没有高效率地学习。顺带一提，这里提到的有些毛病我现在都还没有改掉。</p>
<p>在高二的时候其实我已经认识到（现在我都不知道这种认识是否正确），<strong>自己或许不能专精于任何一个方向</strong>，因为努力学习后也考不到年级顶尖水平。比起某方面的专精，我可能更适合成为全能型庸才（但其实这样我也做不到），所以当时就买了心理学、计算机、美学、音乐的书来看，还读了《混血豺王》和《比尔盖茨传》等。但是这一切在高三到来的时候就又被我抛掷脑后。</p>
<h2 id="疲于奔命"><a href="#疲于奔命" class="headerlink" title="疲于奔命"></a>疲于奔命</h2><p>高二暑假是我此生最短的暑假，短到只有两天。暑假前半段被迫参加每天200块的“名校通”，暑假后半段又要回去补课，回去前的一周我又自愿交钱补习化竞，顺带一提，后期到开学的这段时间我看完《钢之炼金术师》全套漫画。</p>
<p>那个时候，我看到了北大2020的招生简章，简章十分精美，花花绿绿，我们班上放了几本，于是我便热衷于阅读它。那个时候我被北大所深深吸引，开始幻想能不能考上，并且由于自己心态的困境，我特别想去心理学系。其实去不去心理学也无所谓，那时候我觉得读个考古都可以，反正是北大嘛。这样靠着专项计划，我还是得考到680分才可以，而我只有650分的水平，平时的模考只能考580~620区间。</p>
<p>我开始思考着自己如何达到这种“飞跃”，大概是一定要去找自己的节奏，有针对性地提分。前边还是比较顺利，在11月的一次模考中，我同时取得了语文（128，之后再也没达到过）和化学的双班级第一，年级31名，之后一次考试我坐在第一考场，考理综时心态突然崩溃，结果理综考了190，好状态完全止步于这次考试。于是我开始不听讲，不按着学校的复习进度来，自己整些笔记、刷题、网课，这些全都上了。但是随着时间的不断推移，我没觉得自己有什么进步，后边越来越过分。先是伪造病历去办了走读证，在学校旁边租了个小房间便于每天走读回去多学会，也方便刷网课。因为买的网课太多觉得刷不完，然后又跟班主任协商，翘掉四节晚自习。我开始觉得学校老师讲的啥用没有，平时的作业很多都在抄，觉得极其浪费时间，待在学校我都觉得痛苦，我把自己没有进步的错误都归咎于是学校限制了我。一轮复习结束，二轮复习开始，我觉得自己还是老样子。结果这段时间成绩不断下降，位次连着四五次都在一百名开外，老师也在找我谈话。</p>
<p>最后我还是下定决心回家复习去了，结果没走几天撞上疫情，大家都只能在家学习。在家期间我的神经十分紧绷，每天的平均时长在14个小时以上，基本每天就是6点多起床一直学到晚上11点多，除了过年有两三天偷了个懒，三个月没怎么变过。也算是刷完了学校的二轮资料和几本网课资料。但是我仍然觉得自己的学习没有太大起色，从三月起学校开始让学生印模考卷做，我仍然只能考620左右，此时心态十分炸裂，后悔却又无可奈何，那个时候平均两天就会改一次qq签名，正能量的鸡汤背后是深深的负能量。我反思前面做的这一切，终于承认了自己就是普通人的事实，为何要追求680这一虚无缥缈的目标，就这样舒舒服服地苟着不就好了吗？</p>
<h2 id="回归正常"><a href="#回归正常" class="headerlink" title="回归正常"></a>回归正常</h2><p>4月回到学校后我就开始佛系了，不再想着自己去做些什么，而是按部就班地跟着学校。回来的第一次模考，我在数学113血崩的情况下考了年级36，惊艳了一些同学。接下来的一次考试又到了100多名，然后又考了43名，之后就回到以前的段位，考60名左右的水平。事实证明，回家学习的这段时间我大概就物理有了进步，最头疼的数学还是老样子。进步最明显的是心态，我开始没那么在意高考，而且开始对现状持接纳态度，珍惜毕业前的日子。我会趁着晚上走读便利，和朋友去吃华莱士、克莱堡、烧烤，甚至有一天住到他家里。考前两周我为全班同学吹奏《追梦赤子心》，高考完我回去给一位尊敬的老师吹奏《离歌》，弥补了高二的一次遗憾。</p>
<p>那段时间，我也常思考未来，不再去追求一时脑热的化学和心理学专业，觉得作为一个普通人就学个计算机专业，到时候出来工作挣钱就行了。看知乎推荐觉得北邮是一所不错的学校，因为就业率非常高，华科也可以，有“北北邮，南华科”之称。我给自己的计算机专业学校排名是：浙大→北航→华科→北邮→西电/西工。虽然佛系，高考我仍旧全力以赴，最后655收场，语文数学略炸，英语正常，理综略超常，总分是正常水平。周围不少平时一般的同学考到了670+，确实还是有点点不甘心吧。</p>
<p>报志愿的时候，这个分数在我省提前批次确实可以冲一冲华科，往年最高分数是656。但是华科CS给的名额很少，又是热门专业，所以心里没底。就这样，提前批我填了华科（只写了三个专业，还不服从调剂，事后后悔了，因为这不是稳进CS的方案），本一批填了北邮。其实这个分数挺合适的，分低一些我会进入华科非CS专业（光电/能动），分高一点（&gt;660）我说不定会冲进浙大的差专业。最后，事实证明我的担心多余，顺利来到华科CS。从结果上看，我的高考是比较顺利的。</p>
<h2 id="一晃而过的暑假"><a href="#一晃而过的暑假" class="headerlink" title="一晃而过的暑假"></a>一晃而过的暑假</h2><p>暑假开始做一些自己想做的事了，比如说学完标日上下册，还背了一些日语单词；口琴继续练；本来说要做视频，还是没有去学，懂了Pr基本操作，在9月初才剪了一个自己勉强满意的视频；骑车上国道，玩了一天多。</p>
<p>知道自己被华科CS录取后，我又开始“蠢蠢欲动”了，因为本质上我不是一个甘于平庸的人。因为高中的“难忘”经历，我果断地认定卷加权不是适合自己的道路，如何把大学生活过得丰富且有意义，是我最为注重的。早在高考之前，我就听说过华科的“三大团队”，抛开一些功利性的东西不谈，单是出于向往“互联网大学”，我就很想加入。于是我加入了秋招群，在自己并不清楚想要选什么方向的情况下，开始准备冲击联创Lab组，至于为什么是Lab，因为Lab的学习指南里有C，在看到招新信息的时候我已经学了一周的C，不想浪费基础（现在看起来有点可笑）。于是暑假的后半段我每天抽很多时间去看C、Linux，但是都是刷视频且浮光掠影；试着啃了一下黑皮《计算机科学导论》，每天刷个十几二十页，也感觉很难吸收其中的知识，看后就忘。</p>
<p><strong>从这里我开始产生一个矛盾：自己有明确想要学的东西（日语、口琴、视频），但是因为我有别的东西要追求，所以没时间做自己喜欢的事。要做的事多和有限的精力之间产生了不可调和的矛盾。</strong>现在思考一下我想加入团队的原因，无非：①因为高中怎么学都考不进年级前列，对卷加权这件事没有信心，想建立自己在其他方向的优势；②不想继续卷，觉得团队能带来有意义和丰富的生活。其他原因都能归咎于这两点上——想变强/想过不同的生活。</p>
<p>但是要加入团队，又不得不经历一个卷的过程，要努力卷进团队，就没有时间去做自己想做的事了。</p>
<h1 id="步入大学"><a href="#步入大学" class="headerlink" title="步入大学"></a>步入大学</h1><h2 id="确定方向"><a href="#确定方向" class="headerlink" title="确定方向"></a>确定方向</h2><p>来华科以后，新鲜感很快就过去，由于疫情，军训只持续了不到两星期，最后一天坐在潮湿的地面导致我感冒了。这段时间最重要的事就是冲击团队。我同时报名了冰岩、联创和Dian，最开始招新的是冰岩，根据我学习的内容，我选择了程序组。</p>
<p>那个时候我的基础，就是C语言能写<code>printf</code>和<code>if</code>、<code>for</code>循环的程度，连指针和数组都不会用。是的，美其名曰我暑假自学了C语言，其实就是刷视频，而且还没刷到指针，自己的代码能力几乎为0。Linux知道一些如<code>ls</code>、<code>cd</code>、<code>pwd</code>等的常用指令，自己配好了Vmware虚拟机。还稍微看了一点HTML和Python，但是几乎不会用。我还记得自己当时报名信息里吹得天花乱坠，把会的东西全部展开说，达到凑字数的目的，显得这个人很厉害。笔试时拿到题目，我几乎完全懵逼，但是还是硬生生的都编上去了，所有代码题和程序设计题都不会，就强行整个思路上去。最后笔试通过，国庆那天去了1006面试，为了试图作出“努力”的样子，我中午不到1点就到了，然后坐在那里为面试复习，拿起黑皮《计算机科学导论》，但是说实话什么都看不进去。那边有一两个学长学姐，我也不知道怎么跟他们寒暄。我当时思路清奇，走过去跟lyt学长说：“虽然笔试题我都不会，但我还是尽了最大努力去编答案”，似乎是想体现自己的顽强意志，结果得到了“不是给时间学了吗”的回复。然后面试开始，自我介绍，然后谈了自己会的东西，我刻意强调了自己会的都是很简单的皮毛。最后lyt学长问到如何用Python来把一个字符串逆序，我自然是承认自己不会。我最后还不忘补了一刀“我也存在一些同学在群里说的问题，就是像高中一样啃书学习，缺乏实践”。面试自然而然是被挂掉了。我认识到了自己的菜，所以后边的联创和Dian连笔试题都没有做。</p>
<p>当时我觉得，程序组的题目这么难，我自学一学期后端应该也进不了组，而且我高中数学就不是很好，编程可能比不过一些大佬，还是选一个大家都是零基础的、好入门的方向吧。那时候就在知乎上搜，发现前端学习路线非常明确，好像比较简单，加之我之前有一点点HTML的基础，觉得努力学一学期应该可以冲一冲团队，于是我就立刻决定学前端。那时真的是特别想去团队，不去想自己到底热爱什么，想的是什么方向适合我冲击团队。</p>
<p><strong>其实大学四年的时间很长，完全可以什么方向都学一些，再看看自己到底喜欢什么方向；或许自己不适合搞开发，那么就应该去读研。但我的决定就是做得这么快。</strong></p>
<h2 id="生活与学习"><a href="#生活与学习" class="headerlink" title="生活与学习"></a>生活与学习</h2><p>我的大学，从一开始就放弃参加内卷游戏，选择冲击团队之路后，我还希望自己的生活过得丰富一些。于是加入了车协，去骑东湖、骑八分山、骑到武大。武大百团的时候，我还加入了樱之音口琴社（虽然加入后从没参加过活动）。</p>
<p>不知怎么，现在的我已经没法沉下心来玩很长时间的游戏了，玩的时间一长就会导致做别的事情的时间变少，内心就会产生焦虑。其实我一点也不喜欢这样，初中那时一日十来个小时的游戏生活已经彻底远去。其他时间，就是看一看动漫，比起新番，我倾向于老的经典番剧，名作之壁。暑假看了凉宫、石头门、强风吹拂、排球、轻音、京吹，开学后继续看巨人、狼辛，后来又看了钢炼03、小圆、天元、Fate…</p>
<p>然后谈谈学习吧，为了抽出来更多时间来学技术，学校排的课我都疯狂水过，还翘了不少课。平时简单自学一下，做作业都是面向答案，考前再突击一下，第一学期除了期中线代挂掉，其他的科目都还能看，总加权也算混进了前50%，自己还是比较满意的。</p>
<p>但是技术学习，我还存在很多问题。首先我学习主要靠看视频（视频比较系统，看完了可以大概知道一个东西怎么做），而且对于100多集的视频，我一天也就看3~6集，所以学起来的速度非常慢，学完了还缺乏实践。于是就这样，我花了三个多月才完三剑客基础+Markdown，这种学习速度让我变得更加自卑，我不停地安慰自己：“不可心急，日积月累”。我想冲团队的愿望也影响了寝室的氛围，大家或多或少都在学习技术上的东西。</p>
<p>还有一件不愿提及但是不得不提的事就是摔牙，那时候我也抑郁了一阵子，觉得自己不能啃东西了什么的，但是时间可以冲淡悲伤，现在的我也逐渐接纳了这件事。</p>
<h2 id="忙碌的寒假"><a href="#忙碌的寒假" class="headerlink" title="忙碌的寒假"></a>忙碌的寒假</h2><p>我把寒假当作自己冲击冰岩的关键期，所以依然努力学习前端技术。我深入了一些JS，照着冰岩往年的笔试题来补充知识点，看了不少博客，最后觉得自己的实践能力不足，所以又复刻了一些页面。</p>
<p>因为团队是鞭策我学习的重要因素，有时候我会上网搜索信息，读完以后我就会动力十足，继续学习。一次在Github上搜索冰岩，找到了以前夏令营开的仓库，以此我了解到了gc学姐，一次问她js问题的时候，她向我发了一篇博客，是xiong35学长的。当时我就觉得学长很强，这激励了我花了三天时间，去搞了一个WP博客。然后我也加了学长的好友，稍微聊了一些后他鼓励了我，说我春招很有希望进入冰岩。当时的我，确实也有了一些进入冰岩的自信。</p>
<h2 id="冲冰岩失败"><a href="#冲冰岩失败" class="headerlink" title="冲冰岩失败"></a>冲冰岩失败</h2><p>开学以后，我一直期盼着冰岩的招新信息。这段时间我继续完成寒假的项目，以及看博客补充新的知识。很快招新就来了，因为心里激动，简历我是改了又改，最后我作了个大死，说自己搜冰岩的信息，想借此体现自己的热爱。殊不知，这是给自己挖了个天大的坑。我以为秋招面试被挂能带来一些教训，结果春招时我情商还是老样子。</p>
<p>就这样我一路杀过简历、面试，实习选题时，我不敢给自己选太难的，就还是老老实实复刻网页。因为实习只能通过很少的人，而实习名单里好像有实力很强的大二学长，我就还是不自信。实习期我疯狂翘课抄作业，硬是把所有Level基本完成了，展示时我想让自己说得更有条理一些，于是准备了稿子（作死*2），展示完后我觉得自己稳了。</p>
<p>然后就到了组面，在门外，我开始在脑海中构思着自我介绍。我一进门气氛就冷到冰点，然后就是我自顾自地说了很多（作死*3），接着被xiong35学长问到查资料的事，我也没有作出很好的解释。之后面试官问我还有没有什么问题，我反向让他们继续问我，结果被问到了答不上来的问题，场面继续尴尬。后面结局基本就注定了，组面没有通过。</p>
<h2 id="继续迷茫"><a href="#继续迷茫" class="headerlink" title="继续迷茫"></a>继续迷茫</h2><p>组面结束后的那个下午，我就不带手机绕着主校区走了一圈，以排解心中的苦闷。后来我的舍友A通过了冰岩程序组的考核，舍友B通过了Dian的考核。当时最想进入团队的我就这样落败，而他们怀着试一试的心态参与，就这样顺利进入了，一点都不羡慕是不可能的。</p>
<p>后来xiong35学长找我谈，说我技术很强，但是因为如上列举的原因没有让我通过，自己的风格和团队不符，让我找到适合自己的组织。后来我又联系了欧阳学姐，她说我“痴迷于技术”，“有种理工男呆呆的感觉”，“像个geek”，“忽略了一些情商方面的东西”（当然，我从来不认为自己像个Geek，因为Geek这个词给我一种很强的感觉，后来HackDay的队友也认为我完全不像是geek）。</p>
<p>我开始迷茫了，竟然在技术过关的情况下，因为别的因素被团队挂掉，我不太能接受这个结局。而且说我技术很强，那个时候我还真的相信了，开始考虑换方向，甚至是读研——毕竟学习能力强嘛，又何必局限于“简单”的前端。但是我技术真的强吗，也不强。学了五六个月还是这么点水平。想想xiong35学长充沛的精力和很强的学习能力，从零开始40天就能写博客的前后端，我就觉得自己什么都算不上。最后我还是继续学前端，不想浪费基础，而且还可以继续冲击团队。</p>
<p>可是说实话，我真的喜欢前端吗？不喜欢也不讨厌吧，遇到Bug会抓耳挠腮十分难受，可是解决问题时也会有巨大的成就感。写出赏心悦目的页面也可以给我带来正向反馈，但是也就仅仅是网页而已。现在我最需要的，大概就是要做出一个产品吧？一直孤立地自学，啃厚厚的书籍却什么也不做，又有何乐趣可言呢？总之，我目前还像是停留在“为了学习而学习，为了团队而学习”，而不是“为了需求而学习，一边实践一边学习”。</p>
<p>这学期的课内学习要比上学期拉跨了，一来是课业明显变得繁重，二是难度开始加大。我的态度也比上学期要松懈了许多，作业中有很多没有搞懂的内容，考试前复习得也不充分，就这样，我的微积分期中考试直接挂科。以后必须要改善学习方法了，不想投入时间又不想挂科的话，必须要依赖网上的“速成课”，或者慕课。</p>
<p>现在的我，还是想先坚持前端的路线，体验一下开发到底是什么感觉，后续作出的决定，很大程度上与我有没有进入团队有关。之前我想的是本科毕业就去投前端岗，去大厂996，但是最好还是读一下研究生，去外企955吧。</p>
<p>希望HackDay和暑假的夏令营能带来一些转变吧。</p>
<h2 id="Hack-Day"><a href="#Hack-Day" class="headerlink" title="Hack Day"></a>Hack Day</h2><p>以下记录HackDay经历和带来的一些转变：</p>
<p>那是一节国际金融公选课，抄完大物答案百无聊赖的我打开了微信，看见了联创的最新推文——HackDay Reboot。其实这种比赛，我一般是不敢去想的——奖金丰厚、大佬云集，既然标榜是“极客狂欢”，和我这样的蒟蒻又有什么关系呢。但最后思量着，6月14日结束后应该来得及备考期末，况且可以学到不少东西，我还是决定报名。</p>
<p>进入FAQ群后，我本来决定报名后到现场组队，令我没有想到的是，一个冰岩的同学邀请我加入他们。最后三个冰岩人和我这个野路子组成了“启明好难队”。既然和冰岩同学组队了，我就不敢掉以轻心，生怕拖了他们的后腿。</p>
<p>我开始做知乎的项目练习前后端交互，开始写移动端，学了swiper插件（用于移动端滑动页面），由于发现原生JS的效率实在不高，在参加比赛的前一晚我入门了JQuery。</p>
<p>6月13日很快到来，我们先是在报告厅举办了开幕式，然后来到12楼，我被满眼的饮料和零食惊到了，没见过这种大场面。我们之前储备的idea押到了今年的关键字“择”，于是每个人就开始各搞各的，详细比赛过程就不多言。白嫖蒸功夫、披萨、小龙虾、K记的感觉真是太爽了，明年还来。</p>
<p>这次比赛印证了一点——我的技术确实存在短板，思维也常常跟不上，很多需求没做出来，设计的图也只用到一张。后端帮助了我很多，包括熬夜一整晚帮忙理清部分JS逻辑（惭愧）。命悬一刻的时候，都是后端救了我。没有我的队友，真的连阉割版产品都拿不出来。<br>一轮筛选的嘉宾有思否CEO高阳，有幸通过一轮筛选进入二轮，虽然最终没有获奖，但是已经很满意了。</p>
<p>顺带一提，同房间的大佬做的游戏实在牛逼（Re0从零开始的HUST生活），现场效果爆炸，拔得头筹。听到他们的商量和激烈的辩论，我发现，原来这就是Geek，他们对编程的热爱，是溢于言表的，即便是旁人也能深受感染，不像我遇到Bug时的萎靡无力。</p>
<p>经过HackDay，我认识到，学习编程是为了兴趣而非为了团队，真正的Geek用编程改变世界。几个月以来，在加入团队的室友和我侃侃而谈，以及和冰岩同学组队参加比赛之后，我愈来愈觉得，<strong>加入团队也并非我以前所以为的那样光鲜亮丽，团队人≠人上人。抬高对方，疯狂自贬的行为是错误的。</strong></p>
<p>看见大佬开发游戏的时候，我对游戏开发也产生了一定的兴趣，遂希望以后可以学一些框架去开发网页游戏。并且我认为，只是写网页确实有些普通，尝试客户端APP的开发也是一条可行之路。前端追求的是炫酷的特效和优秀的用户体验，我觉得也不错。当下先继续打好前端基础，<strong>不要把加入团队当作自己前进的动力</strong>，要因为喜欢，所以才用汗水浇灌它，哪怕最终什么团队都没加入，自己也可以在沁苑一隅发光发热。</p>
<h2 id="双开夏令营"><a href="#双开夏令营" class="headerlink" title="双开夏令营"></a>双开夏令营</h2><p>大一下学期很快结束，由于先前被冰岩拒绝，我打算只报联创的夏令营，但是冰岩的推文先发了出来。本来笃定只报联创的，看到推文时我还是犹豫了一瞬。</p>
<p>0.am，躺在床上的我突然想到 xiong35 学长曾经多开过夏令营，便立即下床拿起手机，询问他冰岩和联创夏令营学习内容的区别，以及双开的可行性，没想到他立即作出了详尽的答复，也没有劝退我。<strong>在经过深思熟虑后，为了学到更多，我打算双开。</strong></p>
<p>7月5日冰岩夏令营开始，一直持续到7月24日，期间我每天和隔壁班的 kk 同学待在1006学习前端。冰岩夏令营开始后不久，我参加联创的面试并顺利通过。大概从7月15日开始，我开始双开，以14点和20点为分界线，分别完成两边的任务。</p>
<p>冰岩的任务大概是：写一个递归替换文件内字符串和文件名的脚本，写 http-server，用 js 和 vue2 复刻todo-list（其实任务不多，但我当时还没改正刷视频学习的习惯，vue就学了五六天）</p>
<p>联创是：实现基本数据结构，用 js 写 markdown 编辑器，复刻响应式守望先锋官网，最后 hackweek 当了一把后端（但是前后端都没经验，没配合好，最后拉了）</p>
<p>现在回首那段时间，其实学的东西真不多，原生js我早就写腻歪了，又写了一些感觉也没什么太大提高，复刻网页又没什么意思，纯纯的收获就只是学了 vue…又一次感受到了挫败感。我的学习内容，和 xiong35 学长的描述并不一致…..那段时间每天东北菜周麻婆，可能胖了几斤。</p>
<h2 id="稍微荒废的暑假"><a href="#稍微荒废的暑假" class="headerlink" title="稍微荒废的暑假"></a>稍微荒废的暑假</h2><p>暑假之前，我本来想在假期做俩项目，比如说自己手写博客前后端，比如重做 cmind。结果一到暑假就开始摸鱼，最后的学习成果就是水了几十道洛谷，刷了几套视频（linux，c++，dart），用 vue3 再复刻了一遍todo，完善搭出的 hexo 博客。</p>
<p>由于我在夏令营的表现不错，再加上联创夏令营 uu 们的鼓励，我收到了 web 组的 offer，起初我一直觉得做产品的冰岩可能和我更搭，联创的话，自己可能不具有“极客”气质……</p>
<p>但是在联创呆久以后，也和同学聊过，贵创比较自由，学技术打比赛做产品都是随心所欲的，不用被锅束缚其实还是好事，而且不同团队的同学之间也大多认识，比如加入联创后，冰岩的 xiong35 学长仍然给了我很多帮助。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《自顶向下方法》读书笔记</title>
    <url>/2021/11/30/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="计算机网络和因特网"><a href="#计算机网络和因特网" class="headerlink" title="计算机网络和因特网"></a>计算机网络和因特网</h1><p><img src="https://z3.ax1x.com/2021/11/02/IFz9iR.png"></p>
<p>注意<code>传输时延</code>和<code>传播时延</code>间的区别</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><img src="https://z3.ax1x.com/2021/11/02/IFxMKU.png" style="zoom:;">



<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="幂等与非幂等"><a href="#幂等与非幂等" class="headerlink" title="幂等与非幂等"></a>幂等与非幂等</h3><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用</p>
<ul>
<li><p>幂等：对于同一种行为，如果执行不论多少次，最终的结果都是一致相同的</p>
</li>
<li><p>非幂等：对于同一种行为，如果最终的结果与执行的次数有关，每次执行后结果都不相同</p>
</li>
</ul>
<p>分析常见HTTP方法的幂等性：</p>
<ul>
<li><p>GET：<code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用</p>
</li>
<li><p>PUT：<strong>PUT所对应的URI是要创建或更新的资源本身</strong></p>
<p><code>PUT http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即更新id为4231的帖子，因此多次调用或刷新页面而不必担心引起错误</p>
</li>
<li><p>DELETE：<code>DELETE http://www.forum.com/article/4231</code>，和PUT同理</p>
</li>
<li><p>POST：<strong>POST所对应的URI并非创建的资源本身，而是资源的接收者</strong></p>
<p><code>POST http://www.forum.com/articles</code>的语义是在 <a href="http://www.forum.com/articles%E4%B8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E5%B8%96%E5%AD%90%EF%BC%8CHTTP%E5%93%8D%E5%BA%94%E4%B8%AD%E5%BA%94%E5%8C%85%E5%90%AB%E5%B8%96%E5%AD%90%E7%9A%84%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E4%BB%A5%E5%8F%8A%E5%B8%96%E5%AD%90%E7%9A%84URI%E3%80%82%E4%B8%A4%E6%AC%A1%E7%9B%B8%E5%90%8C%E7%9A%84POST%E8%AF%B7%E6%B1%82%E4%BC%9A%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%88%9B%E5%BB%BA%E4%B8%A4%E4%BB%BD%E8%B5%84%E6%BA%90%EF%BC%8C%E5%AE%83%E4%BB%AC%E5%85%B7%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84URI">http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI</a></p>
</li>
</ul>
<h3 id="HTTP-1-0-1-1-2-0"><a href="#HTTP-1-0-1-1-2-0" class="headerlink" title="HTTP 1.0/1.1/2.0"></a>HTTP 1.0/1.1/2.0</h3><p><a href="https://segmentfault.com/a/1190000015316332">深入理解http1.x、http 2和https</a></p>
<ul>
<li>1.1：<ul>
<li><strong>长连接</strong>：新增 Connection 字段，可以设置 keep-alive 值保持 tcp 连接不断开</li>
<li><strong>管道化</strong>：基于长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回 (e.g.请求1 –&gt; 请求2 –&gt; 请求3 &gt; 响应1 –&gt; 响应2 –&gt; 响应3)</li>
<li><strong>缓存处理</strong>：新增字段 cache-control</li>
<li><strong>断点传输（分块）：</strong>新增 Range 和 Content-Range 字段，服务端每产生一块数据，就将其发送</li>
</ul>
</li>
<li>2：<ul>
<li><strong>二进制分帧</strong>：HTTP 1.x 的解析是基于文本，HTTP 2 之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</li>
<li><strong>多路复用</strong>： 在共享 TCP 连接的基础上同时发送请求和响应，避免线程阻塞</li>
<li><strong>头部压缩</strong>：HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源</li>
<li><strong>服务器推送</strong>：服务器可以额外的向客户端推送资源，而无需客户端明确的请求</li>
</ul>
</li>
</ul>
<h3 id="cookie-的工作过程"><a href="#cookie-的工作过程" class="headerlink" title="cookie 的工作过程"></a>cookie 的工作过程</h3><ol>
<li><p>用户访问某网站，发送请求报文</p>
</li>
<li><p>网站产生唯一识别码(Session ID)，以此作为索引在后端数据库产生一个表项</p>
</li>
<li><p>服务器用一个包含<code>Set-cookie</code>首部的报文进行响应，其中该首部含有识别码</p>
</li>
<li><p>浏览器收到该报文时，会在其管理的 cookie 文件中添加一行，包含服务器主机名和识别码</p>
</li>
<li><p>用户再次访问某网站，浏览器查询 cookie 文件，在请求报文中添加 <code>cookie</code> 首部，值为之前的识别码</p>
</li>
</ol>
<blockquote>
<p>A session ID is a unique number that a Web site’s server assigns a specific user for the duration of that user’s visit (session). The session ID can be stored as a cookie, form field, or URL (Uniform Resource Locator). Some Web servers generate session IDs by simply incrementing static numbers.</p>
</blockquote>
<h3 id="输入url到展示页面的过程"><a href="#输入url到展示页面的过程" class="headerlink" title="输入url到展示页面的过程"></a>输入url到展示页面的过程</h3><p><a href="https://zhuanlan.zhihu.com/p/133906695">从输入 URL 到页面展示到底发生了什么？看完吊打面试官！</a></p>
<h3 id="辨析常见名词"><a href="#辨析常见名词" class="headerlink" title="辨析常见名词"></a>辨析常见名词</h3><p><a href="https://juejin.cn/post/6844904034181070861">傻傻分不清之 Cookie、Session、Token、JWT</a></p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP的问题：消息被窃听、通信方身份被伪装、报文被篡改</p>
<p><strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong></p>
<h3 id="加密和认证"><a href="#加密和认证" class="headerlink" title="加密和认证"></a>加密和认证</h3><p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的<strong>混合加密机制</strong>（在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式）</p>
<img src="https://z3.ax1x.com/2021/11/29/oQNam4.png" style="zoom:80%;">



<h3 id="安全通信机制"><a href="#安全通信机制" class="headerlink" title="安全通信机制"></a>安全通信机制</h3><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><h3 id="为什么客户代理要先将报文发送至自己的邮件服务器"><a href="#为什么客户代理要先将报文发送至自己的邮件服务器" class="headerlink" title="为什么客户代理要先将报文发送至自己的邮件服务器"></a>为什么客户代理要先将报文发送至自己的邮件服务器</h3><p>如果不通过自身的邮件服务器进行中继，用户代理没有任何办法到达一个不可达的目的地接收服务器</p>
<p>将邮件存放至自身的邮件服务器，就可以重复尝试向目的地服务器发送报文</p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h3 id="主动模式和被动模式"><a href="#主动模式和被动模式" class="headerlink" title="主动模式和被动模式"></a>主动模式和被动模式</h3><p>参考：</p>
<ul>
<li><p><a href="https://www.huaweicloud.com/zhishi/2006281029.html">https://www.huaweicloud.com/zhishi/2006281029.html</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/93190903">https://zhuanlan.zhihu.com/p/93190903</a></p>
</li>
</ul>
<h4 id="主动模式"><a href="#主动模式" class="headerlink" title="主动模式"></a>主动模式</h4><ul>
<li><p>客户端从一个任意的非特权端口N（N&gt;1024）连接到FTP服务器的21端口</p>
</li>
<li><p>客户端开始监听N+1，并发送FTP命令<code>port N+1</code>到FTP服务器</p>
</li>
<li><p>接着服务器会从它自己的数据端口（20）连接到客户端指定的数据端口（N+1）</p>
</li>
</ul>
<img src="https://bbs-img-cbc-cn.obs.cn-north-1.myhuaweicloud.com/data/attachment/forum/202005/14/103313jcd0xebu4twdflam.png" style="zoom: 80%;">

<p>主动模式的弊端：</p>
<p>FTP 的客户端并不会主动连接到服务器的数据端口，而是是告诉服务器它正在监听哪个端口，然后服务器发起连接到客户端上指定的端口。但是，<strong>这样的连接有时候会被客户端的防火墙阻止</strong></p>
<h4 id="被动模式"><a href="#被动模式" class="headerlink" title="被动模式"></a>被动模式</h4><ul>
<li>客户端打开两个任意的非特权本地端口N（N&gt;1024）和 N+1</li>
<li>端口N连接服务器的21端口，客户端提交<code>PASV命令</code>给服务端</li>
<li>服务器开启一个任意的非特权端口（P&gt;1024），并发送<code>PORT P</code>命令给客户端</li>
<li>接着客户端会从本地端口（N+1）连接到服务器的端口P</li>
</ul>
<img src="https://bbs-img-cbc-cn.obs.cn-north-1.myhuaweicloud.com/data/attachment/forum/202005/14/103319fo2vuhsbb8gqqemk.png" style="zoom:80%;">

<h2 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><strong>XSS</strong> 全称是 Cross Site Scripting（跨站脚本）。是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段，它利用的是用户对指定网站的信任，用户不知道该网站被注入了恶意脚本</p>
<p>两大要素：</p>
<ol>
<li>攻击者提交恶意代码</li>
<li>浏览器执行恶意代码</li>
</ol>
<p>预防：</p>
<ol>
<li>服务器对输入的脚本进行过滤／转码</li>
<li>使用 CSP 让服务器决定浏览器可以加载哪些资源，执行哪些脚本。CSP 不仅可以规定资源来源，还可以禁止脚本向第三方提交数据，同时在出现异常时，也能向维护人员及时上报异常</li>
</ol>
<h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><p>Content Security Policy 内容安全策略</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html">Content Security Policy 入门教程</a></p>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>跨站请求伪造，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作。利用的是网站对用户网页浏览器的信任，浏览器的请求（比如转账）不是遵从用户自身的意愿</p>
<p>比如攻击者发给用户一个链接，</p>
<blockquote>
<p>假如一家银行用以运行转账操作的URL地址如下：<a href="http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</a><br>那么，一个恶意攻击者可以在另一个网站上放置如下代码： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>服务器没有做类型判断，把图片资源当xhr处理，如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金</p>
</blockquote>
<p>预防：</p>
<ol>
<li>从第三方站点发送请求时，禁止发送 Cookie —— Set-Cookie 中设置 SameSite 为 Strict </li>
<li>验证请求的来源站点 —— 通过 Request Header: Referer || Origin </li>
<li>CSRF Token 验证，服务器要求所有请求必须携带 CSRF Token ，第三方无法拿到 Token ，伪造的请求会被拒绝访问</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><img src="https://z3.ax1x.com/2021/11/02/IknZmd.png"></p>
<h2 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h2><p>只有三次握手才能确认双方的接收与发送能力是否正常</p>
<ul>
<li><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的</p>
</li>
<li><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常</p>
</li>
<li><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常</p>
</li>
</ul>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p><img src="https://z3.ax1x.com/2021/11/03/IAO6uF.png"></p>
<p>ICMP 和 PING: <a href="https://zhuanlan.zhihu.com/p/82184458">https://zhuanlan.zhihu.com/p/82184458</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="理解-SOA、RESTful"><a href="#理解-SOA、RESTful" class="headerlink" title="理解 SOA、RESTful"></a>理解 SOA、RESTful</h2><p><a href="https://www.zhihu.com/question/42061683">如何通俗易懂地解释什么是SOA？</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a></p>
<p>SOA：Service-Oriented Architecture  面向服务架构</p>
<blockquote>
<p>SOA是一种设计方法，其中包含多个服务，而服务之间通过配合最终会提供一系列功能。一个服务通常以独立的形式存在于操作系统进程中。服务之间通过网络调用，而非采用进程内调用的方式进行通信</p>
</blockquote>
<p>REST：(Resource) Representational State Transfer</p>
<blockquote>
<p>什么是RESTful架构：</p>
<ol>
<li>每一个URI代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现层；</li>
<li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li>
</ol>
</blockquote>
<blockquote>
<p>实际上SOA只是一种架构设计模式，而SOAP、REST、RPC就是根据这种设计模式构建出来的规范</p>
<p>其中SOAP通俗理解就是http+xml的形式，REST就是http+json的形式，RPC是基于socket的形式。</p>
<p>CXF就是典型的SOAP/REST框架，dubbo就是典型的RPC框架，而SpringCloud就是遵守REST规范的生态系统</p>
</blockquote>
]]></content>
      <categories>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计网</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 设计模式概要</title>
    <url>/2021/11/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81/</url>
    <content><![CDATA[<p>参考博客：<a href="https://juejin.cn/post/6844904032826294286">https://juejin.cn/post/6844904032826294286</a></p>
<p>最少知识原则：</p>
<blockquote>
<p>迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。 英文简写为: LOD。</p>
</blockquote>
<p>简要概括每种设计模式的含义：</p>
<ul>
<li><p>工厂模式：<strong>定义一个用于创建对象的接口，子类通过该接口决定实例化哪一个类。</strong>现有类A，它有工厂子类B，调用B的 create 方法会创建A的一个实例对象。实例：jQuery的<code>$</code></p>
</li>
<li><p>单例模式：<strong>一个类只有一个实例，并提供一个访问它的全局访问点。</strong>实例：登录框</p>
</li>
<li><p>适配器模式：<strong>将一个类的接口转化为另外一个接口，从而满足需求。</strong>形象地理解，就是提供一个不同版本的插头。比如类A中有方法 method，B中定义同名方法，该方法内执行A的 method 并做额外的适配。实例：Vue 的<code>computed</code></p>
</li>
<li><p>装饰者模式：<strong>在不改变原对象的基础上，动态地给某个对象添加一些额外的职责（拓展功能）</strong>，是一种实现继承的替代方案。比如A对象可以创建一个手机，B是A的装饰者，则B对象在创建手机的时候同时创建一个手机壳</p>
</li>
<li><p>代理模式：<strong>为一个对象提供一个代理，以便控制对它的访问。</strong>A请求代理，代理做一些事后请求B</p>
</li>
<li><p>外观模式：<strong>定义了一个高层接口，为子系统的一组接口提供一个一致的界面</strong>，比如兼容浏览器事件绑定（if-else 为不同的浏览器提高不同的方法）、封装接口（把众多接口集中在一起），不符合开闭原则</p>
</li>
<li><p>观察者模式：<strong>多个观察者对象同时监听某一个主题对象，主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己。</strong>实例：DOM 事件、Vue 响应式</p>
<blockquote>
<p>观察者模式 和 发布/订阅模式 的区别：</p>
<p>观察者模式：观察者观察目标（监听目标）=&gt; 目标发生变化 =&gt; 目标主动通知观察者。观察者对应订阅者，目标对应发布者，二者直接关联，耦合在一起，灵活性降低</p>
<p>发布/订阅模式：订阅者和发布者之间还存在事件中心，它可以是一个消息管道（事件队列），发布者将消息加入管道，管道再把这些消息推向订阅者。观察者和订阅者之间不直接关联，无耦合，但由于事件队列的存在，内存消耗较大</p>
</blockquote>
</li>
<li><p>状态模式：<strong>定义多个状态类，允许一个对象在其内部状态改变的时候改变它的行为。</strong>比如 Context 类是一盏灯，状态类 Weak、Strong、Off 分别可以改变它的状态，这样就可以在状态类中定义一些行为，即修改状态的同时就会执行这些行为</p>
</li>
<li><p>迭代器模式：<strong>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</strong>实例：forEach，$.each()，Iterator</p>
</li>
<li><p>桥接模式：<strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</strong>比如现有 Color 类和 Shape 类，Shape 类提供 draw 方法，但 draw 方法访问了 Color 类中的属性（即由 Color 类来实现），即 Shape 类中的抽象部分在 Color 类中实现，相当于把 Color 类桥接到了 Shape 类中</p>
</li>
<li><p>组合模式：<strong>将对象分为”整体”和”部分”，在”部分”中实现逻辑，在”总体”中把它们组合起来，并且使得对单个对象和组合对象的使用具有一致性（提供同名接口）。</strong>比如可以买车票（train 类），可以订房间（hotel 类），也可以买车票同时订房间（total 类，由前两者组合而来），它们都拥有 create方法，其中total 的 create 方法可以分别调用 train 和 hotel 的 create 方法</p>
</li>
<li><p>原型模式：<strong>用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</strong>用继承实现，表现在 ES6 上，就是在子类的构造函数中调用 super() 方法，没有特别之处</p>
</li>
<li><p>策略模式：<strong>提供多种策略对象，将算法的使用与算法的实现分离开来。</strong>它由策略类和环境类组成，环境类接收请求，并委托给某一个策略类</p>
</li>
<li><p>享元模式：<strong>将目标对象的状态区分为内部状态和外部状态，内部状态相同的对象可以被共享出来指向同一个内部状态。</strong>内部状态如考场和考试用车，外部状态如考生信息。考场和考试用车由于有共同特点，可以引用已经创建好的考场对象和车对象（这些对象称作细粒度对象，可以改进成资源池），从而节约资源</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/79819642">https://zhuanlan.zhihu.com/p/79819642</a></p>
</li>
</ul>
<img src="https://pic1.zhimg.com/80/v2-b77f736d5d042fd9da6deb06229e9008_720w.jpg" style="zoom: 80%;">



<ul>
<li><p>模板方法模式：<strong>由抽象父类 + 实现子类组成，父类中实现公共方法和封装子类中方法的执行顺序，子类实现这些方法，也可以重写父类的方法</strong></p>
</li>
<li><p>职责链模式：<strong>将多个对象连成一条链，并沿着这条链传递请求，使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。</strong>比如请假审批，需要组长审批、经理审批、总监审批，就需要沿着这条职责链执行</p>
</li>
<li><p>命令模式：<strong>封装接收类、命令类（和触发类），命令类收到请求后，通知接收类执行相关的功能</strong>，这样做的好处是命令发出者和接受者解耦</p>
</li>
<li><p>备忘录模式：<strong>提供了一种可以恢复状态的机制，方便地回到某个历史的状态。</strong>设置备忘类、备忘列表，备忘列表中存放备忘类实例对象，提供方法存放存储和恢复历史状态</p>
</li>
<li><p>中介者模式：<strong>增加一个中介者对象，所有的相关对象都通过中介者对象来通信，而不是互相引用</strong>，使得多对多关系简化为一对多关系</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Talk with rabbit</title>
    <url>/2021/10/24/Talk%20with%20rabbit/</url>
    <content><![CDATA[<h1 id="Talk-with-rabbit"><a href="#Talk-with-rabbit" class="headerlink" title="Talk with rabbit"></a>Talk with rabbit</h1><p>2021 10.24 1 on 1 with rabbit, thanks a lot!</p>
<ol>
<li><p>算法和数据结构相关</p>
<ul>
<li>看算导，需要理解每个算法的原理，为什么要这样做？证明大概理解是什么意思即可，不需要看得很细。基础算法熟练掌握，提高算法了解即可</li>
<li>在熟悉算法后，刷力扣，不推崇题海战术，就算只刷10道题，也要透彻搞懂每道题为什么要这样做</li>
</ul>
</li>
<li><p>实习相关</p>
<ul>
<li>第一段实习很可能会踩坑，大二暑实可以早试错，踩坑的表现包括：①进了一个氛围不合的组 ②觉得Mentor很傻逼…即便如此也要搞好关系</li>
<li>踩坑后，可以明白自己适合什么方向，适合什么类型的组，是否适合互联网行业</li>
<li>实习的主要目的有两点：<strong>硬实力</strong>（英语，技术，Presentation）和<strong>软实力</strong>（沟通能力）的提高，钱是其次的</li>
<li>在打算找实习的时候可以使用团队资源，请求内推</li>
</ul>
</li>
<li><p>计算机基础相关</p>
<ul>
<li><strong>计网只需要掌握应用层+传输层+IP</strong>，越熟悉越好</li>
<li>不需要刷完《自顶向下》课后题，lab也可以只挑感兴趣的做</li>
<li><strong>在实践中学习</strong>，多做应用实践相关的，可以抓包练习</li>
<li>CSAPP比较重要，推荐全部看完，但可以感兴趣的章节优先。如果时间不充裕，可以暂时降低CSAPP的优先度</li>
<li>部分公司的面试（如腾讯）可能涉及汇编等知识</li>
</ul>
</li>
<li><p>职业规划相关</p>
<ul>
<li><p>几条路线：①赚钱 ②移民 ③技术发展 ④balance</p>
</li>
<li><p>赚钱：去大厂=&gt;去创业公司，尤其是打算上市的公司，持有原始股</p>
</li>
<li><p>移民：①去国外读三年书（不考虑）②去外企工作，签证，几年后获得绿卡</p>
</li>
<li><p>技术发展：去创业公司</p>
</li>
<li><p>balance：①去不卷的公司，或大厂不卷的组 ②去外企965，不过要求效率较高，在公司时会比较累</p>
</li>
<li><p><strong>大厂是一个跳板，先去大厂刷3~5年履历，再去其他地方是一个不错的选择</strong>，不过一般去大厂的话，基础设施等已经完备，个人influnce较小，技术提升空间不大</p>
</li>
<li><p>在公司里，不论是什么岗位，本质上都是打工人。程序员鄙视链一般在学校才会发生，不必在意他人的看法</p>
</li>
</ul>
</li>
<li><p>深度和广度相关</p>
<ul>
<li><p>无论前端还是后端，在公司里都可以细化成很多方向，比如说前端有人会做数据可视化，有人捣鼓框架，有人造轮子（UI库），有人画页面…</p>
</li>
<li><p>在学校里技术很难精深到一个方向，相比工业界的产品，我们写的东西只能称作”玩具”，即使在学校里深入很久也比不上工作一段时间，不妨<strong>提高广度</strong>，多去了解一些东西</p>
</li>
<li><p>能深入的东西只有基础，比如说算法、计网、CSAPP</p>
</li>
<li><p>如果觉得自己的基础没问题，面试准备也没有问题，可以去拓展学习其他内容，比如说客户端和游戏</p>
</li>
<li><p>顺便说一下国内厂和外企的区别：国外招人的时候是”软件工程师”，只要求计算机基础，5年内可以更换自己的方向，成为senior后才要求精进一个方向；而国内在招人的时候就分方向，且很难从一种岗位转移到另一种岗位</p>
</li>
</ul>
</li>
<li><p>课内相关</p>
<ul>
<li>笃定工作的话，课都可以翘，实验都可以水，<strong>一切靠突击是可行的</strong>，摆烂摆多了就习惯了</li>
<li>有些课真的没有用，比如数电模电…</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 笔记</title>
    <url>/2021/08/26/Linux%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="网络连接的三种方式"><a href="#网络连接的三种方式" class="headerlink" title="网络连接的三种方式"></a>网络连接的三种方式</h2><p>同一网段下（如在192.168.0下）的主机可以互相通信</p>
<p>三种方式：</p>
<ul>
<li><p>桥接模式：虚拟系统可以和外部系统相互通讯，但是容易造成IP冲突</p>
</li>
<li><p>NAT模式：网络地址转换模式，虚拟系统可以和外部系统相互通讯（通过代理），不造成IP冲突</p>
</li>
<li><p>主机模式：独立系统，不与外部发生联系</p>
</li>
</ul>
<h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>特点：</p>
<ul>
<li>层级式的树状目录结构</li>
<li>linux中一切皆文件（linux会把硬件映射成文件来管理）</li>
</ul>
<p>具体目录结构：</p>
<ul>
<li>/bin ：存放常用命令</li>
<li>/sbin：存放系统管理员使用的系统管理程序</li>
<li>/home：存放普通用户的主目录，目录名以用户账号命名</li>
<li>/root：系统管理员主目录</li>
<li>/lib：系统开机所需要的动态连接共享库</li>
<li>/lost+found：一般是空的，系统非法关机后会存放一些文件</li>
<li>/etc：系统管理所需的<strong>配置文件</strong>(.conf)和子目录</li>
<li>/usr：存放用户的应用程序和文件</li>
<li>/usr/local：给主机额外安装软件所存放的目录，一般通过编译源码方式安装的程序</li>
<li>/opt：给主机额外安装软件所存放的目录</li>
<li>/boot：存放<strong>启动</strong>linux的核心文件</li>
<li>/proc：虚拟目录，是系统内存的映射，访问该目录可获取系统信息</li>
<li>/srv：存放服务启动后需要提取的数据</li>
<li>/sys：该目录安装了文件系统sysfs</li>
<li>/tmp：存放临时文件</li>
<li>/dev：<strong>设备管理器</strong>，把所有硬件用文件形式存储</li>
<li>/media：linux识别U盘、光驱后，把这些<strong>设备挂载</strong>到该目录下</li>
<li>/mnt：该目录可<strong>挂载外部的存储</strong>（临时挂载其他文件系统）</li>
<li>/var：存惯存放经常被修改的目录，包括日志文件</li>
</ul>
<h2 id="远程登陆和文件传输"><a href="#远程登陆和文件传输" class="headerlink" title="远程登陆和文件传输"></a>远程登陆和文件传输</h2><ul>
<li><p>准备工作：下载xshell和xftp</p>
</li>
<li><p>使用<code>ifconfig</code>查看虚拟机ip</p>
</li>
<li><p>cmd ping 以上ip，确保互通</p>
</li>
<li><p>xshell和xftp的操作略，需要时看视频</p>
</li>
</ul>
<h2 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h2><p>常用快捷键（不声明则在标准模式下）：</p>
<ul>
<li><code>yy</code>拷贝当前行，<code>5yy</code>拷贝当前行向下的5行，<code>p</code>粘贴至光标处</li>
<li><code>dd</code>删除当前行，<code>5dd</code>删除当前行向下的5行</li>
<li>查找：<code>/关键字</code>，回车查找，输入<code>n</code>查找下一个</li>
<li>设置行号：<code>:set nu</code>和<code>:set nonu</code></li>
<li><code>G</code>到文档末行，<code>gg</code>到文档首行</li>
<li><code>ctrl+$ </code>：跳转至某行末尾，<code>ctrl+^</code>：跳转至某行开头</li>
<li><code>u</code>撤销</li>
<li>跳转至第五行：<code>5gg</code>或<code>5G</code></li>
</ul>
<p>tips：</p>
<ul>
<li>写文件名到一半，按<code>tab</code>有代码补全功能</li>
</ul>
<h2 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h2><ul>
<li><code>shutdown -h now</code>：立刻关机</li>
<li><code>shutdown -h 1</code>：1分钟后关机</li>
<li><code>shutdown -r now</code>：立刻重启</li>
<li><code>halt</code>：关机（使用该命令后虚拟机只是提示cpu已禁用，还需要在虚拟机里手动关机）</li>
<li><code>reboot</code>：重启</li>
<li><code>sync</code>：把内存数据同步到磁盘</li>
</ul>
<p>tips：</p>
<ul>
<li>最好在关机和重启前执行<code>sync</code>，避免内存数据丢失，尽管关机重启前会默认执行sync，但小心为妙</li>
</ul>
<h2 id="登录注销"><a href="#登录注销" class="headerlink" title="登录注销"></a>登录注销</h2><ul>
<li><p><code>su - 用户名</code>：切换用户，如 su - root 切换到管理员；从权限高的用户切换到权限低的用户，不需要密码，反之需要</p>
</li>
<li><p>shell（运行级别3，在GUI下不可）下输入<code>logout</code>可以注销用户，使用<code>exit</code>登出的效果类似</p>
<p>假设第一次登录的用户是tom，tom使用 su - root 切换到管理员，此时logout，会从管理员变为tom，再logout，会退出系统</p>
</li>
</ul>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="增删用户"><a href="#增删用户" class="headerlink" title="增删用户"></a>增删用户</h3><ul>
<li><code>useradd 用户名</code>：创建用户，并在/home下生成同名文件夹，作为该用户的文件夹</li>
<li><code>useradd -d 指定目录 用户名</code>：把指定目录作为该用户的文件夹</li>
<li><code>passwd 用户名</code>：设置某一用户的密码，<strong>如果不加用户名，设置的是当前登录用户的密码</strong></li>
<li><code>userdel 用户名</code>：删除用户，但保留家目录</li>
<li><code>userdel -r 用户名</code>：删除用户，同时删除家目录</li>
</ul>
<p>tips：</p>
<ul>
<li>删除用户前，最好使用logout退登，再重新登录root，防止删除普通用户时，这个用户还登陆着（如果从普通用户登录，使用su - root登录管理员，那么该普通用户仍保持着登陆状态）</li>
<li>不要轻易删除家目录</li>
</ul>
<h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><ul>
<li><code>id 用户名</code>：查看用户信息</li>
<li><code>whoami/who am i</code>：查看当前第一次登录的用户信息</li>
</ul>
<h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul>
<li><p><code>groupadd 组名</code>：新增组</p>
</li>
<li><p><code>groupdel 组名</code>：删除组</p>
</li>
<li><p><code>useradd -g 用户组 用户名</code>：创建用户，并将其添加至指定用户组</p>
<p>如果直接使用<code>useradd 用户名</code>，会自动创建和该用户同名的组，再把该用户添加至这个组内</p>
</li>
<li><p><code>usermod -g 用户组 用户名</code>：修改用户的组</p>
</li>
<li><p><code>usermod -d 目录 用户名</code>：改变该用户登录的初始目录（该用户必须拥有进入该目录的权限）</p>
</li>
</ul>
<h4 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h4><ol>
<li><p>/etc/passwd</p>
<p>用户的配置文件，记录用户的各种信息</p>
<p>每行的含义：==用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell==</p>
<p>Shell：linux内核是不认识各种指令的，可以认为shell帮助翻译了指令。一般情况下，shell是bash</p>
</li>
<li><p>/etc/shadow</p>
<p>口令的配置文件</p>
<p>每行的含义：==登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志==</p>
</li>
<li><p>/etc/group</p>
<p>组配置文件，记录linux包含的组的信息</p>
<p>每行的含义：==组名:口令:组标识号:组内用户列表==</p>
</li>
</ol>
<h3 id="用户级别"><a href="#用户级别" class="headerlink" title="用户级别"></a>用户级别</h3><p>运行级别说明：</p>
<ul>
<li><p>0：关机</p>
</li>
<li><p>1：单用户（找回丢失密码，视频在下一节，本人跳过）</p>
</li>
<li><p>2：多用户状态，无网络服务</p>
</li>
<li><p><strong>3：多用户状态，有网络服务</strong></p>
</li>
<li><p>4：自定义</p>
</li>
<li><p>5：图形界面</p>
</li>
<li><p>6：重启</p>
</li>
</ul>
<p>指令：</p>
<ul>
<li><p><code>init [0123456]</code>：切换运行级别</p>
<p>init 0可关机，init 6可重启</p>
</li>
<li><p><code>systemctl get-default</code>：查看默认运行级别</p>
</li>
<li><p><code>systemctl set-default target名称</code>：修改默认运行级别</p>
<p>target一般有两种：<code>multi-user.target</code>（级别3）和<code>graphical.target</code></p>
</li>
</ul>
<h2 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h2><ul>
<li><code>man 指令</code>：获得某指令的帮助信息（按<strong>空格</strong>可以直接跳到下一页）</li>
<li><code>help 指令</code>：获得<strong>shell内置命令</strong>的帮助信息</li>
</ul>
<p>tips：</p>
<ul>
<li>linux下，隐藏文件以 . 开头</li>
<li>指令的选项可以组合使用，如ls -al和ls -la /root</li>
</ul>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p><a href="https://www.ruanyifeng.com/blog/2018/09/bash-wildcards.html">https://www.ruanyifeng.com/blog/2018/09/bash-wildcards.html</a></p>
<h3 id="目录增删"><a href="#目录增删" class="headerlink" title="目录增删"></a>目录增删</h3><ul>
<li><code>ls -h</code>：将文件大小以人类可以读懂的方式显示，如433M（不开-h，默认显示字节数）</li>
<li><code>ls -R</code>：递归显示整个目录的内容</li>
<li><code>ll</code>：相当于<code>ls -l</code>，显示详细信息。因此也可以写ll -ah</li>
<li><code>cd ~</code>或<code>cd</code>：回到自己的家目录，比如你是root，那么cd ~到 /root</li>
<li><code>mkdir -p</code>：创建多级目录，如mkdir -p /home/animal/tiger。如果不加-p，linux必须得找到上一级目录才会创建下一级目录，否则会报错</li>
<li><code>cp -r 源目录 目标目录</code>：递归复制整个文件夹，如cp -r /home/bbb /opt（将整个目录拷贝到/opt），如果需要强制覆盖不提示，把cp改为<code>\cp</code></li>
<li><code>rm -r 目录</code>：递归删除整个目录，如果需要强制删除不提示，再加<code>-f</code>选项</li>
</ul>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p>知识补充：</p>
<ul>
<li>管道命令：把前一个命令的结果交给下一个命令处理，类似于命令的组合</li>
</ul>
<ul>
<li><p><code>cat -n 文件名</code>：读文件，带行号。比vm读更安全，因为只能读不能改</p>
</li>
<li><p><code>more 文件名</code>：读文件，并提供了多种交互功能，交互如下：</p>
<ul>
<li>空白：向下翻动一页</li>
<li>q：离开程序</li>
</ul>
</li>
<li><p><code>cat -n 文件名| more</code>：这是一个管道命令，把cat的结果交给more，好处：使用more也可以显示行号</p>
</li>
<li><p><code>less 文件名</code>：交互比more更多，并且<strong>动态读取文本</strong>，而不是一下子把文本全部载入内存，推荐使用</p>
<ul>
<li>PgUp：向上翻动一页</li>
<li>PgDn：向下翻动一页</li>
<li>/字串：向下搜寻【字串】的功能；n：向下查找；N：向上查找（记住它）</li>
<li>?字串：向上搜寻【字串】的功能；n：向上查找；N：向下查找</li>
<li>G：跳转至末尾</li>
<li>g：跳转至开头</li>
</ul>
</li>
<li><p><code>head 文件</code>：查看文件前10行内容，<code>tail</code>查看后10行内容</p>
</li>
<li><p><code>head -n 5 文件</code>：查看文件前5行内容</p>
</li>
</ul>
<h3 id="覆盖追加"><a href="#覆盖追加" class="headerlink" title="覆盖追加"></a>覆盖追加</h3><ul>
<li><p><code>echo 环境变量</code>：查看环境变量，如echo $PATH</p>
</li>
<li><p><code>echo &quot;内容&quot;</code>：将内容打印在屏幕上，如echo “hello”</p>
</li>
<li><p><code>tail -f 文件</code>：实时追踪文档的所有更新</p>
</li>
</ul>
<p>&gt;表示覆盖写，&gt;&gt;表示追加写</p>
<ul>
<li><code>ls -l &gt; 文件</code>：将列表内容写入文件（目标文件不存在就会自动创建，下同）</li>
<li><code>cat 文件1 &gt; 文件2</code>：将文件1的内容覆盖到文件2</li>
<li><code>echo &quot;内容&quot; &gt;&gt; 文件 </code>：将内容追加进文件</li>
<li><code>cal &gt;&gt; 文件</code>：将日历信息追加进文件</li>
</ul>
<p>补充：</p>
<ul>
<li><code>&gt; 文件</code>也可以用于创建文件</li>
<li><code>echo &quot;&quot; &gt; 文件</code>可以用于把文件置空</li>
</ul>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p><code>软链接</code>又称为符号链接，类似于win中的快捷方式，存放了链接其他文件的路径</p>
<ul>
<li><p><code>ln -s 原文件或目录 软链接名</code>：为原文件创建一个软链接</p>
<p>创建好指向某一目录的软链接，并cd进入软链接以后，使用ls，看到的列表 和 在原目录下看到的列表 一致</p>
<p>使用pwd查看目录时，仍然看到的是软链接所在目录</p>
</li>
<li><p><code>rm 软链接名</code>：删除软链接，如rm /home/myroot</p>
</li>
</ul>
<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul>
<li><code>history</code>：显示所有的历史指令</li>
<li><code>history 10</code>：显示最近使用过的10个指令</li>
<li><code>!5</code>：执行历史编号为5的指令</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>批量创建文件：<code>touch file&#123;0..9&#125;.txt</code></li>
<li>批量删除文件：<code>rm -f file&#123;0..9&#125;.txt</code></li>
<li>批量创建文件夹：<code>mkdir dir&#123;0..9&#125;</code></li>
<li>批量删除文件夹：<code>rmdir dir&#123;0..9&#125;</code>或者<code>rm -rf dir&#123;0..9&#125;</code></li>
</ul>
<h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><p>字母注意大小写：</p>
<ul>
<li><p><code>date</code>：显示当前时间</p>
</li>
<li><p><code>date +%Y </code>：显示当前年份</p>
</li>
<li><p><code>date +%m</code>：月份</p>
</li>
<li><p><code>date +%d</code>：天</p>
</li>
<li><p><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月日时分秒</p>
<p>引号内除第一个加号必需，后面的-和空格只是起修改格式的作用，可以任意修改</p>
</li>
</ul>
<h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><ul>
<li><p><code>find 搜索范围 选项</code>： 从指定目录向下递归地遍历各个子目录，将满足条件的文件或目录显示在终端</p>
<ul>
<li>-name 按指定文件名查找</li>
<li>-user 查找属于某一用户名的所有文件</li>
<li>-size 按照大小查找，+n大于，-n小于，n等于，如<code>find / -size +200M</code></li>
<li>查找一类文件，使用通配符，如查找某一目录下全部.txt文件：<code>find *.txt</code></li>
</ul>
<p>可以组合使用 | less，避免显示内容过长不便于阅读</p>
</li>
<li><p><code>locate 文件名</code>：快速定位文件路径</p>
<p>locate指令利用事先建立的==系统中所有文件名称及路径的locate数据库==实现快速定位给定的文件，无需遍历整个文件系统</p>
<p>使用locate之前，先使用<code>updatedb</code>更新locate数据库</p>
</li>
<li><p><code>which 指令名</code>：查看指令所在的目录</p>
</li>
<li><p><code>grep 选项 查找内容 文件名</code>：筛选文件的特定内容</p>
<ul>
<li>-n：显示匹配行及行号</li>
<li>-i：忽略字母大小写</li>
<li>-v：反向匹配</li>
</ul>
<p>可以直接用grep，也可以用管道指令，如==grep -n “yes” hello.txt== 等价于 ==cat hello.txt | grep “yes”==</p>
</li>
</ul>
<h2 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h2><ul>
<li><p><code>gzip 文件</code>：将文件压缩为*.gz文件（将原本的文件变为压缩文件，而不是新生成压缩文件）</p>
</li>
<li><p><code>gunzip 压缩文件</code>：解压缩</p>
</li>
<li><p><code>zip 选项 压缩后的文件名 目录或文件 </code>：压缩文件，选项-r表示递归压缩</p>
<p>在“压缩后的文件名”处还可以提供压缩后文件所在的目录</p>
<p>如zip -r /opt/myhome.zip /home，表示将home目录及其包含的文件和子目录都压缩为/opt目录下的myhome.zip文件，同时原目录/文件被保留，相当于新生成了压缩文件</p>
</li>
<li><p><code>unzip 压缩文件</code>：解压缩</p>
<ul>
<li><code>unzip -d 目录 压缩文件</code>：指定压缩文件解压缩到某个目录下，如unzip -d /tmp /home/myhome.zip，表示将该压缩文件解压到/tmp目录下</li>
</ul>
</li>
<li><p><code>tar 选项 xxx.tar.gz 打包的内容</code>：打包目录，压缩后的文件格式.tar.gz</p>
<p>选项：</p>
<ul>
<li>-c：产生.tar打包文件</li>
<li>-v：显示详细信息</li>
<li>-f：指定压缩后的文件名</li>
<li>-z：打包同时压缩</li>
<li>-x：解包.tar文件</li>
<li>-C：解压到的位置</li>
</ul>
<p>案例：</p>
<ul>
<li>==tar -zcvf test.tar.gz a.txt b.txt==：压缩多个文件（空格分隔文件名）</li>
<li>==tar -zcvf test.tar.gz /dir==：压缩某个目录</li>
<li>==tar -zxvf test.tar.gz==：解压到当前目录</li>
<li>==tar -zxvf test.tar.gz -C /opt==：解压到/opt目录下</li>
</ul>
</li>
</ul>
<h2 id="linux组"><a href="#linux组" class="headerlink" title="linux组"></a>linux组</h2><h3 id="修改所有者和所在组"><a href="#修改所有者和所在组" class="headerlink" title="修改所有者和所在组"></a>修改所有者和所在组</h3><p>linux中的<strong>每个文件</strong>有所有者、所在组、其它组的概念</p>
<ul>
<li><code>chown 用户名 文件名</code>：修改文件/目录的所有者</li>
<li><code>chown 用户名:组名 文件/目录</code>：同时修改文件/目录的所有者和所在组</li>
<li><code>chgrp 组名 文件名</code>：修改文件/目录所在的组</li>
<li><code>-R</code>：添加这个选项后，如果是目录，其下所有子文件或目录递归生效</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>ls -l后，会看到很多信息，如：==-rwxrw-r– 1 root root 1213 Feb 2 09:39 abc==</p>
<p>0-9位说明：</p>
<ul>
<li>第0位确定文件类型：<ul>
<li>-：普通文件</li>
<li>d：目录</li>
<li>l：软链接</li>
<li>c：字符设备文件，如鼠标、键盘</li>
<li>b：块设备文件，如键盘</li>
</ul>
</li>
<li>第1-3位确定所有者的权限，第4-6位确定所属组的权限，第7-9位确定其他用户的权限</li>
</ul>
<p>rwx权限：</p>
<ul>
<li>到文件：<ul>
<li>r：可读取、查看</li>
<li>w：可修改，但不代表可以删除文件，删除文件的前提条件是<strong>用户对文件所在的目录有写权限</strong></li>
<li>x：可执行</li>
</ul>
</li>
<li>到目录：<ul>
<li>r：可以用ls查看目录内容</li>
<li>w：可在目录内创建和删除（也可以删除目录），可以重命名目录</li>
<li>x：可以进入目录</li>
</ul>
</li>
</ul>
<p>其他说明：</p>
<ul>
<li>1：如果只有一个文件，则该数为1；如果是目录，该数 = 子目录数 + 目录下文件数（只用找一层）</li>
</ul>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>第一种方式：u：所有者，g：所属组，o：其它组，a：所有人</p>
<ul>
<li><code>chmod u=rwx,g=rx,o=x 文件/目录名</code>：设置权限</li>
<li><code>chmod o+w o+w 文件/目录名</code>：增加权限</li>
<li><code>chmod a-x 文件/目录名</code>：减少权限</li>
</ul>
<p>第二种方式：r=4，w=2，x=1</p>
<ul>
<li><code>chmod 751 文件/目录名</code>等价于上方的第一条</li>
</ul>
<h1 id="实操篇"><a href="#实操篇" class="headerlink" title="实操篇"></a>实操篇</h1><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="crontab-任务调度"><a href="#crontab-任务调度" class="headerlink" title="crontab 任务调度"></a>crontab 任务调度</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>任务调度：指系统在某个时间执行的特定的命令或程序</p>
<p>分类：</p>
<ul>
<li>系统工作：有些重要的工作必须周而复始地进行，如病毒扫描等</li>
<li>个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份（也可以只是执行一条简单指令）</li>
</ul>
<p>指令：</p>
<ul>
<li><code>crontab 选项</code>：<ul>
<li>-e：编辑crontab定时任务</li>
<li>-l：查询crontab任务（列出当前有哪些任务调度）</li>
<li>-r：删除当前用户所有的crontab任务（终止任务调度）</li>
</ul>
</li>
<li><code>service crond restart</code>：重启任务调度</li>
</ul>
<p>操作：</p>
<ul>
<li>设置任务调度：crontab -e</li>
<li>输入任务到调度文件，如：==*/1 * * * * ls -l /etc &gt; /tmp/to.txt==，意思是每分钟执行ls -l /etc…这个指令</li>
</ul>
<p>5个占位符的说明：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个 *</td>
<td>一小时中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个 *</td>
<td>一天中的第几小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个 *</td>
<td>一个月中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个 *</td>
<td>一年中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个 *</td>
<td>一周中的星期几</td>
<td>0-7（0和7代表星期日）</td>
</tr>
</tbody></table>
<blockquote>
<p>星期几和几号最好不要同时出现，容易使人混乱</p>
</blockquote>
<p>特殊符号的说明：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间</td>
</tr>
<tr>
<td>,</td>
<td>代表不连续的时间，如”0 8,12,16 * * *”命令，表示在每天8:00，12:00，16:00都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续的时间，如”0 5 * * 1-6”命令，表示在周一到周六的凌晨5点执行命令</td>
</tr>
<tr>
<td>*/n</td>
<td>代表每隔多久执行一次，如”*/10 * * * *”命令，表示每隔10分钟就执行一次命令</td>
</tr>
</tbody></table>
<h4 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h4><p>将命令写入脚本，通过执行脚本来执行命令：</p>
<ol>
<li><code>vim xxx.sh</code> 写入内容，如 date &gt;&gt; /home/mycal 和 cal &gt;&gt; /home/mycal</li>
<li>给xxx.sh增加执行权限，<code>chmod u+x xxx.sh</code></li>
<li><code>crontab -e</code>增加 ==*/1 * * * * xxx.sh==</li>
</ol>
<h3 id="at-定时任务"><a href="#at-定时任务" class="headerlink" title="at 定时任务"></a>at 定时任务</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>简介：</p>
<ul>
<li>at命令是<strong>一次性定时计划任务</strong>，at的守护进程atd会以后台模式运行，检查作业队列来运行</li>
<li>默认情况下，atd守护进程每60s检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业</li>
<li>at命令执行完一个任务后，以后不再执行此任务</li>
<li>使用at命令时需要保证atd进程的启动，可以使用<code>ps -ef | grep atd</code>来检测atd是否在运行（ps -ef 用于检测当前运行的所有进程）</li>
</ul>
<p>at命令格式：</p>
<ul>
<li><code>at 选项 时间</code>：添加at任务</li>
<li><code>atq</code>：查看系统中没有执行的工作任务</li>
<li><code>atrm 编号</code>：从队列中删除指定编号的任务</li>
</ul>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-m</td>
<td>当指定的任务被完成后，将给用户发送邮件，即使没有标准输出</td>
</tr>
<tr>
<td>-I</td>
<td>atq的别名</td>
</tr>
<tr>
<td>-d</td>
<td>atrm的别名</td>
</tr>
<tr>
<td>-v</td>
<td>显示任务将被执行的时间</td>
</tr>
<tr>
<td>-c</td>
<td>打印任务的内容到标准输出</td>
</tr>
<tr>
<td>-V</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-q &lt;队列&gt;</td>
<td>使用指定队列</td>
</tr>
<tr>
<td>-f &lt;文件&gt;</td>
<td>从指定文件读入任务，而不是从标准输入读入</td>
</tr>
<tr>
<td>-t &lt;时间参数&gt;</td>
<td>以时间参数的形式提交要运行的任务</td>
</tr>
</tbody></table>
<p>at时间定义：</p>
<img src="https://z3.ax1x.com/2021/08/29/h8QD2t.png" style="zoom: 80%;">

<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>输入at指令开始编辑后，退出时，按两次<code>ctrl + D</code></p>
<ul>
<li><p>案例1：2天后的下午5点执行 ls /home：</p>
<p>at 5pm +2days</p>
<p>ls /home</p>
</li>
<li><p>案例2：2分钟后，输出时间到指定文件内：</p>
<p>at now +2minutes</p>
<p>date &gt; /root/date.log</p>
</li>
</ul>
<h2 id="磁盘分区与挂载"><a href="#磁盘分区与挂载" class="headerlink" title="磁盘分区与挂载"></a>磁盘分区与挂载</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每块硬盘有多个分区，而linux系统中有多个目录，所谓“挂载”，就是把一个分区和一个目录联系起来</p>
<p>真正存放数据的是分区，比如在下图中，如果在/home下创建文件，就会把该文件存入分区1</p>
<img src="https://z3.ax1x.com/2021/08/29/h83RaD.png" style="zoom:80%;">

<p>硬盘说明：</p>
<ul>
<li>linux硬盘分为<code>IDE硬盘</code>和<code>SCSI硬盘</code>，目前以后者为主</li>
<li>IDE硬盘的标识为”hdx~“，SCSI硬盘的标识为”sdx~“</li>
<li>x为盘号，a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘（或简单理解为第一个盘、第二个盘…）</li>
<li>~代表分区，前四个分区用1到4表示，它们是主分区或拓展分区。从5开始是逻辑分区</li>
</ul>
<p>指令：</p>
<ul>
<li><code>lsblk</code>：查看设备挂载情况</li>
<li><code>lsblk -f</code>：信息更详细，显示磁盘每个分区对应的40位唯一标识符（当且仅当分区格式化后，才会生成该UUID）</li>
</ul>
<h3 id="增加磁盘实例"><a href="#增加磁盘实例" class="headerlink" title="增加磁盘实例"></a>增加磁盘实例</h3><p>步骤：虚拟机添加硬盘→分区→格式化→挂载→设置可以自动挂载</p>
<ul>
<li><p>虚拟机添加硬盘：vmware内操作，设置→添加硬盘→一路下一步</p>
<p>reboot 重启系统才能识别新的硬盘</p>
</li>
<li><p>分区：</p>
<ul>
<li><p><code>fdisk /dev/sdb</code>开始对/sdb 分区，具体操作：</p>
<ol>
<li><p>开始分区后输入n，新增分区</p>
</li>
<li><p>然后选择p，分区类型为主分区</p>
</li>
<li><p>两次回车，默认剩余全部空间</p>
</li>
<li><p>输入w</p>
</li>
</ol>
<p>m：显示命令列表</p>
<p>p：显示磁盘分区，同 <code>fdisk -l</code></p>
<p>n：新增分区</p>
<p>d：删除分区</p>
<p>w：写入并退出</p>
<p>q：不保存退出</p>
</li>
</ul>
</li>
<li><p>格式化磁盘：</p>
<ul>
<li><code>mkfs -t ext4 /dev/stb1</code>：格式化命令，其中ext4是分区类型</li>
</ul>
</li>
<li><p>挂载：</p>
<ul>
<li><code>mount 设备名称 挂载目录</code>：如 mount /dev/sdb1 /newdisk</li>
<li><code>umount 设备名称/挂载目录</code>：卸载命令，如 umount /dev/sdb1 或 umount /newdisk</li>
<li>注意：用命令行挂载，<strong>重启后会失效</strong></li>
</ul>
</li>
<li><p>设置自动挂载：修改/etc/fstab，添加完成后，执行mount -a即刻生效（重启也可生效）</p>
<p>最前面的UUID也可以填写设备名称，如/dev/sdb1，最后两个参数写 0 0（目前不懂）</p>
</li>
</ul>
<h3 id="取消挂载的情况"><a href="#取消挂载的情况" class="headerlink" title="取消挂载的情况"></a>取消挂载的情况</h3><p>情景：当取消挂载后，原文件夹里的文件访问不到了，如何解决？</p>
<p>比如说，先创建了dir1，把/dev/sdb1 挂载到dir1上，并在dir1内创建了几个文件。现在取消挂载，再进入dir1，发现找不到这些文件了。</p>
<p>做法：再创建dir2，把/dev/sdb1 挂载到dir2上，就能找回那些文件了</p>
<h3 id="转移硬盘的情况"><a href="#转移硬盘的情况" class="headerlink" title="转移硬盘的情况"></a>转移硬盘的情况</h3><p>（以下内容是自己总结的，未必准确，以后可能修改）</p>
<p>情景：/dev/sdb1此时挂载在dir上，现在我们想让/dev/sdb2挂载到dir上</p>
<p>做法：</p>
<ul>
<li>创建新的目录/new，使用<code>mv /dir/* /new</code>将dir中的内容剪切过去</li>
<li>取消挂载</li>
<li>将另一块硬盘挂载到/new目录下</li>
</ul>
<h3 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h3><ul>
<li><p><code>df -h</code>：查询系统整体磁盘使用情况</p>
</li>
<li><p><code>du -h</code>：查询指定目录的磁盘占用情况，默认为当前目录</p>
<p>选项：</p>
<ul>
<li>-h：带计量单位</li>
<li>-a：带文件，而不仅是子目录</li>
<li>–max-depth=1：子目录深度</li>
<li>-c：列出明细的同时，增加汇总值</li>
</ul>
<p>应用：==du -hac –max-depth=1 /opt==可查询/opt目录的磁盘占用情况，深度为1</p>
</li>
</ul>
<h3 id="磁盘实用指令"><a href="#磁盘实用指令" class="headerlink" title="磁盘实用指令"></a>磁盘实用指令</h3><p>grep可以接收一个正则表达式，以下指令如果不加 wc -l，则页面上只显示文件/文件夹：</p>
<ol>
<li><code>ls -l /opt | grep &quot;^-&quot; | wc -l</code>：统计/opt目录下文件的个数</li>
<li><code>ls -l /opt | grep &quot;^d&quot; | wc -l</code>：统计/opt目录下一级子目录的个数</li>
<li><code>ls -lR /opt | grep &quot;^-&quot; | wc -l</code>：统计/opt目录下全部文件的个数，包括子目录里的</li>
<li><code>ls -lR /opt | grep &quot;^d&quot; | wc -l</code>：统计/opt目录下全部目录的个数，包括子目录里的</li>
<li><code>tree 目录</code>：以树状显示目录结构，需要先<code>yum install tree</code>按照tree指令</li>
</ol>
<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>NAT网络配置原理图：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGeMJx.png" style="zoom:80%;">

<p>可见，linux虚拟机和vmnet8的ip地址是一样的</p>
<p>指令：</p>
<ul>
<li><code>ipconfig</code>：查看windows的网络配置</li>
<li><code>ifconfig</code>：查看linux的网络配置</li>
<li><code>ping 目的主机</code>：测试当前服务器是否可以连接目的主机</li>
</ul>
<h3 id="配置静态ip"><a href="#配置静态ip" class="headerlink" title="配置静态ip"></a>配置静态ip</h3><p>默认情况下，linux的ip是自动获取的，每次获取的ip地址可能不一样，因此我们需要指定ip</p>
<p>指定ip的方法：<code>vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从DHCP修改为static</span></span><br><span class="line">BOOTPROTO=&quot;static&quot; </span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;49034b55-e0a4-4493-a105-50ab889139ad&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">IP地址</span></span><br><span class="line">IPADDR=192.168.200.130</span><br><span class="line"><span class="meta">#</span><span class="bash">网关</span></span><br><span class="line">GATEWAY=192.168.200.2</span><br><span class="line"><span class="meta">#</span><span class="bash">域名解析器</span></span><br><span class="line">DNS1=192.168.200.2</span><br></pre></td></tr></table></figure>

<p>修改后，使用<code>service network restart</code>或<code>reboot</code>生效</p>
<p>同时，还要修改vmware中虚拟网络编辑器中的ip，和xshell的属性（见视频）</p>
<h3 id="主机名和hosts映射"><a href="#主机名和hosts映射" class="headerlink" title="主机名和hosts映射"></a>主机名和hosts映射</h3><p>Hosts：一个文本文件，用来记录IP和Hostname（主机名）的映射关系</p>
<h4 id="设置主机名"><a href="#设置主机名" class="headerlink" title="设置主机名"></a>设置主机名</h4><ul>
<li><code>hostname</code>：查看主机名</li>
<li><code>vi /etc/hostname</code>：指定主机名</li>
<li>重启生效</li>
</ul>
<h4 id="设置hosts映射"><a href="#设置hosts映射" class="headerlink" title="设置hosts映射"></a>设置hosts映射</h4><p>windows→linux：在C:\Windows\System32\drivers\etc\hosts 文件指定即可，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">192.168.200.130 centos7.6</span><br></pre></td></tr></table></figure>

<p>linux→windows：在/etc/hosts 文件指定，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.200.1 win10</span><br></pre></td></tr></table></figure>



<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>在linux中，每个执行的程序都称为一个进程，每一个进程都分配一个pid（进程号）</p>
<p>每个进程都可能以<strong>前台</strong>和<strong>后台</strong>两种方式存在，前台是用户目前的屏幕上可以操作的进程，后台是实际在操作，但屏幕上无法看到的进程</p>
<p>一般系统发服务通常以后台进程的方式存在，常驻系统中，直到关机才结束</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>ps：用于查看目前系统中的进程状况</p>
<p>选项：</p>
<ul>
<li>-a：显示<strong>当前终端</strong>的所有进程信息（不是所有进程）</li>
<li>-u：以用户的格式显示进程信息</li>
<li>-x：显示后台进程运行的参数</li>
<li>-e：显示所有进程</li>
<li>-f：全格式</li>
</ul>
<p>查看有无特定服务：<code>ps -aux | grep xxx</code>，比如查看有无sshd服务</p>
<h4 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps -aux"></a>ps -aux</h4><p>使用ps -aux：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGtEZt.png" style="zoom:80%;">



<table>
<thead>
<tr>
<th>USER</th>
<th>PID</th>
<th>%CPU</th>
<th>%MEM</th>
<th>VSZ</th>
<th>RSS</th>
<th>TTY</th>
<th>STAT</th>
<th>START</th>
<th>TIME</th>
<th>COMMAND</th>
</tr>
</thead>
<tbody><tr>
<td>用户名称</td>
<td>进程号</td>
<td>占用CPU百分比</td>
<td>占物理内存百分比</td>
<td>占用虚拟内存大小(KB)</td>
<td>占用物理内存大小(KB)</td>
<td>终端名称(缩写，因此显示?)</td>
<td>进程状态</td>
<td>启动时间</td>
<td>使用CPU的时间</td>
<td>启动进程所用的命令和参数(太长会截断显示)</td>
</tr>
</tbody></table>
<p>关于进程状态STAT：</p>
<ul>
<li>S：睡眠</li>
<li>s：表示该进程是会话的先导进程</li>
<li>N：表示进程比普通优先级更低的优先级</li>
<li>R：正在运行</li>
<li>D：短期等待</li>
<li>Z：僵尸进程</li>
<li>T：被跟踪或被停止</li>
</ul>
<h4 id="ps-ef-与父子进程"><a href="#ps-ef-与父子进程" class="headerlink" title="ps -ef 与父子进程"></a>ps -ef 与父子进程</h4><p><code>ps -ef</code>：以全格式显示当前所有的进程</p>
<img src="https://z3.ax1x.com/2021/08/29/hGawQg.png" style="zoom:80%;">

<table>
<thead>
<tr>
<th>UID</th>
<th>PID</th>
<th>PPID</th>
<th>C</th>
<th>STIME</th>
<th>TTY</th>
<th>TIME</th>
<th>CMD</th>
</tr>
</thead>
<tbody><tr>
<td>用户名称</td>
<td>进程号</td>
<td><strong>父进程ID</strong></td>
<td>见下方</td>
<td>进程启动的时间</td>
<td>终端名称</td>
<td>使用CPU的时间</td>
<td>启动进程所用的命令和参数</td>
</tr>
</tbody></table>
<p>C：CPU用于计算执行优先级的因子。数值越大，表明进程是CPU密集型运算，优先级降低；数值越小，表面进程是I/O密集型运算，优先级升高</p>
<p>父子进程：进程存在父子关系，先有父进程，再由父进程创建子进程，如图所示为sshd（远程登陆服务）的相关进程：</p>
<img src="https://z3.ax1x.com/2021/08/29/hGaUW8.png" style="zoom:80%;">

<h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><p>指令：</p>
<ul>
<li><p><code>kill [选项] 进程号</code>：通过进程号杀死/终止进程；-9选项 表示强迫进程立即停止</p>
</li>
<li><p><code>killall [选项] 进程名称</code>：通过进程名杀死进程；同时，杀死父进程时也会杀死它的子进程；支持通配符</p>
</li>
<li><p><code>pkill [选项] 进程名称</code>：和killall类似，杀死指定名字的所有进程</p>
</li>
</ul>
<p>最佳实践：</p>
<ul>
<li><p>踢掉某个非法登录用户：<code>kill 进程号</code>（查看sshd进程，找到进程号）</p>
</li>
<li><p>终止远程登录服务sshd，在适当的时候再次重启sshd服务：</p>
<p><code>kill sshd 进程号</code></p>
<p>重启：<code>/bin/systemctl start sshd.service</code></p>
</li>
<li><p>终止多个gedit（文本编辑器）：<code>killall gedit</code></p>
</li>
<li><p>强制杀死一个终端：<code>kill -9 bash的进程号</code></p>
</li>
</ul>
<h3 id="查看进程树"><a href="#查看进程树" class="headerlink" title="查看进程树"></a>查看进程树</h3><p><code>pstree 选项</code>可以直观查看进程信息</p>
<p>选项：</p>
<ul>
<li>-p：显示进程的PID</li>
<li>-u：显示进程的所属用户</li>
</ul>
<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><p>top指令和ps类似，不同之处是它在执行一段时间后可以更新正在运行的进程</p>
<p><code>top -d 秒数</code>：指定top每隔几秒更新，默认3秒</p>
<p>其他选项：</p>
<ul>
<li>-i：使top不显示任何闲置或僵尸进程</li>
<li>-p：通过指定监控进程ID，来仅仅监控某个进程的状态</li>
</ul>
<p>交互操作：</p>
<ul>
<li>P：以CPU使用率排序，默认就是此项</li>
<li>M：以内存使用率排序</li>
<li>N：以PID排序</li>
<li>q：退出topt</li>
</ul>
<p>应用实例：</p>
<ul>
<li>监视特定用户：top → u →输入用户名</li>
<li>终止指定进程，如结束tom登录：top → k → 要结束进程的ID号</li>
</ul>
<h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>netstat指令：</p>
<ul>
<li><code>netstat [选项]</code><ul>
<li>-an：按一定顺序排列输出</li>
<li>-p：显示哪个进程在调用</li>
</ul>
</li>
</ul>
<p>如：<code>netstat -anp | grep sshd</code>可查看sshd服务的信息</p>
<p>netstat -anp：</p>
<p>Local Address指本机地址，Foreign Address指和本机某端口建立通信的外部地址</p>
<img src="https://z3.ax1x.com/2021/08/30/hJRQJg.png" style="zoom: 80%;">

<p>两个端口建立通信的示意图：</p>
<img src="https://z3.ax1x.com/2021/08/30/hJ2Fuq.png" style="zoom:80%;">

<h3 id="端口占用情况"><a href="#端口占用情况" class="headerlink" title="端口占用情况"></a>端口占用情况</h3><p>命令：<code>lsof -i:port</code>，port为端口号</p>
<img src="https://z3.ax1x.com/2021/09/13/4Pu0Gd.png" style="zoom:80%;">

<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><blockquote>
<p>守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。 很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。 另一些只在需要的时候才启动，完成任务后就自动结束。</p>
</blockquote>
<p>后台程序 ~ 服务 ~ 守护进程 </p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>service管理指令：</p>
<ul>
<li><code>service 服务名 [start|stop|restart|reload|status]</code></li>
<li>在centos7.0后，很多服务不再使用service，而是使用systemctl</li>
<li>service指令管理的服务在<code>/etc/init.d</code>查看</li>
</ul>
<p>查看服务名：</p>
<ul>
<li><code>setup</code>：查看全部系统服务</li>
</ul>
<h3 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h3><p>chkconfig指令：可以给服务的各个运行级别设置自启动/关闭（在centos7.0后，很多服务使用systemctl，管理的服务在<code>/etc/init.d</code>查看）</p>
<ul>
<li><p><code>chkconfig --list [|grep xxx]</code>：查看全部服务</p>
</li>
<li><p><code>chkconfig 服务名 --list</code>：查看某项服务</p>
</li>
<li><p><code>chkconfig --level 数字 服务名 on/off</code>：对服务的各个运行级别设置自启动/关闭，需要重启生效</p>
<p>如：chkconfig –level 3 network off</p>
</li>
</ul>
<h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><p>systemctl管理指令：它管理的服务在<code>/usr/lib/systemd/system</code>查看</p>
<ul>
<li><code>systemctl [start|stop|restart|status] 服务名</code>：如果选择stop，只是临时关闭服务，下次启动还看is-enabled</li>
<li><code>systemctl list-unit-files [|grep 服务名]</code>：查看服务开机启动状态</li>
<li><code>systemctl enable 服务名</code>：设置服务（在3和5级别下）开机启动</li>
<li><code>systemctl disable 服务名</code>：关闭服务（在3和5级别下）开机启动</li>
<li><code>systemctl is-enabled 服务名</code>：查询某个服务是否是自启动的</li>
</ul>
<h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h3><p>防火墙：外界想要访问服务器ip（比如192.168.200.130）下的某个端口（如111），要先经过防火墙。防火墙将一些端口开放，将一些端口关闭，如果外界访问了关闭的端口，则访问失败</p>
<p>比如防火墙未开放111端口，此时在windows <code>telnet 192.168.200.130 111</code>会失败 </p>
<p>防火墙指令：</p>
<p>输入<code>netstat -anp | more</code>，最前面一列可以看到端口对应的协议</p>
<ul>
<li><code>firewall-cmd --permanent --add-port=端口号/协议</code>：打开端口</li>
<li><code>firewall-cmd --permanent --remove-port=端口号/协议</code>：关闭端口</li>
<li><code>firewall-cmd --reload</code>：重新载入，使上方指令生效</li>
<li><code>firewall-cmd --query-port=端口/协议</code>：查询端口是否开放</li>
</ul>
<h2 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h2><p>rpm类似于windows下的setup，是一个安装程序</p>
<p>rpm包名的基本格式：</p>
<img src="https://z3.ax1x.com/2021/08/30/hJ4NjJ.png" style="zoom: 80%;">

<p>指令：</p>
<ul>
<li><code>rpm -qa</code>：查询已安装的所有rpm软件包，一般使用 | grep xxx 过滤，如rpm -qa | grep firefox</li>
<li><code>rpm -q 软件包名</code>：查询软件包是否安装，如 rpm -q firefox</li>
<li><code>rpm -qi 软件包名</code>：查询软件包详细信息</li>
<li><code>rpm -ql 软件包名</code>：查询软件包中的文件</li>
<li><code>rpm -qf 文件全路径名</code>：查询文件所属的软件包，如 rpm -qf /etc/passwd，rpm -qf /root/install.log</li>
<li><code>rpm -e 软件包名</code>：卸载rpm包，如rpm -e firefox，会将火狐卸载<ul>
<li>–nodeps：无视依赖提醒，强制删除</li>
</ul>
</li>
<li><code>rpm -ivh RPM包全路径名称</code>：安装rpm包<ul>
<li>-i：安装</li>
<li>-v：提示</li>
<li>-h：进度条</li>
</ul>
</li>
</ul>
<p>删除并安装火狐的全过程：</p>
<ol>
<li><p>rpm -e firefox，卸载火狐</p>
</li>
<li><p>进入桌面上的CentOS 7 x86_64，搜索出firefox的rpm包</p>
<img src="https://z3.ax1x.com/2021/08/30/hJoCnJ.png" style="zoom: 80%;"></li>
<li><p>为了方便操作，将其复制到/opt下</p>
</li>
<li><p>执行rpm -ivh /opt/firefox</p>
</li>
</ol>
<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>yum是一个shell前端软件包管理器，基于rpm包管理，能够从指定的服务器自动下载rpm包并安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包</p>
<p>指令：</p>
<ul>
<li><code>yum list | grep 软件名</code>：查询yum服务器是否有需要安装的软件</li>
<li><code>yum install 软件名</code>：下载安装</li>
</ul>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell是一个<strong>命令行解释器</strong>，它为用户提供了一个向linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动、挂起、停止甚至是编写一些程序</p>
<h3 id="执行shell脚本"><a href="#执行shell脚本" class="headerlink" title="执行shell脚本"></a>执行shell脚本</h3><p>要求：</p>
<ol>
<li>脚本以 #!/bin/bash 开头</li>
<li>如果不用sh，脚本需要有可执行权限</li>
</ol>
<p>脚本内容示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>执行方式：</p>
<ol>
<li>首先赋予脚本+x权限，再输入脚本路径</li>
<li>不需要+x权限，直接<code>sh 脚本路径</code></li>
</ol>
<h3 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h3><p>shell的变量分为：系统变量和自定义变量</p>
<p>系统变量包括：$HOME、$PWD、$SHELL、$PATH、$USER等，可以 echo $HOME</p>
<p><code>set</code>指令可以显示当前shell中的所有变量</p>
<p>shell变量的定义：</p>
<p>基本语法：</p>
<ul>
<li>定义变量：<code>变量名=值</code>（等号两边无空格）</li>
<li>撤销变量：<code>unset 变量名</code></li>
<li>声明静态变量：<code>readonly 变量名</code>，静态变量不能unset</li>
<li>A=`命令`（反引号）：运行里边的命令，并把结果返回给变量A</li>
<li>A=$(命令)与上边等价</li>
</ul>
<p>定义变量的规则：</p>
<ul>
<li>规范：变量名为大写</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line">A=100</span><br><span class="line"><span class="meta">#</span><span class="bash">输出变量需要加$，不加当字符串处理</span></span><br><span class="line"><span class="meta">#</span><span class="bash">双引号可加可不加</span></span><br><span class="line">echo A=$A</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line"></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">unset</span> B 报错</span></span><br><span class="line">C=`date`</span><br><span class="line">D=$(date)</span><br><span class="line">echo C=$C</span><br><span class="line">echo D=$D</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">多行注释</span></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">D=1</span><br><span class="line">E=2</span><br><span class="line">F=3</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>现有一个变量，想要在多个脚本中使用，为了避免对其重复定义，应设置为环境变量</p>
<p>基本语法：</p>
<ul>
<li><code>export 变量名=变量值</code>：将shell变量输出为环境变量/全局变量</li>
<li><code>source 配置文件</code>：让修改后的配置信息立即生效</li>
<li><code>echo $变量名</code>：查询环境变量的值</li>
</ul>
<p>实践：</p>
<ol>
<li><p>在/etc/profile文件中定义MY_TEST 环境变量</p>
<p>在行尾添加：export MY_TEST=/opt/test</p>
</li>
<li><p>source /etc/profile 刷新</p>
</li>
<li><p>echo $MY_TEST，输出/opt/test，环境变量设置成功</p>
</li>
</ol>
<h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><p>用于获取命令行的参数信息</p>
<p>基本语法：</p>
<ul>
<li><p><code>$n</code>：n为数字，$0代表命令本身，$1到$9代表第一到第九个参数，十以上的参数需要用括号包含，如${10}</p>
</li>
<li><p><code>$*</code>：该变量代表命令行中所有的参数，$*把所有的参数看作一个整体</p>
</li>
<li><p><code>$@</code>：也代表命令行中所有的参数，但$@会把每个参数区分对待（两者的区别见for循环部分）</p>
</li>
<li><p><code>$#</code>：代表命令行中所有参数的个数</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo 0=$0 1=$1 2=$2</span><br><span class="line">echo 所有的参数=$*</span><br><span class="line">echo $@</span><br><span class="line">echo 参数的个数=$#</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYlI8H.png" style="zoom:80%;">



<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>shell设计者事先已经定义好的变量，可以直接在shell脚本中使用</p>
<ul>
<li><p><code>$$</code>：当前进程的进程号</p>
</li>
<li><p><code>$!</code>：后台运行的最后一个进程的进程号</p>
</li>
<li><p><code>$?</code>：最后一次执行的命令的返回状态</p>
<p>如果值为0，说明正确执行；反之不正确</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo 当前执行的进程id=$$</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">以后台的方式运行一个脚本（最后带&amp;），并获取它的进程号</span></span><br><span class="line">sh /opt/test/a.sh &amp;</span><br><span class="line"></span><br><span class="line">echo 最后一个后台方式运行的进程id=$!</span><br><span class="line">echo 执行的结果是$?</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYG7Y8.png" style="zoom:80%;">



<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>三种方式，只记录前两种：</p>
<ul>
<li><code>$((运算式))</code>：不推荐</li>
<li><code>$[运算式]</code>：推荐</li>
</ul>
<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：计算(2+3)*4</span></span><br><span class="line"></span><br><span class="line">RES1=$(((2+3)*4))</span><br><span class="line">echo res1=$RES1</span><br><span class="line"></span><br><span class="line">RES2=$[(2+3)*4]</span><br><span class="line">echo res2=$RES2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：求出命令行两个参数的和 20 50</span></span><br><span class="line">SUM=$[$1+$2]</span><br><span class="line">echo sum=$SUM</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYt4m9.png" style="zoom:80%;">



<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>基本语法：<code>[ condition ]</code>，注意空格</p>
<p><code>[ ]</code>为假，<code>[ xxx ]</code>为真（任意字符串）</p>
<p>常用判断条件：</p>
<ul>
<li>=：字符串比较</li>
<li>整数比较：<ul>
<li>-lt：小于</li>
<li>-le：小于等于</li>
<li>-eq：等于</li>
<li>-gt：大于</li>
<li>-ge：大于等于</li>
<li>-ne：不等于</li>
</ul>
</li>
<li>按照文件权限进行判断：<ul>
<li>-r：有读的权限</li>
<li>-w：有写的权限</li>
<li>-x：有执行的权限</li>
</ul>
</li>
<li>按文件类型进行判断：<ul>
<li>-f：文件存在并且是一个常规的文件</li>
<li>-e：文件存在</li>
<li>-d：文件存在并且是一个目录</li>
</ul>
</li>
</ul>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if，elif，else"><a href="#if，elif，else" class="headerlink" title="if，elif，else"></a>if，elif，else</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">    代码</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">    代码</span><br><span class="line">else</span><br><span class="line">    代码</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：<span class="string">&quot;ok&quot;</span>是否等于<span class="string">&quot;ok&quot;</span></span></span><br><span class="line">if [ &quot;ok&quot; = &quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;equal&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：23是否大于等于22</span></span><br><span class="line">if [ 23 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;大于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例3：/opt/<span class="built_in">test</span>/a.txt 目录中的文件是否存在</span></span><br><span class="line">if [ -f /opt/test/a.txt ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYWxFf.png" style="zoom:80%;">

<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">代码</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例：当命令行参数是1时输出<span class="string">&quot;周一&quot;</span>，是2时输出<span class="string">&quot;周二&quot;</span>，其他输出<span class="string">&quot;others&quot;</span></span></span><br><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;others&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYIqaR.png" style="zoom:80%;">

<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p>基本语法1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">    代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>基本语法2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">    代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure>



<p>实践1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：打印命令行输入的参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash">$*把参数当整体对待，<span class="variable">$@</span>把参数分开对待</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;num is $i&quot;</span><br><span class="line">done</span><br><span class="line">echo &quot;=======================================&quot;</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">    echo &quot;num is $j&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/hYb5DS.png" style="zoom:80%;">

<p>实践2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：从命令行输入一个数n，将1~n的值累加</span></span><br><span class="line">SUM=0</span><br><span class="line">for(( i=1; i&lt;=$1; i++ ))</span><br><span class="line">do</span><br><span class="line">    SUM=$[$SUM+$i]</span><br><span class="line">done</span><br><span class="line">echo &quot;SUM=$SUM&quot;</span><br></pre></td></tr></table></figure>

<h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">    代码</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例：从命令行输入一个数n，将1~n的值累加</span></span><br><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -le $1 ]</span><br><span class="line">do</span><br><span class="line">   SUM=$[$SUM+$i]</span><br><span class="line">   i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;执行结果=$SUM&quot;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>定义数组：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=(value1 value2 ... valuen)</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure>

<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>读取数组：<code>$&#123;array_name[index]&#125;</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">my_array=(A B &quot;C&quot; D)</span><br><span class="line"></span><br><span class="line">echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;</span><br><span class="line">echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;</span><br><span class="line">echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;</span><br><span class="line">echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>执行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">第一个元素为: A</span><br><span class="line">第二个元素为: B</span><br><span class="line">第三个元素为: C</span><br><span class="line">第四个元素为: D</span><br></pre></td></tr></table></figure>



<h4 id="获取所有元素"><a href="#获取所有元素" class="headerlink" title="获取所有元素"></a>获取所有元素</h4><p>获取数组内的所有元素：使用@ 或 * </p>
<p>接上例，添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组的元素为: A B C D</span><br></pre></td></tr></table></figure>



<h4 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h3><p>基本语法：</p>
<ul>
<li><p><code>read 选项 参数</code></p>
<p>选项：</p>
<ul>
<li>-p：指定读取值时的提示符</li>
<li>-t：指定读取值时等待的时间，如果超时则不再等待</li>
</ul>
<p>参数：指定读取值的变量名（参数和前边必须用空格隔开）</p>
</li>
</ul>
<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：读取控制台输入一个NUM1值</span></span><br><span class="line">read -p &quot;请输入一个数NUM1=&quot; NUM1 #程序会被阻塞在这里，等待输入</span><br><span class="line">echo &quot;你输入的NUM1=$NUM1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例2：读取控制台输入一个NUM2值，在10秒内输入</span></span><br><span class="line">read -t 10 -p &quot;请输入一个数NUM2=&quot; NUM2</span><br><span class="line">echo &quot;你输入的NUM2=$NUM2&quot;</span><br></pre></td></tr></table></figure>



<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h4><p>basename：返回完整路径最后 / 的部分，常用于获取文件名</p>
<p>语法：<code>basename [pathname] [suffix]</code></p>
<p>如果suffix被指定，则文件后缀如.txt也会被去掉</p>
<p>实例：basename /home/aaa/test.txt 返回test.txt，basename /home/aaa/test.txt .txt 返回test</p>
<p>dirname：返回完整路径最后 / 的前面的部分，常用于返回路径部分</p>
<p>语法：<code>dirname [pathname]</code></p>
<p>实例：dirname /home/aaa/test.txt 返回/home/aaa</p>
<h4 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h4><p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ function ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">    Action;</span><br><span class="line">    [return int;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用直接写函数名：funname [值]</span><br></pre></td></tr></table></figure>

<p>实践：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">案例1：计算输入两个参数的和（动态获取），getSum</span></span><br><span class="line">function getSum() &#123;</span><br><span class="line">    SUM=$[$n1+$n2]</span><br><span class="line">    echo &quot;SUM=$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;请输入一个数n1=&quot; n1</span><br><span class="line">read -p &quot;请输入一个数n2=&quot; n2</span><br><span class="line"></span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure>



<p>执行情况：</p>
<img src="https://z3.ax1x.com/2021/08/30/htZgc6.png" style="zoom:80%;">

<h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>日志是用来记录重大事件的工具</p>
<p>/var/log是系统日志文件的保存位置</p>
<p>系统常用的日志：</p>
<img src="https://z3.ax1x.com/2021/08/30/htreCd.png" style="zoom: 80%;">



<p>应用案例：</p>
<p>使用root用户通过xshell6登录，第一次使用错误的密码，第二次使用正确的密码登录成功，可以查看/var/log/secure里记录的相关信息</p>
<h3 id="日志管理服务"><a href="#日志管理服务" class="headerlink" title="日志管理服务"></a>日志管理服务</h3><p>centos7使用的日志管理服务是rsyslogd（负责写日志），和以前版本的syslogd是兼容的，/etc/rsyslog.config 可以查看日志服务管理的文件有那些</p>
<ul>
<li><code>ps aux | grep &quot;rsyslog&quot; | grep -v &quot;grep&quot;</code>：查看rsyslogd服务是否启动</li>
<li><code>systemctl list-unit-files | grep rsyslog</code>：查询rsyslogd服务的自启动状态</li>
</ul>
<p>配置文件 /etc/rsyslog.config：编辑文件时的格式为 <code>*.*</code>，其中第一个*代表日志类型，第二个*代表日志级别</p>
<p>日志类型：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">auth</td>
<td align="left">pam产生的日志</td>
</tr>
<tr>
<td align="left">authpriv</td>
<td align="left">ssh、ftp等登录信息的验证信息</td>
</tr>
<tr>
<td align="left">corn</td>
<td align="left">时间任务相关</td>
</tr>
<tr>
<td align="left">kern</td>
<td align="left">内核</td>
</tr>
<tr>
<td align="left">lpr</td>
<td align="left">打印</td>
</tr>
<tr>
<td align="left">mail</td>
<td align="left">邮件</td>
</tr>
<tr>
<td align="left">mark(syslog)-rsyslog</td>
<td align="left">服务内部的信息，时间标识</td>
</tr>
<tr>
<td align="left">news</td>
<td align="left">新闻组</td>
</tr>
<tr>
<td align="left">user</td>
<td align="left">用户程序产生的相关信息</td>
</tr>
<tr>
<td align="left">uucp</td>
<td align="left">主机之间相关的通信</td>
</tr>
<tr>
<td align="left">local 1-7</td>
<td align="left">自定义的日志设备</td>
</tr>
</tbody></table>
<p>日志级别：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>级别</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>有调试信息的，日志通信最多</td>
</tr>
<tr>
<td>info</td>
<td>一般信息日志，最常用</td>
</tr>
<tr>
<td>notice</td>
<td>最具有重要性的普通条件的信息</td>
</tr>
<tr>
<td>warning</td>
<td>警告级别</td>
</tr>
<tr>
<td>err</td>
<td>错误级别，某个功能或模块不能正常工作的信息</td>
</tr>
<tr>
<td>crit</td>
<td>严重级别，整个系统或整个软件不能正常工作的信息</td>
</tr>
<tr>
<td>alert</td>
<td>需要立刻修改的信息</td>
</tr>
<tr>
<td>emerg</td>
<td>内核崩溃等重要信息</td>
</tr>
<tr>
<td>none</td>
<td>什么也不记录</td>
</tr>
</tbody></table>
<p>从上到下，级别从低到高，记录信息越来越少</p>
<p>由rsyslogd记录的日志文件，文件的格式包含以下4列：</p>
<ol>
<li>事件产生的时间</li>
<li>产生事件的服务器的主机名</li>
<li>产生事件的服务名或程序名</li>
<li>事件的具体信息</li>
</ol>
<h3 id="自定义日志服务"><a href="#自定义日志服务" class="headerlink" title="自定义日志服务"></a>自定义日志服务</h3><p>在/etc/rsyslog.conf中添加一个日志文件/var/log/test.log，当有事件发生时，该文件会接收到信息并保存</p>
<img src="https://z3.ax1x.com/2021/08/31/hUPEse.png" style="zoom:80%;">



<p>生成了test.log，里面保存了全部信息，用grep筛选可以看到有关sshd的信息</p>
<img src="https://z3.ax1x.com/2021/08/31/hUPnII.png" style="zoom: 67%;">

<h3 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p>日志轮替：把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除</p>
<p>centos7使用<code>logrotate</code>进行日志轮替管理，配置文件为<code>/etc/logrotate.conf</code>，可以在该文件内进行全局配置，也可以进行局部配置（可以把局部配置写入该文件，也可以用别的方式，见自定义部分）</p>
<img src="https://z3.ax1x.com/2021/08/31/hUFg8x.png" style="zoom:80%;">



<img src="https://z3.ax1x.com/2021/08/31/hUFg8x.png" style="zoom:80%;">



<p>关于dateext参数：</p>
<ul>
<li><p>如果配置文件中有dateext参数，那么日志会用日期来作为日志文件的后缀，例如”secure-20210831”。这样日志名不会重叠，只需要指定保存日志个数，删除多余的日志文件即可</p>
</li>
<li><p>如果没有该参数，日志文件需要改名。</p>
<p>当第一次进行日志轮替时，当前”secure”日志会自动改名为”secure.1”，然后新建”secure”日志，用来保存新的日志。</p>
<p>当第一次进行日志轮替时，当前”secure1”日志会自动改名为”secure.2”，以此类推。</p>
</li>
</ul>
<p>其他参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="center">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">daily</td>
<td align="center">轮替周期为每天</td>
</tr>
<tr>
<td align="left">weekly</td>
<td align="center">每周</td>
</tr>
<tr>
<td align="left">monthly</td>
<td align="center">每月</td>
</tr>
<tr>
<td align="left">rotate 数字</td>
<td align="center">保留的日志文件的个数，0指没有备份</td>
</tr>
<tr>
<td align="left">compress</td>
<td align="center">日志轮替时，旧的日志进行压缩</td>
</tr>
<tr>
<td align="left">create mode owner group</td>
<td align="center">建立新日志，同时指定新日志的权限与所有者和所属组</td>
</tr>
<tr>
<td align="left">mail address</td>
<td align="center">当日志轮替时，输出内容通过邮件发送到指定的邮件地址</td>
</tr>
<tr>
<td align="left">missingok</td>
<td align="center">如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td align="left">notifempty</td>
<td align="center">如果日志为空文件，则不进行日志轮替</td>
</tr>
<tr>
<td align="left">minsize 大小</td>
<td align="center">日志轮替的最小值（达到该最小值才会轮替，否则时间到了也不轮替）</td>
</tr>
<tr>
<td align="left">size 大小</td>
<td align="center">日志只有大于指定大小才进行日志轮替，而不是按照时间轮替</td>
</tr>
<tr>
<td align="left">dateext</td>
<td align="center">使用日期作为日志轮替文件的后缀</td>
</tr>
<tr>
<td align="left">sharedscripts</td>
<td align="center">在此关键字之后的脚本只执行一次</td>
</tr>
<tr>
<td align="left">prerotate/endscript</td>
<td align="center">在日志轮替之前执行脚本命令</td>
</tr>
<tr>
<td align="left">postrotate/endscript</td>
<td align="center">在日志轮替之后执行脚本命令</td>
</tr>
</tbody></table>
<h4 id="自定义日志轮替"><a href="#自定义日志轮替" class="headerlink" title="自定义日志轮替"></a>自定义日志轮替</h4><p>把自己的日志加入日志轮替：</p>
<ul>
<li>方法一：直接在/etc/logrotate.conf中写入该日志的轮替策略（不推荐）</li>
<li>方法二：在/etc/logrotate.d/目录中新建该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被”include”到主配置文件中，所以也可以把日志加入轮替（推荐，便于维护）</li>
</ul>
<img src="https://z3.ax1x.com/2021/08/31/hUe9gI.png" style="zoom:80%;">

<h4 id="日志轮替原理"><a href="#日志轮替原理" class="headerlink" title="日志轮替原理"></a>日志轮替原理</h4><p>日志轮替依赖系统定时任务</p>
<p>在/etc/cron.daily/目录中，有可执行文件logrotate，logrotate通过这个文件完成定时任务执行</p>
<h3 id="查看内存日志"><a href="#查看内存日志" class="headerlink" title="查看内存日志"></a>查看内存日志</h3><p>journalctl可以查看内存日志，重启会清空，指令：</p>
<ul>
<li><p><code>journalctl</code>：查看全部</p>
</li>
<li><p><code>journalctl -n 3</code>：查看最新3条</p>
</li>
<li><p><code>journalctl --since 19:00 --until 19:10:00</code>：查看起始时间到结束时间的日志，可加日期</p>
</li>
<li><p><code>journalctl -p err</code>：报错日志</p>
</li>
<li><p><code>journalctl -o verbose</code>：日志详细内容</p>
</li>
<li><p><code>journal _PID=1245 _COMM=sshd</code>：查看包含这些参数的日志</p>
<p>或者<code>journalctl | grep sshd</code></p>
</li>
</ul>
<h2 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h2><p>linux的备份和恢复的两种方式：</p>
<ol>
<li>把需要的文件（或分区）用TAR打包，下次需要恢复时，解压并覆盖即可</li>
<li>使用dump和restore命令</li>
</ol>
<h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><p>首先安装dump和restore指令：<code>yum -y install dump</code>，会同时安装2个指令</p>
<p>dump支持分卷和增量备份，语法：</p>
<img src="https://z3.ax1x.com/2021/08/31/hUYIc8.png" style="zoom:80%;">

<p>c是一个0到9的数，备份时从0开始，一直到9，然后又从0开始</p>
<p>关于备份层级：如果不理解可以再看看视频P133</p>
<p>实践1：将/boot分区所有内容备份到 /opt/boot.bak0.bz2 文件中，备份层级为”0”：</p>
<p><code>dump -0uj -f /opt/boot.bak0.bz2 /boot</code></p>
<p>实践2：在/boot目录下增加新文件，备份层级为”1”（只备份上次使用层次”0”备份后发生过改变的数据）：</p>
<p><code>dump -1uj -f /opt/boot.bak1.bz2 /boot</code></p>
<p>通过dump命令配合crontab可以实现无人值守备份</p>
<p>查询操作：</p>
<ul>
<li><code>dump -W</code>：显示需要备份的文件以及最后一次备份的层级、时间、日期</li>
<li><code>dump -w</code>：仅显示需要备份的文件</li>
<li><code>cat /etc/dumpdates</code>：查看备份时间文件</li>
</ul>
<p>注意，在备份分区时支持增量备份，<strong>如果备份文件或目录</strong>，不再支持增量备份，此时数字只能写0，也不能提供-u选项</p>
<blockquote>
<p>如果是重要的备份文件，建议将文件上传到其他服务器保存，<strong>不要将鸡蛋放在同一个篮子里</strong></p>
</blockquote>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>restore命令用于恢复已备份的文件，可以从dump生成的备份文件中恢复原文件</p>
<p>基本语法：</p>
<ul>
<li><p><code>restore [模式选项] [选项]</code></p>
<p>模式选项：一次只能指定一种</p>
<ul>
<li>-C：对比模式，将备份的文件与已存在的文件相互对比</li>
<li>-i：交互模式，在进行还原操作时，restore指令依序询问用户</li>
<li>-r：还原模式</li>
<li>-t：查看模式，看备份文件有哪些文件</li>
</ul>
<p>选项：</p>
<ul>
<li>-f&lt;备份设备&gt;：从指定的文件中读取备份数据，进行还原操作</li>
</ul>
</li>
</ul>
<p>实践：</p>
<ul>
<li>使用对比模式：先将某文件改名，再执行<code>restore -C -f boot.bak1.bz2</code></li>
</ul>
<img src="https://z3.ax1x.com/2021/08/31/hUg19U.png" style="zoom:80%;">



<ul>
<li>使用查看模式，看备份文件有哪些数据/文件：<code>restore -t -f boot.bak0.bz2</code></li>
</ul>
<img src="https://z3.ax1x.com/2021/08/31/hUWp7R.png" style="zoom:80%;">

<ul>
<li><p>使用还原模式，注意：如果有增量备份，需要把增量备份文件也进行恢复，有几个就要恢复几次，并且要按顺序恢复：</p>
<p><code>restore -r -f /opt/boot.bak0.bz2</code>：恢复到第1次完全备份状态</p>
<p><code>restore -r -f /opt/boot.bak1.bz2</code>：恢复到第1次增量备份状态</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>svg-sprite</title>
    <url>/2021/08/26/svg-sprite/</url>
    <content><![CDATA[<h1 id="何为-svg-sprite"><a href="#何为-svg-sprite" class="headerlink" title="何为 svg-sprite"></a>何为 svg-sprite</h1><h2 id="css-sprite"><a href="#css-sprite" class="headerlink" title="css-sprite"></a>css-sprite</h2><p>在说svg-sprite以前，先聊聊css-sprite，一般我们称之为“雪碧图”。</p>
<p>雪碧图，就是把很多小的图标整合到一张图片中，可以减少向后端请求的次数。</p>
<p><img src="https://i.stack.imgur.com/fu607.png"></p>
<p>在使用这些图片时，比如让这些图片作背景，便可以调整 <code>background-position    </code>值，使之显示我们需要的部分。</p>
<h2 id="svg-sprite"><a href="#svg-sprite" class="headerlink" title="svg-sprite"></a>svg-sprite</h2><p>因此，svg-sprite 同理，就是把很多svg合到一个.svg文件中，开发者使用图标时，每次只使用其中的一部分。</p>
<p>首先，我们需要得到一些.svg文件，可以前往iconfont等网站下载：</p>
<p><img src="https://s1.ax1x.com/2022/03/23/qlgFAA.png"></p>
<p>之后，可以借助一些工具将这些.svg文件合并，产生svg-sprite.svg：</p>
<p><a href="https://www.zhangxinxu.com/sp/svgo/">SVG在线压缩合并工具</a></p>
<p><a href="https://icomoon.io/app/#/select">icomoon</a></p>
<p>有了合并后的svg，还需要知道使用方法：</p>
<p>SVG Sprite最佳实践是使用<code>symbol</code>元素，可以把SVG元素看成一个舞台，而<code>symbol</code>则是舞台上一个一个组装好的元件，这这些一个一个的元件就是我们即将使用的一个一个SVG图标，然后，使用use来调用它们。</p>
<p>除了symbol，还可以使用<code>defs</code>。</p>
<blockquote>
<p>SVG的<defs>元素用于预定义一个元素使其能够在SVG图像中重复使用。</defs></p>
<p>SVG <symbol>元素用于定义可重复使用的符号。能够创建自己的视窗，能够应用viewBox和preserveAspectRatio属性。</symbol></p>
</blockquote>
<p>它们的共同特点是，在其中的元素都不会直接显示出来，需要使用<code>use</code>调用。</p>
<p>use具有<strong>可重复调用</strong>和<strong>跨SVG调用</strong>的特性，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;shape&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;0&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--可重复调用--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#shape&quot;</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#shape&quot;</span> <span class="attr">x</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--跨svg调用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#shape&quot;</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器中的效果：</p>
<p><img src="https://s1.ax1x.com/2022/03/23/qlg3hq.png"></p>
<p>因此，当获得了合成后的svg文件，我们可以采用外链引入的方式，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">&quot;svg-sprite&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;./svg/symbol-defs.svg#icon-game&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过，根据浏览器的安全策略，页面会出现空白，控制台有一行报错信息。</p>
<p>因此，此处的演示选择直接将合成svg代码复制进来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      svg &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-id">#game</span> &#123;</span></span><br><span class="line"><span class="css">        fill: red;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">      </span></span><br><span class="line"><span class="css">      <span class="selector-id">#book1</span> &#123;</span></span><br><span class="line"><span class="css">        fill: green;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-id">#book2</span> &#123;</span></span><br><span class="line"><span class="css">        fill: blue;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--合并的svg，其中包含三个图标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">      <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">&quot;position: absolute; width: 0; height: 0; overflow: hidden&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">symbol</span> <span class="attr">id</span>=<span class="string">&quot;icon-game&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 32 32&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">d</span>=<span class="string">&quot;M32..&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">symbol</span> <span class="attr">id</span>=<span class="string">&quot;icon-book1&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 32 32&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">d</span>=<span class="string">&quot;M25...&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">d</span>=<span class="string">&quot;M21...&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">symbol</span> <span class="attr">id</span>=<span class="string">&quot;icon-book2&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 32 32&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">            <span class="attr">d</span>=<span class="string">&quot;M27...&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">symbol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--利用use的跨svg调用特性，调用这些图标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-game&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">&quot;book1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-book1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">&quot;book2&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-book2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<p><img src="https://s1.ax1x.com/2022/03/23/qlg1Nn.png"></p>
<p>Svg-sprite 优点：</p>
<ol>
<li>修改ID就可以改变图标，使用方便。</li>
<li>页面代码量小，维护成本低。</li>
<li>图标可改变颜色大小，减少重复图片的加载</li>
<li>减少图片请求量。</li>
</ol>
<h1 id="svg-sprite-在框架中的应用"><a href="#svg-sprite-在框架中的应用" class="headerlink" title="svg-sprite 在框架中的应用"></a>svg-sprite 在框架中的应用</h1><p>前端项目中常常有使用小图标的需求，以vue为例：</p>
<p>我们需要解决的问题如下：</p>
<ol>
<li>自动打包svg，生成svg-sprite，并将打包好的内容插入html。</li>
<li>创建组件，以后在使用图标时，只用传入图标的名称，便可以生成icon。</li>
</ol>
<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><h3 id="配置loader"><a href="#配置loader" class="headerlink" title="配置loader"></a>配置loader</h3><p>首先，下载<code>svg-sprite-loader</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install svg-sprite-loader -D</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/JetBrains/svg-sprite-loader">svg-sprite-loader</a> 的作用是<strong>合并一组单个的svg图片为一个sprite，并把合成好的内容，插入到html内，形式是添加svg标签。</strong></p>
<p>指定<code>@/src/icons</code>，在该目录下新建/svg目录，把svg图全部放在该目录下。</p>
<p>vue-cli对svg文件有默认的<code>url-loader</code> 处理，所以要排除<code>url-loader</code>对<code>@/src/icons</code>的处理，指定<code>svg-sprite-loader</code>处理。</p>
<p>修改<code>vue.config.js</code>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例</span></span><br><span class="line">  <span class="comment">// 允许对内部的 webpack 配置进行更细粒度的修改</span></span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 配置svg默认规则排除icons目录中svg文件处理</span></span><br><span class="line">    config.module.rule(<span class="string">&#x27;svg&#x27;</span>).exclude.add(resolve(<span class="string">&#x27;src/icons&#x27;</span>)).end();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增icons规则，设置svg-sprite-loader处理icons目录中svg文件</span></span><br><span class="line">    config.module</span><br><span class="line">      .rule(<span class="string">&#x27;icons&#x27;</span>)</span><br><span class="line">      .test(<span class="regexp">/\.svg$/</span>)</span><br><span class="line">      .include.add(resolve(<span class="string">&#x27;src/icons&#x27;</span>))</span><br><span class="line">      .end()</span><br><span class="line">      .use(<span class="string">&#x27;svg-sprite-loader&#x27;</span>)</span><br><span class="line">      .loader(<span class="string">&#x27;svg-sprite-loader&#x27;</span>)</span><br><span class="line">      .options(&#123; <span class="attr">symbolId</span>: <span class="string">&#x27;icon-[name]&#x27;</span> &#125;)</span><br><span class="line">      .end();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码首先排除了默认svg的loader对<code>icons/</code>目录下svg文件的处理，然后新增了一个规则让<code>svg-sprite-loader</code>处理<code>icons/</code>文件夹下的svg文件，最后设置了<code>icon-</code>加上经过处理的svg文件名作为symbolId，也就是说在使用<code>book.svg</code>时可以直接在use标签使用<code>#icon-book</code>。</p>
<p>此时，在main.js中引入一些svg，这些svg经过处理变为sprite，然后我们就可以使用这些图标了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/icons/svg/book.svg&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--template中使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">:class</span>=<span class="string">&quot;svgClass&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">xlink:href</span>=<span class="string">&quot;#icon-book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">use</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，sprite就只会把引入的这些图标打包，然后插入html：</p>
<p><img src="https://s1.ax1x.com/2022/03/23/qlafKI.jpg"></p>
<p>不过，一个一个引入组件是很麻烦的，我们希望可以将全部svg直接打包插入html，在icons/下创建index.js：</p>
<p><img src="https://s1.ax1x.com/2022/03/23/qlwvNT.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// icons图标自动加载</span></span><br><span class="line"><span class="keyword">const</span> req = <span class="built_in">require</span>.context(<span class="string">&quot;./svg&quot;</span>, <span class="literal">false</span>, <span class="regexp">/\.svg$/</span>);</span><br><span class="line">req.keys().map(req);</span><br></pre></td></tr></table></figure>

<p>然后，在main.js中引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/icons/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这样，处于icons/svg下的所有svg文件都会被打包，在template中直接使用即可：</p>
<p><img src="https://s1.ax1x.com/2022/03/23/ql0GUf.jpg"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>上边的方式还是不够优雅，我们在/components目录下创建<code>SvgIcon.vue</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;svg :class=&quot;svgClass&quot;&gt;</span><br><span class="line">    &lt;use :xlink:href=&quot;iconName&quot; /&gt;</span><br><span class="line">  &lt;/svg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; computed, toRefs &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;SvgIcon&#x27;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    iconClass: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    className: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    // 如果不使用toRefs，可能丢掉效应式的特性</span><br><span class="line">    const &#123; className, iconClass &#125; = toRefs(props)</span><br><span class="line">  </span><br><span class="line">    const iconName = computed(() =&gt; `#icon-$&#123;iconClass.value&#125;`);</span><br><span class="line">    const svgClass = computed(() =&gt; &#123;</span><br><span class="line">      if (className.value) &#123;</span><br><span class="line">        return &#x27;svg-icon &#x27; + className.value;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &#x27;svg-icon&#x27;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      iconName,</span><br><span class="line">      svgClass,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.svg-icon &#123;</span><br><span class="line">  width: 2em;</span><br><span class="line">  height: 2em;</span><br><span class="line">  fill: currentColor;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>在main.js中，注册为全局组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> SvgIcon <span class="keyword">from</span> <span class="string">&#x27;./components/Svg-icon.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/icons/index.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册全局组件</span></span><br><span class="line">createApp(App).component(<span class="string">&#x27;svg-icon&#x27;</span>, SvgIcon).mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!--使用SvgIcon组件--&gt;</span><br><span class="line">    &lt;svg-icon :iconClass=&quot;&#x27;book&#x27;&quot; :className=&quot;&#x27;icon-book&#x27;&quot; /&gt;</span><br><span class="line">    &lt;svg-icon :iconClass=&quot;&#x27;game&#x27;&quot; :className=&quot;&#x27;icon-game&#x27;&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">/* 设置图标样式 */</span><br><span class="line">.icon-book &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.icon-game &#123;</span><br><span class="line">  color: green;</span><br><span class="line">  transition: all .3s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 还可以使用媒体查询 */</span><br><span class="line">@media only screen and (max-width: 800px) &#123;</span><br><span class="line">  .icon-game &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>（此处演示使用vite + vue3 + ts）</p>
<p>到了 <code>Vite</code> 上，由于不再使用 <code>webpack</code>进行打包，配置方式有所变化。</p>
<p>依然先安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install svg-sprite-loader</span><br></pre></td></tr></table></figure>



<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://s1.ax1x.com/2022/03/23/qlc6mQ.jpg"></p>
<p>在@/src/plugins下创建<code>svgBuilder.ts</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Plugin &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; readFileSync, readdirSync &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> idPerfix = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> svgTitle = <span class="regexp">/&lt;svg([^&gt;+].*?)&gt;/</span>;</span><br><span class="line"><span class="keyword">const</span> clearHeightWidth = <span class="regexp">/(width|height)=&quot;([^&gt;+].*?)&quot;/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasViewBox = <span class="regexp">/(viewBox=&quot;[^&gt;+].*?&quot;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clearReturn = <span class="regexp">/(\r)|(\n)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSvgFile</span>(<span class="params">dir</span>): <span class="title">string</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> svgRes = [];</span><br><span class="line">  <span class="keyword">const</span> dirents = readdirSync(dir, &#123;</span><br><span class="line">    <span class="attr">withFileTypes</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> dirent <span class="keyword">of</span> dirents) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirent.isDirectory()) &#123;</span><br><span class="line">      svgRes.push(...findSvgFile(dir + dirent.name + <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> svg = readFileSync(dir + dirent.name)</span><br><span class="line">        .toString()</span><br><span class="line">        .replace(clearReturn, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        .replace(svgTitle, <span class="function">(<span class="params">$<span class="number">1</span>, $<span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> width = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">let</span> height = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">let</span> content = $<span class="number">2.</span>replace(clearHeightWidth, <span class="function">(<span class="params">s1, s2, s3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2 === <span class="string">&#x27;width&#x27;</span>) &#123;</span><br><span class="line">              width = s3;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s2 === <span class="string">&#x27;height&#x27;</span>) &#123;</span><br><span class="line">              height = s3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">if</span> (!hasViewBox.test($<span class="number">2</span>)) &#123;</span><br><span class="line">            content += <span class="string">`viewBox=&quot;0 0 <span class="subst">$&#123;width&#125;</span> <span class="subst">$&#123;height&#125;</span>&quot;`</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">`&lt;symbol id=&quot;<span class="subst">$&#123;idPerfix&#125;</span>-<span class="subst">$&#123;dirent.name.replace(</span></span></span><br><span class="line"><span class="subst"><span class="string">            <span class="string">&#x27;.svg&#x27;</span>,</span></span></span><br><span class="line"><span class="subst"><span class="string">            <span class="string">&#x27;&#x27;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">          )&#125;</span>&quot; <span class="subst">$&#123;content&#125;</span>&gt;`</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .replace(<span class="string">&#x27;&lt;/svg&gt;&#x27;</span>, <span class="string">&#x27;&lt;/symbol&gt;&#x27;</span>);</span><br><span class="line">      svgRes.push(svg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> svgRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> svgBuilder = (path: string, perfix = <span class="string">&#x27;icon&#x27;</span>): <span class="function"><span class="params">Plugin</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (path === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">  idPerfix = perfix;</span><br><span class="line">  <span class="keyword">const</span> res = findSvgFile(path);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;svg-transform&#x27;</span>,</span><br><span class="line">    transformIndexHtml(html): string &#123;</span><br><span class="line">      <span class="keyword">return</span> html.replace(</span><br><span class="line">        <span class="string">&#x27;&lt;body&gt;&#x27;</span>,</span><br><span class="line">        <span class="string">`</span></span><br><span class="line"><span class="string">          &lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; style=&quot;position: absolute; width: 0; height: 0&quot;&gt;</span></span><br><span class="line"><span class="string">              <span class="subst">$&#123;res.join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">            &lt;/svg&gt;</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>配置<code>vite.config.ts</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; svgBuilder &#125; <span class="keyword">from</span> <span class="string">&#x27;./src/plugins/svgBuilder&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineConfig(&#123;</span><br><span class="line">  <span class="comment">// 指定存放svg文件的目录为 src/assets/svg/</span></span><br><span class="line">  <span class="attr">plugins</span>: [vue(), svgBuilder(<span class="string">&#x27;./src/assets/svg/&#x27;</span>)],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h3><p>注册和使用方式同 vue-cli，注意此时不再需要引入刚刚的 index.js。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> SvgIcon <span class="keyword">from</span> <span class="string">&#x27;./components/Svg-icon.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">createApp(App).component(<span class="string">&#x27;svg-icon&#x27;</span>, SvgIcon).mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/">未来必热：SVG Sprites技术介绍</a></p>
<p><a href="https://juejin.cn/post/6844903998563024910#heading-18">Vue项目中优雅使用icon</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/468930912">vite中使用svg图标</a></p>
]]></content>
      <categories>
        <category>svg</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器是如何工作的</title>
    <url>/2021/08/22/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>参考视频：<a href="https://www.bilibili.com/video/BV1x54y1B7RE">浏览器是如何运作的</a></p>
<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h2 id="浏览器的组成部分"><a href="#浏览器的组成部分" class="headerlink" title="浏览器的组成部分"></a>浏览器的组成部分</h2><p>浏览器分为以下几个部分：<code>用户界面</code>，<code>浏览器引擎</code>，<code>渲染引擎</code></p>
<p>其中：</p>
<ul>
<li>用户界面用于展示除标签页窗口之外的其它用户界面内容</li>
<li>渲染引擎负责渲染用户请求的页面内容</li>
<li>浏览器引擎用于在用户界面和渲染引擎之间传递数据</li>
</ul>
<p>渲染器下有很多小的功能模块，如负责网络请求的<code>网络模块</code>，用于解析和执行js的<code>js解释器</code>，还有<code>数据存储持久层</code>（帮助浏览器存储各种数据，如cookie）</p>
<blockquote>
<p><strong>渲染引擎是浏览器的核心，把它称作浏览器的内核</strong></p>
</blockquote>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><center>
    <img src="https://img-blog.csdnimg.cn/20210311162244195.png" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<p>Blink是基于Webkit改造的</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><center>
    <img src="https://img-blog.csdnimg.cn/20210311164614193.png" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<ul>
<li><p>当我们启动某个程序时，就会创建一个<code>进程</code>来执行任务代码，同时会为该进程分配内存空间，该应用程序的状态都保存在该内存空间里</p>
</li>
<li><p>当应用关闭时，该内存空间就会被回收，进程可以启动更多的进程来执行任务</p>
</li>
<li><p>两个进程间相互独立，如果需要两个进程空间需要传递某些数据，则使用<code>进程间通信管道IPC</code>传递</p>
</li>
<li><p>进程可以将任务分成更多细小的任务，然后通过创建多个线程并行执行不同的任务</p>
</li>
<li><p>同一进程下的线程是可以直接通信共享数据的</p>
</li>
</ul>
<h3 id="各进程的作用"><a href="#各进程的作用" class="headerlink" title="各进程的作用"></a>各进程的作用</h3><center>
    <img src="https://img-blog.csdnimg.cn/20210311164620571.jpg" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>


<ul>
<li><p><code>浏览器进程</code>负责控制chrome浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与浏览器的其它进程协调工作</p>
</li>
<li><p><code>网络进程</code>负责发起接受网络请求</p>
</li>
<li><p><code>GPU进程</code>负责整个浏览器界面的渲染</p>
</li>
<li><p><code>插件进程</code> 负责控制网站使用的所有插件（此处插件是flash等，不是chrome安装的拓展插件）</p>
</li>
<li><p><code>渲染器进程</code>用来控制显示tab标签内的所有内容</p>
</li>
</ul>
<h1 id="从输入网址到加载网页的过程"><a href="#从输入网址到加载网页的过程" class="headerlink" title="从输入网址到加载网页的过程"></a>从输入网址到加载网页的过程</h1><center>
    <img src="https://img-blog.csdnimg.cn/20210311164839647.jpg" width="70%">
    <br>
    <font size="3" face="楷体" color="#999"><u></u></font>
</center>

<p>浏览器默认情况下，为每个标签页都创建一个进程</p>
<h2 id="输入网址"><a href="#输入网址" class="headerlink" title="输入网址"></a>输入网址</h2><p>在地址栏输入地址时，<code>浏览器进程的UI线程</code>会捕捉你的输入内容</p>
<p>如果访问的是网址，则UI线程会启动一个<code>网络线程</code>来请求DNS进行域名解析，接着开始链接服务器获取数据</p>
<p>如果输入不是网址而是一串关键词，浏览器判断你要搜索，就会使用<code>默认配置的搜索引擎</code>来查询</p>
<p>当网络线程获取到数据后，会通过<code>SafeBrowsing</code>来检查站点是否是恶意站点，如果是，则提示警告页面（可强行继续访问）</p>
<blockquote>
<p>SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据来判断是否安全（比如通过查看该站点IP是否在谷歌黑名单之内）</p>
</blockquote>
<p>当返回数据准备完毕并且安全校验通过时，网络线程会通知UI线程:自己已经准备好，然后UI线程会创建一个渲染器进程来渲染页面</p>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><h3 id="获得DOM树"><a href="#获得DOM树" class="headerlink" title="获得DOM树"></a>获得DOM树</h3><p>浏览器进程通过IPC管道将数据传递给渲染器进程，正式进入渲染流程</p>
<p>渲染器进程接收到的数据也就是html，<strong>渲染器进程的核心任务就是把html css js image等资源渲染成用户可以交互的web页面</strong></p>
<p>渲染器进程的<code>主线程</code>将html进行解析，构造DOM数据结构（DOM是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发程序员可以通过JS与之交互的数据结构和API）</p>
<p>html首先经过<code>tokeniser标记化</code>，通过<code>词法分析</code>将输入的html内容解析成多个标记，根据识别后的标记进行<code>DOM树构造</code>，在DOM树构造过程中会创建document对象，然后以document为根节点的DOM树不断进行修改，向其中添加各种元素</p>
<p>html代码中往往会引入一些额外的资源，图片和CSS这些资源需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞html的解析，不会影响DOM的生成</p>
<p>但当HTML解析过程中遇到script标签，将停止html解析流程，转而去加载解析并且执行JS，这是因为浏览器不知道JS执行是否会改变当前页面的HTML结构（JS代码可以用document.write 来修改html），这就是要把script标签放在合适的位置/或者使用async或defer属性来异步加载执行JS 的原因</p>
<p>HTML解析完成之后，获得DOM树，但我们还不知道其上每个结点长什么样子</p>
<h3 id="获得Layout树"><a href="#获得Layout树" class="headerlink" title="获得Layout树"></a>获得Layout树</h3><p>主线程需要解析CSS，并确定每个DOM结点的计算样式，即使没有提供CSS样式，浏览器也会有自己默认的样式表</p>
<p>我们接下来需要知道每个结点需要放在页面上的哪个位置，也就是结点的坐标以及该结点需要占用多大的区域，这个阶段被成为layout布局</p>
<p>主线程通过遍历dom和计算好的样式来生成Layout树，Layout树上的每个结点都记录了x，y坐标和边框尺寸</p>
<blockquote>
<p>注意DOM树和Layout树并不是一一对应的，设置了display:none 的结点不会出现在Layout树上，而在before伪类中添加了content值的元素，content里的内容会出现在Layout树上，而不会出现在DOM树里，这是因为DOM树是通过html解析获得，并不关系样式，而Layout树是根据DOM和计算好的样式来生成的，<strong>Layout树是和最后展示在屏幕上的结点是对应的</strong></p>
</blockquote>
<h3 id="栅格化与合成"><a href="#栅格化与合成" class="headerlink" title="栅格化与合成"></a>栅格化与合成</h3><p>我们还需要知道以什么样的顺序绘制这个结点</p>
<p>举例来说，z-index属性会影响结点绘制的层级关系，如果我们按照dom的层级结构来绘制页面，则会导致错误的渲染，所以为了保证在屏幕上展示正确的层级，主线程遍历Layout树创建一个绘制记录表，该表记录了绘制的顺序，这个阶段被成为<code>绘制（paint）</code></p>
<p>知道绘制顺序后，现在该把这些信息转化成像素点，显示在屏幕上了，这种行为称为<code>栅格化</code>，chrome使用较为复杂的栅格化流程，叫做<code>合成</code></p>
<p>合成是一种将页面上的各个部分分成多个图层，分别对其进行栅格化，并在合成器线程中单独进行合成页面的技术，简单来说就是页面所有的元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可</p>
<p><strong>主线程遍历Layout树生成Layer树</strong>，当Layer树生成完毕和绘制顺序确定后，主线程将这些信息传递给<code>合成器线程</code>，合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，合成器线程将它们切分成许多<code>图块</code>，然后将每个图块发送给栅格化线程，栅格化线程栅格化每个图块，并将它们存储在<code>GPU内存</code>中，当图块栅格化完成后，合成器线程将收集称为<code>draw quads</code>的图块信息，这些信息里记录了图块在内存中的位置，和在页面的哪个位置绘制图块的信息</p>
<p>根据这些信息合成器线程生成了一个<code>合成器帧</code>，然后合成器帧通过IPC传送给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上，当页面发生变化（比如滚动页面），都会生成一个新的合成器帧，新的帧再传给GPU，然后再次渲染到屏幕上</p>
<h3 id="重排重绘和卡顿现象"><a href="#重排重绘和卡顿现象" class="headerlink" title="重排重绘和卡顿现象"></a>重排重绘和卡顿现象</h3><ul>
<li><p>重排：当改变一个元素的尺寸位置属性时，会重新进行样式计算，布局、绘制以及后面的所有流程</p>
</li>
<li><p>重绘：当改变元素的颜色属性时，不会重新触发布局，但还剩会触发样式计算和绘制</p>
</li>
</ul>
<p>重排和重绘都会占用主线程，JS也运行在主线程</p>
<p>页面的卡顿现象：<br>当页面以每秒60帧的刷新率（每帧16ms）时才不会感到卡顿</p>
<p>重排重绘和JS运行会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作</p>
<p>如果在运行动画时还有大量的JS任务需要执行，由于布局、绘制和JS执行都是在主线程运行的，当在一帧的时间内布局和绘制结束后，如果还有剩余时间，JS就会拿到主线程的使用权，如果JS执行时间过长，就会导致在下一帧开始时JS没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面动画的卡顿</p>
<h3 id="卡顿的优化方案"><a href="#卡顿的优化方案" class="headerlink" title="卡顿的优化方案"></a>卡顿的优化方案</h3><ol>
<li><p>requestAnimationFrame()<br>这个方法会在每一帧被调用，通过API的回调，我们可以把JS运行任务分成一些更小的任务块，分到每一帧，在每一帧时间冲完前暂停JS执行，归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制</p>
</li>
<li><p>由于栅格化的整个流程是不占用主线程的，只在合成器线程和栅格线程中运行，这就意味着它无需和JS抢夺主线程，通过transform属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格化线程中，所以不会受到主线程中JS执行的影响</p>
</li>
</ol>
<p>用transform实现的动画由于不需要经过布局绘制，样式计算等操作，所以节省了很多运算时间</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 模板与 STL</title>
    <url>/2021/08/22/c++%20%E6%A8%A1%E6%9D%BF%E4%B8%8ESTL/</url>
    <content><![CDATA[<h1 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h1><h2 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h2><p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<h2 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h2><ul>
<li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li>
</ul>
<ul>
<li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li>
</ul>
<h3 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h3><p>函数模板作用：建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p>
<p><strong>语法：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替，推荐用class</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用模板实现交换</span></span><br><span class="line">  <span class="comment">//1、自动类型推导</span></span><br><span class="line">  <span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、显示指定类型</span></span><br><span class="line">  mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>函数模板利用关键字 template</li>
<li>使用函数模板有两种方式：自动类型推导、显示指定类型</li>
<li>模板的目的是为了提高复用性，将类型参数化</li>
</ul>
<h3 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h3><p>注意事项：</p>
<ul>
<li>自动类型推导，必须推导出一致的数据类型T，才可以使用</li>
</ul>
<ul>
<li>模板必须要确定出T的数据类型，才可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line">  <span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//func();    //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">  func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li>
</ul>
<h3 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h3><p>案例描述：</p>
<ul>
<li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li>
<li>排序规则从大到小，排序算法为<strong>选择排序</strong></li>
<li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span> </span>&#123;</span><br><span class="line">  T temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[max] &lt; arr[j]) &#123;</span><br><span class="line">        max = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">      <span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//测试char数组</span></span><br><span class="line">  <span class="keyword">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(charArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>);</span><br><span class="line">  <span class="built_in">mySort</span>(charArr, num);</span><br><span class="line">  <span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//测试int数组</span></span><br><span class="line">  <span class="keyword">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in"><span class="keyword">sizeof</span></span>(intArr) / <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br><span class="line">  <span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">  <span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h3><p><strong>普通函数与函数模板区别：</strong></p>
<ul>
<li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">  myAdd02&lt;<span class="keyword">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p>
</blockquote>
<h3 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h3><p>调用规则如下：</p>
<ol>
<li>如果函数模板和普通函数都可以实现，优先调用普通函数</li>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span>&#123; </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line">  <span class="comment">// 注意：如果告诉编译器 普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">  myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">  <span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">  <span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">  <span class="comment">//如果调用普通函数，存在隐式类型转换，而函数模板不需要，所以模板的匹配性更好</span></span><br><span class="line">  <span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p>
<h3 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h3><p><strong>局限性：</strong></p>
<ul>
<li>模板的通用性并不是万能的</li>
</ul>
<p><strong>例如：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">  a = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p>
<p>再例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p>
<p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显式具体化的原型和定义以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line">  <span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line">  <span class="keyword">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用具体化的模板，可以解决自定义类型的通用化</li>
<li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li>
</ul>
<h2 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h2><h3 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h3><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li>
</ul>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>template  —  声明创建模板</p>
<p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p>
<p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">  Person&lt;string, <span class="keyword">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">  P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p>
<h3 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h3><p>类模板与函数模板区别主要有两点：</p>
<ol>
<li>类模板没有自动类型推导的使用方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mAge = age; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">  Person &lt;string ,<span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表，可以指定默认参数</span></span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>类模板使用只能用显示指定类型方式</li>
<li>类模板中的模板参数列表可以有默认参数</li>
</ul>
<h3 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h3><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li>普通类中的成员函数一开始就可以创建</li>
<li>类模板中的成员函数在调用时才创建</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyClass&lt;Person1&gt; m;</span><br><span class="line">  </span><br><span class="line">  m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p>
<h3 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h3><p>一共有三种传入方式：</p>
<ol>
<li>指定传入的类型   — 直接显示对象的数据类型</li>
<li>参数模板化           — 将对象中的参数变为模板进行传递</li>
<li>整个类模板化       — 将这个对象类型 模板化进行传递</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(NameType name, AgeType age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  NameType mName;</span><br><span class="line">  AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span> </span>&#123; </span><br><span class="line">  <span class="comment">//参数变为了T1，T2，即参数模板化了，为了让编译器认识T1和T2，上边添加模板的语法</span></span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;	<span class="comment">//typeid(...).name()可以查看类型的名称，string类型的输出很长</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;  <span class="comment">//int类型只输出int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">  <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line">  <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li>
<li>使用比较广泛是第一种：指定传入的类型（第二三种 类模板配合函数模板，过于复杂）</li>
</ul>
<h3 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h3><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">  T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son2</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p>
<h3 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//成员函数类内声明</span></span><br><span class="line">  <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T1 m_Name;</span><br><span class="line">  T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> </span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123; <span class="comment">//模板参数列表&lt;T1,T2&gt;不能少</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123; <span class="comment">//模板参数列表&lt;T1,T2&gt;不能少</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p>
<h3 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h3><p>问题：当源文件引入test.h（声明），test.cpp（实现）也引入test.h时，编译运行时报错</p>
<p>原因：类模板中成员函数创建时机是在调用阶段，源文件只引入了.h文件，而.h文件不会去调用.cpp文件</p>
<p>解决：</p>
<ul>
<li>解决方式1：直接包含.cpp源文件（不常用）</li>
<li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li>
</ul>
<p><strong>示例：</strong></p>
<p>person.hpp中代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">//防止头文件重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  T1 m_Name;</span><br><span class="line">  T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将声明和实现写在一起</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类模板分文件编写.cpp中代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.cpp&quot; //解决方式1，包含cpp源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person&lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p>
<h3 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h3><p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现复杂且不常用，不作记录</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="comment">//1、全局函数配合友元 类内实现</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T1 m_Name;</span><br><span class="line">  T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person &lt;string, <span class="keyword">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h1><h2 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h2><ul>
<li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p>
</li>
<li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p>
</li>
<li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p>
</li>
<li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p>
</li>
</ul>
<h2 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h2><ul>
<li>STL(Standard Template Library,<strong>标准模板库</strong>)</li>
<li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li>
<li>STL 几乎所有的代码都采用了模板类或者模板函数</li>
</ul>
<h2 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h2><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p>
<ol>
<li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li>
<li>算法：各种常用的算法，如sort、find、copy、for_each等</li>
<li>迭代器：扮演了容器与算法之间的胶合剂。</li>
<li>仿函数：行为类似函数，可作为算法的某种策略。</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li>
<li>空间配置器：负责空间的配置与管理。</li>
</ol>
<h2 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h2><p><strong>容器：</strong>置物之所也</p>
<p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p>
<p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p>
<p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p>
<p>  <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>  <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p>
<p><strong>算法：</strong>问题之解法也</p>
<p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p>
<p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
<p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p>
<p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p>
<p><strong>迭代器：</strong>容器和算法之间粘合剂</p>
<p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p>
<p>每个容器都有自己专属的迭代器</p>
<p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p>
<p>迭代器种类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
<th>支持运算</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>对数据的只读访问</td>
<td>只读，支持++、==、！=</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>对数据的只写访问</td>
<td>只写，支持++</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>读写操作，并能向前推进迭代器</td>
<td>读写，支持++、==、！=</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>读写操作，并能向前和向后操作</td>
<td>读写，支持++、–，</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td>
<td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td>
</tr>
</tbody></table>
<p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p>
<h2 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h2><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p>
<p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p>
<h3 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h3><p>容器：     <code>vector</code></p>
<p>算法：     <code>for_each</code></p>
<p>迭代器： <code>vector&lt;int&gt;::iterator</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="comment">//向容器中放数据</span></span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line">  <span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line">  <span class="comment">//v.end() 返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line">  <span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一种遍历方式：</span></span><br><span class="line">  <span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">    cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">    pBegin++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二种遍历方式：</span></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第三种遍历方式：</span></span><br><span class="line">  <span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint); <span class="comment">//MyPrint是回调函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h3><blockquote>
<p>小技巧：迭代器可以视作指针，以==vector<Person>::iterator it==为例，&lt;&gt;内的部分是*it得到的数据类型</Person></p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    mName = name;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string mName;</span><br><span class="line">  <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">//由&lt;Person&gt;可知，*it得到的数据类型是Person</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">//由&lt;Person*&gt;可知，*it得到的数据类型是Person*，所以之后还要用-&gt;访问属性</span></span><br><span class="line">    Person * p = (*it);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h3><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">    v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">    v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">  v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="comment">//由&lt;vector&lt;int&gt;&gt;可知，*it得到的数据类型是vector&lt;int&gt;，所以之后还要进行一轮迭代</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">      cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h1><h2 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h2><h3 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h3><p><strong>本质：</strong></p>
<ul>
<li>string是C++风格的字符串，而string本质上是一个类</li>
</ul>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li>
</ul>
<p><strong>特点：</strong></p>
<p>string 类内部封装了很多成员方法</p>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h3 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h3><p>构造函数原型：</p>
<ul>
<li><code>string();</code>                            创建一个空的字符串 例如: string str;</li>
<li><code>string(const char* s);</code>         使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>   使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>         使用n个字符c初始化 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c语言风格string转换成了string</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;  <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>; <span class="comment">//10个a字符</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h3><p>功能描述：</p>
<ul>
<li>给string字符串进行赋值</li>
</ul>
<p>赋值的函数原型：</p>
<ul>
<li><code>string&amp; operator=(const char* s);</code>             char*类型字符串 赋值给当前的字符串</li>
<li><code>string&amp; operator=(const string &amp;s);</code>          把字符串s赋给当前的字符串</li>
<li><code>string&amp; operator=(char c);</code>                       字符赋值给当前的字符串</li>
<li><code>string&amp; assign(const char *s);</code>                 把字符串s赋给当前的字符串</li>
<li><code>string&amp; assign(const char *s, int n);</code>       把字符串s的前n个字符赋给当前的字符串</li>
<li><code>string&amp; assign(const string &amp;s);</code>               把字符串s赋给当前字符串</li>
<li><code>string&amp; assign(int n, char c);</code>                  用n个字符c赋给当前字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str1;</span><br><span class="line">  str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str2;</span><br><span class="line">  str2 = str1;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str3;</span><br><span class="line">  str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str4;</span><br><span class="line">  str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str5;</span><br><span class="line">  str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str6;</span><br><span class="line">  str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str7;</span><br><span class="line">  str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现在字符串末尾拼接字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; operator+=(const char* str);</code>                    重载+=操作符</li>
<li><code>string&amp; operator+=(const char c);</code>                         重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                  重载+=操作符</li>
<li><code>string&amp; append(const char *s); </code>                             把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                   把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>   字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">  str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">  str1 += str2;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">  str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">  str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="comment">//str3.append(str2);</span></span><br><span class="line">  str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int find(const string&amp; str, int pos = 0) const;</code>              查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const; </code>                    查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const; </code>                从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const; </code>                      查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>         查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>               查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>               从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;  </code>                     查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>          替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s); </code>                 替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">//3</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>); <span class="comment">//rfind是从字符串右侧开始找的</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl; <span class="comment">//7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//替换</span></span><br><span class="line">  string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">  str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl; <span class="comment">//a1111efgde</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>find查找是从左往后，rfind从右往左</li>
<li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li>
<li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li>
</ul>
<h3 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h3><p><strong>功能描述：</strong></p>
<ul>
<li>字符串之间的比较</li>
</ul>
<p><strong>比较方式：</strong></p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
</ul>
<p>= 返回   0</p>
<p>&gt; 返回   1 </p>
<p>&lt; 返回  -1</p>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>int compare(const string &amp;s) const; </code>    与字符串s比较</li>
<li><code>int compare(const char *s) const;</code>       与字符串s比较</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h3 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h3><p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n); </code>      通过[]方式取字符</li>
<li><code>char&amp; at(int n);   </code>                  通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字符修改</span></span><br><span class="line">  str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p>
<h3 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对string字符串进行插入和删除字符操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string&amp; insert(int pos, const char* s);  </code>                插入字符串</li>
<li><code>string&amp; insert(int pos, const string&amp; str); </code>          插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                   删除从Pos开始的n个字符 </li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p>
<h3 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h3><p><strong>功能描述：</strong></p>
<ul>
<li>从字符串中获取想要的子串</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>string substr(int pos = 0, int n = npos) const;</code>   返回由pos开始的n个字符组成的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">  string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">  string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos); <span class="comment">//获取用户名</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>
<h2 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h2><h3 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h3><p><strong>功能：</strong></p>
<ul>
<li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li>
</ul>
<p><strong>vector与普通数组区别：</strong></p>
<ul>
<li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li>
</ul>
<p><strong>动态扩展：</strong></p>
<ul>
<li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/08/24/hFMYdA.jpg" alt="说明: 2015-11-10_151152"></p>
<ul>
<li>vector容器的迭代器是支持随机访问的迭代器</li>
</ul>
<h3 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>创建vector容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&lt;T&gt; v; </code>                           采用模板实现类实现，默认构造函数</li>
<li><code>vector(v.begin(), v.end());   </code>      将v[begin(), end())区间中的元素拷贝给本身。</li>
<li><code>vector(n, elem);</code>                      构造函数将n个elem拷贝给本身。</li>
<li><code>vector(const vector &amp;vec);</code>        拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">v2</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v3);</span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">v4</span>(v3);</span><br><span class="line">  <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p>
<h3 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>给vector容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>vector&amp; operator=(const vector &amp;vec);</code>   重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>       将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>        将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;   <span class="comment">//无参构造</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">  v2 = v1;</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">  v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">  v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h3 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器的容量和大小操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>empty(); </code>                      判断容器是否为空</p>
</li>
<li><p><code>capacity();</code>                  容器的容量</p>
</li>
<li><p><code>size();</code>                        返回容器中元素的个数</p>
</li>
<li><p><code>resize(int num);</code>           重新指定容器的长度为num，若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
<li><p><code>resize(int num, elem);</code>  重新指定容器的长度为num，若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的元素被删除</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="keyword">if</span> (v1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resize 重新指定大小，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">  v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//resize 重新指定大小，若指定的更小，超出部分元素被删除</span></span><br><span class="line">  v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空  — empty</li>
<li>返回元素个数  — size</li>
<li>返回容器容量  — capacity</li>
<li>重新指定大小  —  resize</li>
</ul>
<h3 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对vector容器进行插入、删除操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(ele);</code>                                                  尾部插入元素ele</li>
<li><code>pop_back();</code>                                                        删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>                          迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>            迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                                   删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>   删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                             删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  <span class="comment">//尾插</span></span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="comment">//尾删</span></span><br><span class="line">  v1.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">  v1.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插  — push_back</li>
<li>尾删  — pop_back</li>
<li>插入  — insert    (位置迭代器)</li>
<li>删除  — erase  （位置迭代器）</li>
<li>清空  —  clear  </li>
</ul>
<h3 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对vector中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     返回索引idx所指的数据</li>
<li><code>operator[]; </code>       返回索引idx所指的数据</li>
<li><code>front(); </code>           返回容器中第一个数据元素</li>
<li><code>back();</code>             返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h3 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现两个容器内元素进行互换</li>
<li>实现内存收缩（见代码）</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>swap(vec);</code>   将vec与本身的元素互换</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//互换容器</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">  v1.<span class="built_in">swap</span>(v2);</span><br><span class="line">  <span class="built_in">printVector</span>(v1);</span><br><span class="line">  <span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//收缩内存：有时vector的容量很大，当使用resize将它的大小变得很小时，浪费了容量</span></span><br><span class="line">  <span class="comment">//此时应该将该vector和一个匿名的vector交换，交换后的vector的大小和容量相同，这一行执行完毕后，匿名vector被释放，达到收缩内存的目的</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//先创建匿名对象，再与原来的vector交换</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p>
<h3 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h3><p><strong>功能描述：</strong></p>
<ul>
<li>减少vector在动态扩展容量时的扩展次数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reserve(int len);</code>  容器预留len个元素长度，预留位置不初始化，元素不可访问。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//预留空间</span></span><br><span class="line">  v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">      p = &amp;v[<span class="number">0</span>];</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h2 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h2><h3 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h3><p><strong>功能：</strong></p>
<ul>
<li>双端数组，可以对头端进行插入删除操作</li>
</ul>
<p><strong>deque与vector区别：</strong></p>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对头部的插入删除速度回比vector快</li>
<li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li>
</ul>
<p><img src="https://z3.ax1x.com/2021/08/24/hkiHNF.jpg" alt="说明: 2015-11-19_204101"></p>
<p>deque内部工作原理:</p>
<p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img src="https://z3.ax1x.com/2021/08/24/hkibh4.jpg" alt="clip_image002-1547547896341"></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h3 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>deque容器构造</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&lt;T&gt; deqT</code>;                      默认构造形式</li>
<li><code>deque(beg, end);</code>                   构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                     构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>        拷贝构造函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line">  <span class="function">deque&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">  <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d4 = d3;</span><br><span class="line">  <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>给deque容器进行赋值</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>deque&amp; operator=(const deque &amp;deq); </code>       重载等号操作符</li>
</ul>
<ul>
<li><code>assign(beg, end);</code>                                 将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                   将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">  d2 = d1;</span><br><span class="line">  <span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">  d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">  d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对deque容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>deque.empty();</code>                   判断容器是否为空</p>
</li>
<li><p><code>deque.size();</code>                     返回容器中元素的个数</p>
</li>
<li><p><code>deque.resize(num);</code>              重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>deque.resize(num, elem);</code>     重新指定容器的长度为num,若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断容器是否为空</span></span><br><span class="line">  <span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//统计大小</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重新指定大小</span></span><br><span class="line">  d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">  d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>deque没有容量capacity的概念，和实现方式有关</li>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h3 id="3-3-5-deque插入和删除"><a href="#3-3-5-deque插入和删除" class="headerlink" title="3.3.5 deque插入和删除"></a>3.3.5 deque插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>向deque容器中插入和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<p>两端插入操作：</p>
<ul>
<li><code>push_back(elem);</code>          在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        在容器头部插入一个数据</li>
<li><code>pop_back();</code>                 删除容器最后一个数据</li>
<li><code>pop_front();</code>                删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li><p><code>insert(pos,elem);</code>         在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li><p><code>insert(pos,n,elem);</code>      在pos位置插入n个elem数据，无返回值。</p>
</li>
<li><p><code>insert(pos,beg,end);</code>     在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li><p><code>clear();</code>                      清空容器的所有数据</p>
</li>
<li><p><code>erase(beg,end);</code>            删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li><p><code>erase(pos);</code>                  删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  <span class="comment">//尾插</span></span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="comment">//头插</span></span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尾删</span></span><br><span class="line">  d.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="comment">//头删</span></span><br><span class="line">  d.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">  d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">  d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">  d.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入和删除提供的位置是迭代器！</li>
<li>尾插   —  push_back</li>
<li>尾删   —  pop_back</li>
<li>头插   —  push_front</li>
<li>头删   —  pop_front</li>
</ul>
<h3 id="3-3-6-deque数据存取"><a href="#3-3-6-deque数据存取" class="headerlink" title="3.3.6 deque数据存取"></a>3.3.6 deque数据存取</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对deque 中的数据的存取操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>at(int idx); </code>     返回索引idx所指的数据</li>
<li><code>operator[]; </code>       返回索引idx所指的数据</li>
<li><code>front(); </code>           返回容器中第一个数据元素</li>
<li><code>back();</code>             返回容器中最后一个数据元素</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h3 id="3-3-7-deque排序"><a href="#3-3-7-deque排序" class="headerlink" title="3.3.7  deque排序"></a>3.3.7  deque排序</h3><p><strong>功能描述：</strong></p>
<ul>
<li>利用算法实现对deque容器进行排序</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  对beg和end区间内元素进行排序</li>
<li>只要迭代器满足随机访问，就可以使用sort，所以vector也可以使用</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> deque&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (deque&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  deque&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">  <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h2><h3 id="3-5-1-stack常用接口"><a href="#3-5-1-stack常用接口" class="headerlink" title="3.5.1 stack常用接口"></a>3.5.1 stack常用接口</h3><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>stack&lt;T&gt; stk;</code>                             stack采用模板类实现， stack对象的默认构造形式</li>
<li><code>stack(const stack &amp;stk);</code>             拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>stack&amp; operator=(const stack &amp;stk);</code>     重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      向栈顶添加元素</li>
<li><code>pop();</code>             从栈顶移除第一个元素</li>
<li><code>top(); </code>             返回栈顶元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>          判断堆栈是否为空</li>
<li><code>size(); </code>            返回栈的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">  stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">  s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">//输出栈顶元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//弹出栈顶元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入栈   — push</li>
<li>出栈   — pop</li>
<li>返回栈顶   — top</li>
<li>判断栈是否为空   — empty</li>
<li>返回栈大小   — size</li>
</ul>
<h2 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h2><h3 id="3-6-1-queue常用接口"><a href="#3-6-1-queue常用接口" class="headerlink" title="3.6.1 queue常用接口"></a>3.6.1 queue常用接口</h3><p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                            queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>   重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>      往队尾添加元素</li>
<li><code>pop();</code>              从队头移除第一个元素</li>
<li><code>back();</code>            返回最后一个元素</li>
<li><code>front(); </code>           返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>           判断队列是否为空</li>
<li><code>size(); </code>             返回队列的大小</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建队列</span></span><br><span class="line">  queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//准备数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">  q.<span class="built_in">push</span>(p1);</span><br><span class="line">  q.<span class="built_in">push</span>(p2);</span><br><span class="line">  q.<span class="built_in">push</span>(p3);</span><br><span class="line">  q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//队列不提供迭代器，更不支持随机访问  </span></span><br><span class="line">  <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">//输出队头元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//弹出队头元素</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>入队   — push</li>
<li>出队   — pop</li>
<li>返回队头元素   — front</li>
<li>返回队尾元素   — back</li>
<li>判断队是否为空   — empty</li>
<li>返回队列大小   — size</li>
</ul>
<h2 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h2><h3 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h3><p><strong>功能：</strong>将数据进行链式存储</p>
<p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p>
<p>链表的组成：链表由一系列<strong>结点</strong>组成</p>
<p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p>
<p>STL中的链表是一个双向循环链表</p>
<p><img src="https://z3.ax1x.com/2021/08/25/hEe94x.jpg" alt="说明: 2015-11-15_225145"></p>
<p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p>
<p>list的优点：</p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
</ul>
<p>list的缺点：</p>
<ul>
<li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li>
</ul>
<p><strong>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</strong></p>
<p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p>
<h3 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>创建list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>list&lt;T&gt; lst;</code>                          list采用采用模板类实现,对象的默认构造形式：</li>
<li><code>list(beg,end);</code>                       构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                         构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            拷贝构造函数。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line">  <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-3-list赋值和交换"><a href="#3-7-3-list赋值和交换" class="headerlink" title="3.7.3 list赋值和交换"></a>3.7.3 list赋值和交换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>给list容器进行赋值，以及交换list容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>assign(beg, end);</code>                               将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                 将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>        重载等号操作符</li>
<li><code>swap(lst);</code>                                          将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">  L2 = L1;</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">  L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line">  <span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">  L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">  L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line">  <span class="built_in">printList</span>(L2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-4-list大小操作"><a href="#3-7-4-list大小操作" class="headerlink" title="3.7.4 list大小操作"></a>3.7.4 list大小操作</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器的大小进行操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>size(); </code>                      返回容器中元素的个数</p>
</li>
<li><p><code>empty(); </code>                     判断容器是否为空</p>
</li>
<li><p><code>resize(num);</code>               重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
<li><p><code>resize(num, elem); </code>      重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (L1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重新指定大小</span></span><br><span class="line">  L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">  L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>判断是否为空   — empty</li>
<li>返回元素个数   — size</li>
<li>重新指定个数   — resize</li>
</ul>
<h3 id="3-7-5-list插入和删除"><a href="#3-7-5-list插入和删除" class="headerlink" title="3.7.5 list插入和删除"></a>3.7.5 list插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器进行数据的插入和删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>push_back(elem);</code>           在容器尾部加入一个元素</li>
<li><code>pop_back(); </code>                  删除容器中最后一个元素</li>
<li><code>push_front(elem); </code>          在容器开头插入一个元素</li>
<li><code>pop_front();</code>                 从容器开头移除第一个元素</li>
<li><code>insert(pos,elem);</code>          在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li><code>insert(pos,n,elem);</code>       在pos位置插入n个elem数据，无返回值。</li>
<li><code>insert(pos,beg,end);</code>      在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li><code>clear();</code>                       移除容器的所有数据</li>
<li><code>erase(beg,end);</code>             删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li><code>erase(pos);</code>                   删除pos位置的数据，返回下一个数据的位置。</li>
<li><code>remove(elem);</code>                删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">  <span class="comment">//尾插</span></span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  <span class="comment">//头插</span></span><br><span class="line">  L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">  L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">  L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//尾删</span></span><br><span class="line">  L.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//头删</span></span><br><span class="line">  L.<span class="built_in">pop_front</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">  L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  it = L.<span class="built_in">begin</span>();</span><br><span class="line">  L.<span class="built_in">erase</span>(++it);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//移除</span></span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">  L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  L.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>尾插   — push_back</li>
<li>尾删   — pop_back</li>
<li>头插   — push_front</li>
<li>头删   — pop_front</li>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>移除   — remove</li>
<li>清空   — clear</li>
</ul>
<h3 id="3-7-6-list数据存取"><a href="#3-7-6-list数据存取" class="headerlink" title="3.7.6 list数据存取"></a>3.7.6 list数据存取</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对list容器中数据进行存取</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>front();</code>       返回第一个元素。</li>
<li><code>back();</code>         返回最后一个元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl; //错误 不支持at访问数据</span></span><br><span class="line">  <span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl;    //错误  不支持[]方式访问数据</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="comment">//it = it + 1; //错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   — front</li>
<li>返回最后一个元素   — back</li>
</ul>
<h3 id="3-7-7-list反转和排序"><a href="#3-7-7-list反转和排序" class="headerlink" title="3.7.7 list反转和排序"></a>3.7.7 list反转和排序</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将容器中的元素反转，以及将容器中的数据进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>reverse();</code>   反转链表</li>
<li><code>sort();</code>        链表排序</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> list&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (list&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  list&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反转容器的元素</span></span><br><span class="line">  L.<span class="built_in">reverse</span>();</span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//排序</span></span><br><span class="line">  L.<span class="built_in">sort</span>();          <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">  L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">  <span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>反转   — reverse</li>
<li>排序   — sort （成员函数）</li>
</ul>
<h3 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h3><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p>
<p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) &#123;</span><br><span class="line">    m_Name = name;</span><br><span class="line">    m_Age = age;</span><br><span class="line">    m_Height = height;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;  <span class="comment">//姓名</span></span><br><span class="line">  <span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line">  <span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line">    <span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">  L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li>
</ul>
<ul>
<li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li>
</ul>
<h2 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h2><h3 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h3><p><strong>简介：</strong></p>
<ul>
<li>所有元素都会在插入时自动被排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li>
</ul>
<p><strong>set和multiset区别</strong>：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h3 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h3><p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                     默认构造函数：</li>
<li><code>set(const set &amp;st);</code>        拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//拷贝构造</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line">  <span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">  s3 = s2;</span><br><span class="line">  <span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>set容器插入数据时用insert</li>
<li>set容器插入数据的数据会自动排序</li>
</ul>
<h3 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>统计set容器大小以及交换set容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>size();</code>          返回容器中元素的数目</li>
<li><code>empty();</code>         判断容器是否为空</li>
<li><code>swap(st);</code>        交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  </span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line">  <span class="built_in">printSet</span>(s2);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">  s1.<span class="built_in">swap</span>(s2);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line">  <span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h3 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>set容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>            在容器中插入元素。</li>
<li><code>clear();</code>                   清除所有元素</li>
<li><code>erase(pos);</code>               删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>        删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(elem);</code>              删除容器中值为elem的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="keyword">int</span>&gt; &amp; s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  <span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">  s1.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>插入   — insert</li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h3 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对set容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>            查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>           统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//统计</span></span><br><span class="line">  <span class="keyword">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于set，结果为0或者1）</li>
</ul>
<h3 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h3><p><strong>区别：</strong></p>
<ul>
<li>set不可以插入重复数据，而multiset可以</li>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  pair&lt;set&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>); <span class="comment">// set插入后会返回pair，pair的第二个参数是判断插入是否成功的布尔值</span></span><br><span class="line">  <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//multiset</span></span><br><span class="line">  multiset&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">  ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (multiset&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>如果不允许插入重复数据可以利用set</li>
<li>如果需要插入重复数据利用multiset</li>
</ul>
<h3 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h3><p><strong>功能描述：</strong></p>
<ul>
<li>成对出现的数据，利用对组可以返回两个数据</li>
</ul>
<p><strong>两种创建方式：</strong></p>
<ul>
<li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">pair&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  pair&lt;string, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h3><p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例一</strong>   set存放内置数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123; <span class="comment">//重载()，仿函数</span></span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">  set&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认从小到大</span></span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指定排序规则</span></span><br><span class="line">  set&lt;<span class="keyword">int</span>,MyCompare&gt; s2; <span class="comment">//将MyCompare类作为第二个参数传入</span></span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">  s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (set&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123; <span class="comment">//将MyCompare类作为第二个参数传入</span></span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：利用仿函数可以指定set容器的排序规则</p>
<p><strong>示例二</strong> set存放自定义数据类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span> &#123;</span> <span class="comment">//重载()，仿函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照年龄进行降序排序</span></span><br><span class="line">    <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  set&lt;Person, comparePerson&gt; s; <span class="comment">//将comparePerson类作为第二个参数传入</span></span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">insert</span>(p1);</span><br><span class="line">  s.<span class="built_in">insert</span>(p2);</span><br><span class="line">  s.<span class="built_in">insert</span>(p3);</span><br><span class="line">  s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123; <span class="comment">//将comparePerson类作为第二个参数传入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h2 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h2><h3 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h3><p><strong>简介：</strong></p>
<ul>
<li>map中所有元素都是pair</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的<strong>键值</strong>自动排序</li>
</ul>
<p><strong>本质：</strong></p>
<ul>
<li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
<p>map和multimap<strong>区别</strong>：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h3 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行构造和赋值操作</li>
</ul>
<p><strong>函数原型：</strong></p>
<p><strong>构造：</strong></p>
<ul>
<li><code>map&lt;T1, T2&gt; mp;</code>            map默认构造函数:</li>
<li><code>map(const map &amp;mp);</code>       拷贝构造函数</li>
</ul>
<p><strong>赋值：</strong></p>
<ul>
<li><code>map&amp; operator=(const map &amp;mp);</code>    重载等号操作符</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line">  <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">  m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">  <span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p>
<h3 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h3><p><strong>功能描述：</strong></p>
<ul>
<li>统计map容器大小以及交换map容器</li>
</ul>
<p>函数原型：</p>
<ul>
<li><code>size();</code>          返回容器中元素的数目</li>
<li><code>empty();</code>         判断容器是否为空</li>
<li><code>swap(st);</code>       交换两个集合容器</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">  m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">  m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">  m2.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line">  <span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">  m.<span class="built_in">swap</span>(m2);</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line">  <span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>统计大小   — size</li>
<li>判断是否为空   — empty</li>
<li>交换容器   — swap</li>
</ul>
<h3 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h3><p><strong>功能描述：</strong></p>
<ul>
<li>map容器进行插入数据和删除数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>insert(elem);</code>           在容器中插入元素。</li>
<li><code>clear();</code>                  清除所有元素</li>
<li><code>erase(pos);</code>              删除pos迭代器所指的元素，返回下一个元素的迭代器。</li>
<li><code>erase(beg, end);</code>       删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li>
<li><code>erase(key);</code>              删除容器中值为key的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//插入</span></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">  <span class="comment">//第一种插入方式</span></span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  <span class="comment">//第二种插入方式</span></span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  <span class="comment">//第三种插入方式</span></span><br><span class="line">  m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">  <span class="comment">//第四种插入方式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果用这种方式访问了不存在的键名，键会被自动创建，键值为0</span></span><br><span class="line">  m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除</span></span><br><span class="line">  m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清空</span></span><br><span class="line">  m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">  m.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>map插入方式很多，记住其一即可</li>
</ul>
<ul>
<li>插入   — insert </li>
<li>删除   — erase</li>
<li>清空   — clear</li>
</ul>
<h3 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对map容器进行查找数据以及统计数据</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>find(key);</code>               查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li>
<li><code>count(key);</code>             统计key的元素个数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找</span></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pos != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//统计</span></span><br><span class="line">  <span class="keyword">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>查找   —  find    （返回的是迭代器）</li>
<li>统计   —  count  （对于map，结果为0或者1）</li>
</ul>
<h3 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h3><p><strong>学习目标：</strong></p>
<ul>
<li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li>
</ul>
<p><strong>主要技术点:</strong></p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//默认从小到大排序</span></span><br><span class="line">  <span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">  map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m; <span class="comment">//将MyCompare类作为第三个参数传入</span></span><br><span class="line"></span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">  m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123; <span class="comment">//将MyCompare类作为第三个参数传入</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>利用仿函数可以指定map容器的排序规则</li>
<li>对于自定义数据类型，map必须要指定排序规则，同set容器</li>
</ul>
<h1 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h1><h2 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h2><h3 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h3><p><strong>概念：</strong></p>
<ul>
<li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li>
<li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li>
</ul>
<p><strong>本质：</strong></p>
<p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p>
<h3 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h3><p><strong>特点：</strong></p>
<ul>
<li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li>
<li><strong>函数对象超出普通函数的概念，函数对象可以有自己的状态</strong></li>
<li><strong>函数对象可以作为参数传递</strong></li>
</ul>
<p><strong>示例:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyAdd myAdd;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyPrint</span>() &#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    count++; <span class="comment">//统计使用次数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyPrint myPrint;</span><br><span class="line">  <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyPrint myPrint;</span><br><span class="line">  <span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line">  <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h2><h3 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h3><p><strong>概念：</strong></p>
<ul>
<li>返回bool类型的仿函数称为<strong>谓词</strong></li>
<li>如果operator()接受一个参数，那么叫做一元谓词</li>
<li>如果operator()接受两个参数，那么叫做二元谓词</li>
</ul>
<h3 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());   <span class="comment">//find_if的第三个参数要求传入函数对象，它的返回值是迭代器</span></span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h3><p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//默认从小到大</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>()); <span class="comment">//第三个参数传入函数对象</span></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h2><h3 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h3><p><strong>概念：</strong></p>
<ul>
<li>STL内建了一些函数对象</li>
</ul>
<p><strong>分类:</strong></p>
<ul>
<li><p>算术仿函数</p>
</li>
<li><p>关系仿函数</p>
</li>
<li><p>逻辑仿函数</p>
</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li>
</ul>
<h3 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现四则运算</li>
<li>其中negate是一元运算，其他都是二元运算</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>               加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>       乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>           除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>           取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>             取反仿函数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p>
<h3 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现关系对比</li>
</ul>
<p><strong>仿函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    等于</li>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>              不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                     大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>            大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                         小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>                 小于等于</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//STL内建仿函数——大于仿函数</span></span><br><span class="line">  <span class="comment">//在前面，第三个参数是自己写了MyCompare再传入的，也可以使用STL提供的大于仿函数</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p>
<h3 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现逻辑运算</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              逻辑与</li>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              逻辑非</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">  v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">//搬运之前必须提前开辟空间，见5.1.2</span></span><br><span class="line">  <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), logical_not&lt;<span class="keyword">bool</span>&gt;()); <span class="comment">//transform是遍历函数，搬运过去的时候顺便执行逻辑非运算</span></span><br><span class="line">  <span class="keyword">for</span> (vector&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<h1 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h1><p><strong>概述</strong>:</p>
<ul>
<li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li>
</ul>
<ul>
<li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h2 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>for_each</code>     遍历容器</li>
<li><code>transform</code>    搬运容器到另一个容器中</li>
</ul>
<h3 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h3><p><strong>功能描述：</strong></p>
<ul>
<li>实现遍历容器</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>for_each(iterator beg, iterator end, _func);  </code></p>
<p>遍历算法 遍历容器元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历算法</span></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p>
<h3 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h3><p><strong>功能描述：</strong></p>
<ul>
<li>搬运容器到另一个容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></p>
<p>beg1 源容器开始迭代器</p>
<p>end1 源容器结束迭代器</p>
<p>beg2 目标容器开始迭代器</p>
<p>_func 函数或者函数对象</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在搬过去时可以对每个数进行处理</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">  vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p>
<h2 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>find</code>                     查找元素</li>
<li><code>find_if</code>                 按条件查找元素</li>
<li><code>adjacent_find</code>         查找相邻重复元素</li>
<li><code>binary_search</code>         二分查找法</li>
<li><code>count</code>                    统计元素个数</li>
<li><code>count_if</code>                按条件统计元素个数</li>
</ul>
<h3 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find(iterator beg, iterator end, value);  </code></p>
<p> 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p> beg 开始迭代器</p>
<p> end 结束迭代器</p>
<p> value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">// 第三个参数直接传入5</span></span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重载==</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">  vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p>
<h3 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h3><p><strong>功能描述：</strong></p>
<ul>
<li>按条件查找元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p>
<p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_Pred 函数或者谓词（返回bool类型的仿函数）</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>()); <span class="comment">// 第三个参数传入函数体</span></span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建数据</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">  vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h3 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找相邻重复元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>adjacent_find(iterator beg, iterator end);  </code></p>
<p>查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找相邻重复元素</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h3><p><strong>功能描述：</strong></p>
<ul>
<li>查找指定元素是否存在</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p>
<p>查找指定的元素，查到 返回true  否则false，注意: 在<strong>无序序列中不可用</strong></p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 查找的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//二分查找</span></span><br><span class="line">  <span class="keyword">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h3><p><strong>功能描述：</strong></p>
<ul>
<li>统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count(iterator beg, iterator end, value);  </code></p>
<p>统计元素出现次数</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 统计的元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重载==</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//先插入容器</span></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p); <span class="comment">//查找和诸葛亮年龄相同的人数</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p>
<h3 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h3><p><strong>功能描述：</strong></p>
<ul>
<li>按条件统计元素个数</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p>
<p>按条件统计元素出现次数</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_Pred 谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>()); <span class="comment">//第三个参数传入函数体</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">  v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>()); <span class="comment">//第三个参数传入函数体</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p>
<h2 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>sort</code>             //对容器内元素进行排序</li>
<li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       // 反转指定范围的元素</li>
</ul>
<h3 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h3><p><strong>功能描述：</strong></p>
<ul>
<li>对容器内元素进行排序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p>
<p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>beg    开始迭代器</p>
<p>end    结束迭代器</p>
<p>_Pred  谓词</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sort默认从小到大排序</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从大到小排序</span></span><br><span class="line">  <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p>
<h3 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h3><p><strong>功能描述：</strong></p>
<ul>
<li>洗牌，指定范围内的元素随机调整次序</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>random_shuffle(iterator beg, iterator end);  </code></p>
<p>指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">srand</span>((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//根据系统的时间，随机生成种子，每次的排列顺序都不同</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打乱顺序</span></span><br><span class="line">  <span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h3 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h3><p><strong>功能描述：</strong></p>
<ul>
<li>两个容器元素合并，并存储到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>容器元素合并，并存储到另一容器中，注意: 两个容器必须是<strong>有序的</strong></p>
<p>beg1   容器1开始迭代器<br>end1   容器1结束迭代器<br>beg2   容器2开始迭代器<br>end2   容器2结束迭代器<br>dest    目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line">  <span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">  vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">  <span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">  for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p>
<h3 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内元素进行反转</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>reverse(iterator beg, iterator end);  </code></p>
<p>反转指定范围的元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>reverse反转区间内元素</p>
<h2 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><code>copy</code>                      容器内指定范围的元素拷贝到另一容器中</li>
<li><code>replace</code>                  将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if </code>              容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                      互换两个容器的元素</li>
</ul>
<h3 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h3><p><strong>功能描述：</strong></p>
<ul>
<li>容器内指定范围的元素拷贝到另一容器中</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p>
<p>按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>beg  开始迭代器</p>
<p>end  结束迭代器</p>
<p>dest 目标起始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">  <span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">  for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间。copy不常用，拷贝都在构造时用=</p>
<h3 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h3><p><strong>功能描述：</strong></p>
<ul>
<li>将容器内指定范围的旧元素修改为新元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p>
<p>将区间内旧元素 替换成 新元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>oldvalue 旧元素</p>
<p>newvalue 新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace会替换区间内满足条件的元素</p>
<h3 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h3><p><strong>功能描述:</strong>  </p>
<ul>
<li>将区间内满足条件的元素，替换成指定元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p>
<p>按条件替换元素，满足条件的替换成指定元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>_pred 谓词</p>
<p>newvalue 替换的新元素</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h3 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h3><p><strong>功能描述：</strong></p>
<ul>
<li>互换两个容器的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>swap(container c1, container c2);  </code></p>
<p>互换两个容器的元素</p>
<p>c1容器1</p>
<p>c2容器2</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">swap</span>(v1, v2);</span><br><span class="line">  for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">  for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>swap交换容器时，注意交换的<strong>容器要同种类型</strong></p>
<h2 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h2><p><strong>注意：</strong></p>
<ul>
<li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li>
</ul>
<p><strong>算法简介：</strong></p>
<ul>
<li><p><code>accumulate</code>      计算容器元素累计总和</p>
</li>
<li><p><code>fill</code>               向容器中添加元素</p>
</li>
</ul>
<h3 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h3><p><strong>功能描述：</strong></p>
<ul>
<li> 计算区间内 容器元素累计总和</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>accumulate(iterator beg, iterator end, value);  </code></p>
<p>计算容器元素累计总和</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 起始值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//起始值为0</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>accumulate使用时头文件注意是 numeric</p>
<h3 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h3><p><strong>功能描述：</strong></p>
<ul>
<li>向容器中填充指定的元素</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>fill(iterator beg, iterator end, value);  </code></p>
<p>向容器中填充元素</p>
<p>beg 开始迭代器</p>
<p>end 结束迭代器</p>
<p>value 填充的值</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="comment">//填充</span></span><br><span class="line">  <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>利用fill可以将容器区间内元素填充为指定的值</p>
<h2 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h2><p><strong>算法简介：</strong></p>
<ul>
<li><p><code>set_intersection</code>         求两个容器的交集</p>
</li>
<li><p><code>set_union</code>                   求两个容器的并集</p>
</li>
<li><p><code>set_difference </code>            求两个容器的差集</p>
</li>
</ul>
<h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个容器的交集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>求两个集合的交j集，<strong>注意：两个集合必须是有序序列</strong></p>
<p>beg1 容器1开始迭代器<br>end1 容器1结束迭代器<br>beg2 容器2开始迭代器<br>end2 容器2结束迭代器<br>dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">  <span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">  vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>()); <span class="comment">//itEnd作为第二个参数</span></span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li>
<li>set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的并集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>求两个集合的并集，<strong>注意:两个集合必须是有序序列</strong></p>
<p>beg1 容器1开始迭代器<br>end1 容器1结束迭代器<br>beg2 容器2开始迭代器<br>end2 容器2结束迭代器<br>dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">  <span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">  vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要<strong>两个容器相加</strong></li>
<li>set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p>
<ul>
<li>求两个集合的差集</li>
</ul>
<p><strong>函数原型：</strong></p>
<ul>
<li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p>
<p>求两个集合的差集，<strong>注意:两个集合必须是有序序列</strong></p>
<p>beg1 容器1开始迭代器<br>end1 容器1结束迭代器<br>beg2 容器2开始迭代器<br>end2 容器2结束迭代器<br>dest 目标容器开始迭代器</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line">  <span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">  vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt;::iterator itEnd = <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">  for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li>
<li>set_difference返回值既是差集中最后一个元素的位置</li>
</ul>
<h2 id="5-7-其他算法"><a href="#5-7-其他算法" class="headerlink" title="5.7 其他算法"></a>5.7 其他算法</h2><p>min，max函数需要包含<code>&lt;algorithm&gt;</code>头文件</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2021/08/22/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="commonjs"><a href="#commonjs" class="headerlink" title="commonjs"></a>commonjs</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。<strong>在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</strong></p>
<p>由上可知，（在服务器端）模块的依赖关系是在运行时确定的。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h2 id="暴露"><a href="#暴露" class="headerlink" title="暴露"></a>暴露</h2><p>每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性是对外的接口。<strong>加载某个模块，其实是加载该模块的 module.exports 属性</strong>。</p>
<p>require 用于加载模块文件。<strong>基本功能是读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。如果没有发现指定模块，会报错</strong>。</p>
<h2 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h2><p><strong>输入的是被输出的值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值</strong>。比如模块 A 输出了一个 number 和增加该 number 的方法，在模块 B 中引入它们，并调用该方法，发现 number 的值并没有增加。</p>
<h1 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>
<p>两者的区别：</p>
<ol>
<li><strong>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。因此上边 number 的值会增加。</li>
<li><strong>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。因为 CommonJS 加载的是一个对象（module.exports），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</li>
<li>require 是同步加载，import 是异步加载，更准确地说，<strong>ES6 模块有一个独立的静态解析阶段，依赖关系的分析在该阶段完成，最底层的模块第一个执行。</strong>require 不支持 ES6 的一个原因便是，它是同步加载，而 ES6 内部可以使用顶层 await 命令，导致无法被同步加载。</li>
</ol>
<h2 id="导入导出方式"><a href="#导入导出方式" class="headerlink" title="导入导出方式"></a>导入导出方式</h2><ul>
<li><p>命名导出：导出的数据带 name，统一引入需要 { }。</p>
</li>
<li><p>别名引入：import { cym as Danmo } from ‘…’。</p>
</li>
<li><p>命名空间引入：import * as Danmo from ‘…’，比如原文件下定义了 learn 、play 等方法，我们指定命名空间叫 Danmo，引入后通过 Danmo.learn、Danmo.play 来调用它们，避免使用大量别名引入。</p>
</li>
<li><p>默认导入导出，export default 并且引入无需 { }，引入的是 <code>import &#123; default as Danmo&#125; from &#39;...&#39;</code> 的缩写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样导出的话，import Danmo from &#x27;...&#x27;，方法的使用和命名空间引入一致</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  learn () &#123;&#125;,</span><br><span class="line">  play () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="more-about-ES6-module"><a href="#more-about-ES6-module" class="headerlink" title="more about ES6 module"></a>more about ES6 module</h1><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><blockquote>
<p>You need to pay attention to local testing — if you try to load the HTML file locally (i.e. with a <code>file://</code> URL), you’ll run into CORS errors due to JavaScript module security requirements. You need to do your testing through a server.</p>
</blockquote>
<p>如果使用 <code> &lt;script type=&quot;module&quot;&gt;</code> 将默认启用跨域访问，不能在本地测试，需要通过 server，否则 CORS 报错。</p>
<blockquote>
<p>Also, note that you might get different behavior from sections of script defined inside modules as opposed to in standard scripts. This is because modules use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a> automatically.</p>
</blockquote>
<p>模块自动开启严格模式。</p>
<blockquote>
<p>There is no need to use the <code>defer</code> attribute (see <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attributes">`` attributes</a>) when loading a module script; modules are deferred automatically.</p>
</blockquote>
<p>模块自动开启 defer。</p>
<blockquote>
<p>You will only be able to access imported features in the script they are imported into, and you won’t be able to access them from the JavaScript console.</p>
</blockquote>
<p>引入的模块不能在控制台中访问。</p>
<h2 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h2><p>把多个子模块的导出汇集到一个文件中，可以 <code>export &lt;sth.&gt; form &lt;path&gt;</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules/</span><br><span class="line">  canvas.js</span><br><span class="line">  shapes.js</span><br><span class="line">  shapes/</span><br><span class="line">    circle.js</span><br><span class="line">    square.js</span><br><span class="line">    triangle.js</span><br></pre></td></tr></table></figure>

<p>每个子模块的导出方式如：<code>export &#123; Square &#125;</code>。</p>
<p>在 /modules 下新建 shapes.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; Square &#125; <span class="keyword">from</span> <span class="string">&#x27;./shapes/square.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; Triangle &#125; <span class="keyword">from</span> <span class="string">&#x27;./shapes/triangle.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; Circle &#125; <span class="keyword">from</span> <span class="string">&#x27;./shapes/circle.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 shapes.js 导入：</span></span><br><span class="line"><span class="keyword">import</span> &#123; Square, Circle, Triangle &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/shapes.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Dynamic-module"><a href="#Dynamic-module" class="headerlink" title="Dynamic module"></a>Dynamic module</h2><blockquote>
<p>A recent addition to JavaScript modules functionality is dynamic module loading. This allows you to dynamically load modules only when they are needed, rather than having to load everything up front.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">squareBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;./modules/square.js&#x27;</span>).then(<span class="function">(<span class="params">Module</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 可以获取 Module Object，从而得到其导出成员</span></span><br><span class="line">    <span class="keyword">const</span> square1 = <span class="keyword">new</span> Module.Square(myCanvas.ctx, myCanvas.listId, <span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    square1.draw();</span><br><span class="line">    square1.reportArea();</span><br><span class="line">    square1.reportPerimeter();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Top-level-await"><a href="#Top-level-await" class="headerlink" title="Top level await"></a>Top level await</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getColors.js</span></span><br><span class="line"><span class="keyword">const</span> colors = fetch(<span class="string">&#x27;../data/colors.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json());</span><br><span class="line"></span><br><span class="line"><span class="comment">// top level await</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">await</span> colors;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>We’re using the keyword <code>await</code> before specifying the constant <code>colors</code> to export. <strong>This means any other modules which include this one will wait until <code>colors</code> has been downloaded and parsed before using it.</strong></p>
<p>However it won’t block other modules being loaded. For instance our <code>canvas.js</code> continue to load while <code>colors</code> is being fetched.</p>
</blockquote>
<p>其他模块如果引入了 getColors.js，需要等待 fetch 请求得到 colors。对于没有引入 getColors.js 的模块，不受影响。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.cn/post/6844903744518389768#heading-25">前端模块化详解</a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript modules —— MDN</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2020/08/how-nodejs-use-es6-module.html">Node.js 如何处理 ES6 模块</a>：讲解了 CommonJS 和 ES6 模块的加载问题，推荐阅读。</p>
<p><a href="https://segmentfault.com/q/1010000009891745">ES6 import 后缀名问题</a>：讲解了什么时候 import 需要拓展名，什么时候不需要。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ 面向对象</title>
    <url>/2021/08/19/c++%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>已有c的基础，故只记录了以前没学过的部分：</p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1 Hello World"></a>1 Hello World</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-输出变量"><a href="#2-输出变量" class="headerlink" title="2 输出变量"></a>2 输出变量</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a =&quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// a = 10</span></span><br></pre></td></tr></table></figure>

<h2 id="3-关键字"><a href="#3-关键字" class="headerlink" title="3 关键字"></a>3 关键字</h2><table>
<thead>
<tr>
<th>asm</th>
<th>do</th>
<th>if</th>
<th>return</th>
<th>typedef</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typeid</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typename</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>union</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>unsigned</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>using</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>virtual</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>void</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>volatile</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>wchar_t</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>while</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>try</td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4 数据类型"></a>4 数据类型</h2><h3 id="4-1-转义"><a href="#4-1-转义" class="headerlink" title="4.1 转义"></a>4.1 转义</h3><table>
<thead>
<tr>
<th><strong>转义字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>ASCII</strong>码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>警报</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td>
<td><strong>010</strong></td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>水平制表(HT)  （跳到下一个TAB位置）</strong></td>
<td><strong>009</strong></td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>*<em>\\*</em></td>
<td><strong>代表一个反斜线字符”&quot;</strong></td>
<td><strong>092</strong></td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>数字0</td>
<td>000</td>
</tr>
<tr>
<td>\ddd</td>
<td>8进制转义字符，d范围0~7</td>
<td>3位8进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td>
<td>3位16进制</td>
</tr>
</tbody></table>
<h3 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h3><p><strong>C++风格字符串</strong>：  <code>string  变量名 = &quot;字符串值&quot;</code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==（经过测试，不加也可以运行）</p>
</blockquote>
<h3 id="4-3-布尔"><a href="#4-3-布尔" class="headerlink" title="4.3 布尔"></a>4.3 布尔</h3><p><strong>bool类型占==1个字节==大小</strong></p>
<h3 id="4-4-数据的输入"><a href="#4-4-数据的输入" class="headerlink" title="4.4 数据的输入"></a>4.4 数据的输入</h3><p><strong>作用：用于从键盘获取数据</strong></p>
<p><strong>关键字：</strong>cin</p>
<p><strong>语法：</strong> <code>cin &gt;&gt; 变量 </code></p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//整型输入</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; a;</span><br><span class="line">  cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//浮点型输入</span></span><br><span class="line">  <span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; d;</span><br><span class="line">  cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字符型输入</span></span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; ch;</span><br><span class="line">  cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//字符串型输入</span></span><br><span class="line">  string str;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cin &gt;&gt; str;</span><br><span class="line">  cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//布尔类型输入</span></span><br><span class="line">  <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="comment">// 测试时输入一个数，输入0时输出0，输入非0时输出1</span></span><br><span class="line">  <span class="comment">// 如果输入的是true或false，得到的输出都为0</span></span><br><span class="line">  cin &gt;&gt; flag;</span><br><span class="line">  cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p>
<h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p>
<ul>
<li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li>
<li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li>
</ul>
<p><strong>内存四区意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p>
<h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>  在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p>
<p>  <strong>代码区：</strong></p>
<p>​    存放 CPU 执行的机器指令</p>
<p>​    代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>​    代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p>
<p>  <strong>全局区：</strong></p>
<p>​    全局变量和静态变量存放在此.</p>
<p>​    全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p>
<p>​    ==该区域的数据在程序结束后由操作系统释放==.</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//局部变量</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//打印地址</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="keyword">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="keyword">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<img src="https://z3.ax1x.com/2021/08/19/fHLqPO.png" alt="1545017602518" style="zoom: 80%;">



<p>总结：</p>
<ul>
<li>C++中在程序运行前分为全局区和代码区</li>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放 const修饰的全局常量  和 字符串常量</li>
</ul>
<h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p><strong>栈区：</strong></p>
<p>​    由编译器自动分配释放, 存放函数的参数值,局部变量等</p>
<p>​    注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆区：</strong></p>
<p>​    由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p>
<p>​    在C++中主要利用new在堆区开辟内存</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>堆区数据由程序员管理开辟和释放</p>
<p>堆区数据利用new关键字进行开辟内存</p>
<h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>  C++中利用==new==操作符在堆区开辟数据</p>
<p>  堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p>
<p>  语法：<code> new 数据类型</code></p>
<p>  利用new创建的数据，会返回该数据对应的类型的==指针==</p>
<p><strong>示例1： 基本语法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>* a = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用delete释放堆区数据</span></span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>示例2：开辟数组</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    arr[i] = i + <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line">  <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p>**作用： **给变量起别名</p>
<p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line">  <span class="keyword">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">  c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p>
<p><strong>优点：</strong>可以简化指针修改实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap02</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap03</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = a;</span><br><span class="line">  a = b;</span><br><span class="line">  b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p>
</blockquote>
<h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：<strong>不要返回局部变量引用</strong></p>
<p>用法：函数调用作为左值</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//不能返回局部变量的引用</span></span><br><span class="line">  <span class="keyword">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line">  <span class="keyword">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p>
<p>讲解示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">  ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line">  <span class="keyword">int</span>&amp; ref = a; </span><br><span class="line">  ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">func</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p>
<h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p>
<p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showValue</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//v += 10;</span></span><br><span class="line">  cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line">  <span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">  cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p>
<p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>, <span class="keyword">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p>
<p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p><strong>作用：</strong>函数名可以相同，提高复用性</p>
<p><strong>函数重载满足条件：</strong></p>
<ul>
<li>同一个作用域下</li>
<li>函数名称相同</li>
<li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong> （避免歧义，编译器就不会迷惑）</li>
</ul>
<blockquote>
<p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> a ,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul>
<li>引用作为重载条件</li>
<li>函数重载碰到函数默认参数</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line">  <span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：==封装、继承、多态==</p>
<p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p>
<p>具有相同性质的==对象==，可以抽象称为==类==</p>
<h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li>将属性和行为作为一个整体，表现生活中的事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>封装意义一：</strong></p>
<p>  在设计类的时候，属性和行为写在一起，表现事物</p>
<p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p>
<p><strong>示例1：</strong>设计一个圆类，求圆的周长</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//属性</span></span><br><span class="line">  <span class="keyword">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//行为</span></span><br><span class="line">  <span class="comment">//获取到圆的周长</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">calculateZC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2 * pi  * r</span></span><br><span class="line">    <span class="comment">//获取圆的周长</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line">  <span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">  Circle c1;</span><br><span class="line">  c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>封装意义二：</strong></p>
<p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ol>
<li>public        公共权限  </li>
<li>protected  保护权限</li>
<li>private      私有权限</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问 子类可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问 子类不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_Name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  string m_Car;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">    m_Password = <span class="number">123456</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">  p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">  <span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line">  <span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p>
<p>区别：</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class   默认权限为私有</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  C1 c1;</span><br><span class="line">  c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">  C2 c2;</span><br><span class="line">  c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p>
<p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">//姓名设置可读可写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">    m_Name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取年龄 </span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置年龄</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_Age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情人设置为只写</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">    m_Lover = lover;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">  string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Person p;</span><br><span class="line">  <span class="comment">//姓名设置</span></span><br><span class="line">  p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//年龄设置</span></span><br><span class="line">  p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情人设置</span></span><br><span class="line">  p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line">  <span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul>
<li> 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li>
<li> C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li>
</ul>
<h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p>
<p>  一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>  同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p>
<p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li>
<li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li>
</ul>
<p><strong>构造函数语法：</strong> <code>类名()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值也不写void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li>
</ol>
<p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值也不写void</li>
<li>函数名称与类名相同,在名称前加上符号  ~</li>
<li>析构函数不可以有参数，因此不可以发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p>
<p>  按参数分为： 有参构造和无参构造</p>
<p>  按类型分为： 普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>  括号法</p>
<p>  显示法</p>
<p>  隐式转换法</p>
<p>注意事项：</p>
<p>  显示法中，如果只写等号右侧的部分，则是一个匿名对象，当前行执行完毕后立刻析构</p>
<p>  不能利用<code>拷贝构造函数</code>初始化匿名对象，编译器会认为是对象声明</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有参构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    age = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    age = p.age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.1  括号法，常用</span></span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line">  <span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.2 显式法</span></span><br><span class="line">  Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">  Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line">  <span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2.3 隐式转换法</span></span><br><span class="line">  Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">  Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">  <span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值方式返回局部对象</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mAge = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mAge = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    mAge = p.mAge;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line">  <span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">  Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Person newman3;</span></span><br><span class="line">  <span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Person p; <span class="comment">//无参构造函数</span></span><br><span class="line">  <span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Person p1;</span><br><span class="line">  cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">  cout &lt;&lt; (<span class="keyword">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line">  <span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<p>1．默认构造函数(无参，函数体为空)</p>
<p>2．默认析构函数(无参，函数体为空)</p>
<p>3．默认拷贝构造函数，对属性进行值拷贝</p>
<p><strong>结论：</strong></p>
<p>构造函数调用规则如下：</p>
<ul>
<li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li>
</ul>
<ul>
<li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li>
</ul>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有参构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    age = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    age = p.age;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//析构函数</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">  <span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">  Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">  Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">  <span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line">  <span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p>浅拷贝的问题：如果不提供拷贝构造函数，编译器提供的拷贝函数使用浅拷贝，如果有在堆区开辟的属性，会出现内存重复释放问题。</p>
<p>此处的场景：p1通过有参构造函数构造，p2由p1拷贝得到，它们都是局部变量，根据栈先进后出的原则，p2会先被析构函数释放，于是堆区0x0011被清空，在此之后p1被析构函数释放时，会再次对堆区0x0011进行清空，但此时堆区0x0011不具有清空的权限，就会报错。</p>
<p>所以p2应当使用深拷贝（必须自己提供拷贝函数），在拷贝时再开辟一片空间来保存m_Height</p>
<img src="https://z3.ax1x.com/2021/08/20/fLjZYq.png" style="zoom: 67%;">

<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//无参（默认）构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//有参构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age ,<span class="keyword">int</span> height) &#123;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    m_age = age;</span><br><span class="line">    m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(height);</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数  </span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">    m_age = p.m_age;</span><br><span class="line">    m_height = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_height);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//析构函数，用于释放堆区</span></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_height;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_age;</span><br><span class="line">  <span class="keyword">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p>
</blockquote>
<h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p>
<p>C++提供了初始化列表语法，用来初始化属性</p>
<p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">////传统方式初始化</span></span><br><span class="line">  <span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line">  <span class="comment">//  m_A = a;</span></span><br><span class="line">  <span class="comment">//  m_B = b;</span></span><br><span class="line">  <span class="comment">//  m_C = c;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化列表方式初始化</span></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>B类中有对象A作为成员，A为对象成员</p>
<p>创建B对象时，A与B的构造顺序：==先A后B（先零件后整体）==，析构与之相反</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Phone</span>(string name) &#123;</span><br><span class="line">    m_PhoneName = name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_PhoneName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line">  <span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line">  <span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line">  <span class="comment">//析构顺序与构造相反</span></span><br><span class="line">  <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">  p.<span class="built_in">playGame</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字<code>static</code>，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li>静态成员变量<ul>
<li> 所有对象共享同一份数据</li>
<li> 在编译阶段分配内存</li>
<li> 类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数<ul>
<li> 所有对象共享同一个函数</li>
<li> 静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>示例1 ：</strong>静态成员变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态成员变量特点：</span></span><br><span class="line">  <span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line">  <span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line">  <span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//1、通过对象</span></span><br><span class="line">  Person p1;</span><br><span class="line">  p1.m_A = <span class="number">100</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  Person p2;</span><br><span class="line">  p2.m_A = <span class="number">200</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、通过类名</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="补充：双冒号"><a href="#补充：双冒号" class="headerlink" title="补充：双冒号"></a>补充：双冒号</h5><p><code>::</code> 是作用域符，是运算符中等级最高的，它分为三种:</p>
<ol>
<li>==global scope (全局作用域符）==，用法（::name)，如在程序中的某一处想调用全局变量a，那么就写成::a（也可以是全局函数）</li>
<li>==class scope (类作用域符）==，用法(class::name)，如果想调用class A中的成员变量a，那么就写成A::a</li>
<li>==namespace scope (命名空间作用域符）==，用法(namespace::name)，如果想调用namespace std中的cout成员，就写成std::cout</li>
</ol>
<p>都是左关联（left-associativity)，作用都是为了更明确的调用变量</p>
<h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>() &#123;</span><br><span class="line">    mA = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line">  <span class="keyword">int</span> mA;</span><br><span class="line">  <span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> mB; </span><br><span class="line">  <span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p>
<p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li> 当形参和成员变量同名时，可用this指针来区分</li>
<li> 在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处必须返回引用，才能保证修改的是同一个对象</span></span><br><span class="line">    <span class="comment">//否则参考4.2.3，以值方式返回时会调用拷贝构造函数，创建一个新的Person实例对象</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">    <span class="comment">//返回对象本身</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person * p = <span class="literal">NULL</span>;</span><br><span class="line"> p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line"> p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p>
<ul>
<li>成员函数后加const后，称为这个函数为<strong>常函数</strong></li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p><strong>常对象：</strong></p>
<ul>
<li>声明对象前加const称该对象为常对象</li>
<li>常对象只能调用常函数（一般函数里可能存在对某一不可修改变量的修改）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Person</span>() &#123;</span><br><span class="line">  m_A = <span class="number">0</span>;</span><br><span class="line">  m_B = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"> <span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">//this-&gt;m_A = 100; //报错</span></span><br><span class="line">  <span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">//mA = 10000;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">int</span> m_A;</span><br><span class="line"> <span class="keyword">mutable</span> <span class="keyword">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line"> cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"> <span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line"> person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//常对象访问成员函数</span></span><br><span class="line"> person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象只能调用常函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类 访问另一个类中私有成员，关键字为 <code>friend</code></p>
<p>友元的三种实现</p>
<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
<h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line"> <span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"> <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Building</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> string m_BedRoom;     <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GoodGay是一个全局函数，不在类Building中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span> </span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Building b;</span><br><span class="line"> <span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2-类做友元（含类外实现成员函数）"><a href="#4-4-2-类做友元（含类外实现成员函数）" class="headerlink" title="4.4.2 类做友元（含类外实现成员函数）"></a>4.4.2 类做友元（含类外实现成员函数）</h4><p>代码中包括了：在类的外部定义函数的方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span> <span class="comment">//声明类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">goodGay</span>();  <span class="comment">//声明有该函数，但在外部定义</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">  <span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123;</span><br><span class="line">  building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  goodGay gg;</span><br><span class="line">  gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goodGay</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">goodGay</span>();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span> &#123;</span></span><br><span class="line">  <span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string m_SittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  string m_BedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>() &#123;</span><br><span class="line">  building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">  <span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  goodGay  gg;</span><br><span class="line">  gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">  Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p) &#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">    temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//  Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//  temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//  temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//  return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="keyword">const</span> Person&amp; p2, <span class="keyword">int</span> val) &#123;</span><br><span class="line">  Person temp;</span><br><span class="line">  temp.m_A = p2.m_A + val;</span><br><span class="line">  temp.m_B = p2.m_B + val;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//成员函数方式</span></span><br><span class="line">  Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  Person p4 = p3 + <span class="number">10</span>;  <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p>
</blockquote>
<blockquote>
<p>总结2：不要滥用运算符重载</p>
</blockquote>
<h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p>
<p>注意点：</p>
<ol>
<li>&lt;&lt;运算符重载只能使用全局函数，因为成员函数实现时&lt;&lt;在右侧，实现不了想要的效果</li>
<li>全局函数的返回值类型是ostream&amp;，如果是void，后边就不能加 &lt;&lt; endl，导致无法换行（实现链式编程）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载（输出类实例的全部属性）</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">  <span class="comment">//此处形参写out，在test中传入的实参还是cout（简化版可能没那么容易看出）</span></span><br><span class="line">  out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p>
</blockquote>
<h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据递增</p>
<p>对于前置++，在++(++num)时，由于需要保证每次修改的是同一个num，因此需要返回引用</p>
<p>而对于后置++，由于重载函数体内返回了局部变量，如果返回值是引用，那么返回的就是局部变量的引用，会报错，因此只能返回值，因此出现(num++)++的写法是无效的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">    m_Num = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//前置++</span></span><br><span class="line">  MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    <span class="comment">//先++ 再返回</span></span><br><span class="line">    m_Num++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//后置++</span></span><br><span class="line">  <span class="comment">//只能通过int占位符区分前置和后置</span></span><br><span class="line">  MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="comment">//先返回</span></span><br><span class="line">    MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">    m_Num++;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">  out &lt;&lt; myint.m_Num;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyInteger myInt;</span><br><span class="line">  cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyInteger myInt;</span><br><span class="line">  cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 前置递增返回引用，后置递增返回值</p>
</blockquote>
<h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p>
<ol>
<li>默认构造函数(无参，函数体为空)</li>
<li>默认析构函数(无参，函数体为空)</li>
<li>默认拷贝构造函数，对属性进行值拷贝</li>
<li>==赋值运算符 operator=, 对属性进行值拷贝==</li>
</ol>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">    m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(age);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重载赋值运算符 </span></span><br><span class="line">  Person&amp; <span class="keyword">operator</span>=(Person &amp;p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_Age;</span><br><span class="line">      m_Age = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line">    <span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">    m_Age = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回自身</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_Age;</span><br><span class="line">      m_Age = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//年龄的指针</span></span><br><span class="line">  <span class="keyword">int</span> *m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//重载关系运算符 </span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(Person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(Person &amp; p) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string m_Name;</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">  <span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (a != b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul>
<li>函数调用运算符 ()  也可以重载</li>
<li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//重载的()操作符，也称为仿函数</span></span><br><span class="line">  MyPrint myFunc;</span><br><span class="line">  <span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//重载()操作符</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1 + v2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  MyAdd add;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//匿名对象调用  </span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p>
<p>定义一些类时，下级别的成员除了拥有上一级的共性，还有自己的特性，可以考虑利用继承的技术，减少重复代码</p>
<h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p>
<p><strong>继承实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasePage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">header</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">footer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">left</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Python</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPP</span> :</span> <span class="keyword">public</span> BasePage &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Java页面</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Java ja;</span><br><span class="line">  ja.<span class="built_in">header</span>();</span><br><span class="line">  ja.<span class="built_in">footer</span>();</span><br><span class="line">  ja.<span class="built_in">left</span>();</span><br><span class="line">  ja.<span class="built_in">content</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Python页面</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Python py;</span><br><span class="line">  py.<span class="built_in">header</span>();</span><br><span class="line">  py.<span class="built_in">footer</span>();</span><br><span class="line">  py.<span class="built_in">left</span>();</span><br><span class="line">  py.<span class="built_in">content</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//C++页面</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  CPP cp;</span><br><span class="line">  cp.<span class="built_in">header</span>();</span><br><span class="line">  cp.<span class="built_in">footer</span>();</span><br><span class="line">  cp.<span class="built_in">left</span>();</span><br><span class="line">  cp.<span class="built_in">content</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结：</strong></p>
<p>继承的好处：==可以减少重复的代码==</p>
<p>class A : public B; </p>
<p>A 类称为子类 或 派生类</p>
<p>B 类称为父类 或 基类</p>
<p><strong>派生类中的成员，包含两大部分</strong>：</p>
<p>一类是从基类继承过来的，一类是自己增加的成员。</p>
<p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p>
<h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p>
<p><strong>继承方式一共有三种：</strong></p>
<ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<img src="https://z3.ax1x.com/2021/08/22/fzWXNV.png" alt="img" style="zoom:80%;">





<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">    m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">    <span class="comment">//m_C; //不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son1 s1;</span><br><span class="line">  s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>:</span><span class="keyword">protected</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">    m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line">    <span class="comment">//m_C; //不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myClass2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son2 s;</span><br><span class="line">  <span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>:</span><span class="keyword">private</span> Base3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">    m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line">    <span class="comment">//m_C; //不可访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandSon3</span> :</span><span class="keyword">public</span> Son3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line">    <span class="comment">//m_A;</span></span><br><span class="line">    <span class="comment">//m_B;</span></span><br><span class="line">    <span class="comment">//m_C;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>利用工具查看：</p>
<p><img src="https://z3.ax1x.com/2021/08/22/fzhfSS.png" alt="1545881904150"></p>
<p>打开工具窗口后，定位到当前CPP文件的盘符</p>
<p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p>
<p>效果如下图：</p>
<img src="https://z3.ax1x.com/2021/08/22/fzhRW8.png" alt="1545882158050" style="zoom:80%;">



<blockquote>
<p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p>
</blockquote>
<h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<p>问题：父类和子类的构造和析构顺序是谁先谁后？</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Son</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">  Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p>
</blockquote>
<h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p>
<ul>
<li>访问子类同名成员——直接访问即可</li>
<li>访问父类同名成员——需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() &#123;</span><br><span class="line">    m_A = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>() &#123;</span><br><span class="line">    m_A = <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line">  <span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">func</span>();</span><br><span class="line">  s.Base::<span class="built_in">func</span>();</span><br><span class="line">  s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>子类对象可以直接访问到子类中同名成员</li>
<li>子类对象加作用域可以访问到父类同名成员</li>
<li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li>
</ol>
<h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p>
<p>静态成员和非静态成员出现同名，处理方式一致</p>
<ul>
<li>访问子类同名成员——直接访问即可</li>
<li>访问父类同名成员——需要加作用域</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过对象访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Son s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过类名访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl; <span class="comment">//直接写Base::m_A也可以</span></span><br><span class="line">  <span class="comment">//第一个::代表通过类名方式访问，第二个::代访问父类作用域下</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//通过对象访问</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Son s;</span><br><span class="line">  s.<span class="built_in">func</span>();</span><br><span class="line">  s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">  Son::<span class="built_in">func</span>();</span><br><span class="line">  Son::Base::<span class="built_in">func</span>();</span><br><span class="line">  <span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">  Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//test01();</span></span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p>
</blockquote>
<h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p>
<p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p>
<p>多继承可能会引发父类中有同名成员出现的现象，需要加作用域区分，故<strong>C++实际开发中不建议用多继承</strong></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base1</span>() &#123;</span><br><span class="line">    m_A = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base2</span>() &#123;</span><br><span class="line">    m_A = <span class="number">200</span>; <span class="comment">// 和Base1中的m_A重名</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Son</span>() &#123;</span><br><span class="line">    m_C = <span class="number">300</span>;</span><br><span class="line">    m_D = <span class="number">400</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_C;</span><br><span class="line">  <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Son s;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(s) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p>
</blockquote>
<h4 id="4-6-8-菱形继承和虚继承"><a href="#4-6-8-菱形继承和虚继承" class="headerlink" title="4.6.8 菱形继承和虚继承"></a>4.6.8 菱形继承和虚继承</h4><p>由于多继承使用较少，遇到菱形继承的机会更少，因此了解即可</p>
<p><strong>菱形继承概念：</strong></p>
<p>  两个派生类继承同一个基类</p>
<p>  又有某个类同时继承者两个派生类</p>
<p>  这种继承被称为菱形继承，或者钻石继承</p>
<p><strong>典型的菱形继承案例：</strong></p>
<img src="https://z3.ax1x.com/2021/08/22/fzXFQ1.png" alt="IMG_256" style="zoom: 67%;">



<p><strong>菱形继承问题：</strong></p>
<ol>
<li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
</code></pre>
</li>
<li><p>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span>   :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  SheepTuo st;</span><br><span class="line">  st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">  st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ul>
<li><p>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费</p>
</li>
<li><p>利用虚继承可以解决菱形继承问题</p>
</li>
<li><p>虚继承的原理：子类不再保存父类的数据，而是保存指针，通过给指针设置不同的偏移量，从而共享数据（详情见视频）</p>
</li>
</ul>
<h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p>
<p>对多态的解释：多态，即一个接口有多种形态，对于同一个接口，当传入的对象不同（Animal、cat…）时，会得到不同的结果</p>
<p>多态分为两类</p>
<ul>
<li>静态多态: 函数重载 和 运算符重载 属于静态多态，复用函数名</li>
<li>动态多态: 派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别：</p>
<ul>
<li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li>
</ul>
<p>下面通过案例进行讲解多态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Speak函数就是虚函数</span></span><br><span class="line">  <span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态多态</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span> </span>&#123;</span><br><span class="line">  animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态的满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态的使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Cat cat;</span><br><span class="line">  <span class="comment">//动态多态，传入cat后才确定函数地址，进而调用Cat类的函数</span></span><br><span class="line">  <span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line">  Dog dog;</span><br><span class="line">  <span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类中的虚函数（父类要有虚函数，子类将它重写，子类中的同名函数的virtual可带可不带）</li>
</ul>
<p>多态使用条件</p>
<ul>
<li>父类指针或引用指向子类对象</li>
</ul>
<p>重写：函数返回值类型、函数名、参数列表 完全一致 称为重写</p>
<h4 id="4-7-2-多态的原理剖析"><a href="#4-7-2-多态的原理剖析" class="headerlink" title="4.7.2 多态的原理剖析"></a>4.7.2 多态的原理剖析</h4><img src="https://z3.ax1x.com/2021/08/22/hS1G24.png" style="zoom: 50%;">

<p>添加了virtual后，类中保存了vfptr指针，它指向对应的vftable，vftable中存该类的属性和函数（可以是自己的，也可以是继承下来的）</p>
<p>一旦重写了子类的函数，子类对应的vftable会改变</p>
<img src="https://z3.ax1x.com/2021/08/22/hS1zJU.png" style="zoom:67%;">

<h4 id="4-7-3-多态案例一-计算器类"><a href="#4-7-3-多态案例一-计算器类" class="headerlink" title="4.7.3 多态案例一-计算器类"></a>4.7.3 多态案例一-计算器类</h4><p>案例描述：</p>
<p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li><p>满足开闭原则（对于扩展是开放的，对于修改是封闭的）</p>
</li>
<li><p>代码组织结构清晰</p>
</li>
<li><p>可读性强</p>
</li>
<li><p>利于前期和后期的扩展以及维护</p>
</li>
</ul>
<p><strong>示例：</strong></p>
<p>普通实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(string oper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> m_Num1;</span><br><span class="line">  <span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//普通实现测试</span></span><br><span class="line">  Calculator c;</span><br><span class="line">  c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">  c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>多态实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//多态实现 抽象计算器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> m_Num1;</span><br><span class="line">  <span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MulCalculator</span> :</span><span class="keyword">public</span> AbstractCalculator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建加法计算器</span></span><br><span class="line">  AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">  abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">  abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建减法计算器</span></span><br><span class="line">  abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">  abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">  abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建乘法计算器</span></span><br><span class="line">  abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">  abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">  abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">  cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p>
</blockquote>
<h4 id="4-7-4-纯虚函数和抽象类"><a href="#4-7-4-纯虚函数和抽象类" class="headerlink" title="4.7.4 纯虚函数和抽象类"></a>4.7.4 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p>
<p>当类中有了纯虚函数，这个类也称为==抽象类==</p>
<p><strong>抽象类特点</strong>：</p>
<ul>
<li>无法实例化对象</li>
<li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 纯虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Base * base = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">//base = new Base; //错误，抽象类无法实例化对象</span></span><br><span class="line">  base = <span class="keyword">new</span> Son;</span><br><span class="line">  base-&gt;<span class="built_in">func</span>();</span><br><span class="line">  <span class="keyword">delete</span> base;       <span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-5-多态案例二-制作饮品"><a href="#4-7-5-多态案例二-制作饮品" class="headerlink" title="4.7.5 多态案例二-制作饮品"></a>4.7.5 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p>
<p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDrinking</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//烧水</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//冲泡</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//倒入杯中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//加入辅料</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//规定流程</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Boil</span>();</span><br><span class="line">    <span class="built_in">Brew</span>();</span><br><span class="line">    <span class="built_in">PourInCup</span>();</span><br><span class="line">    <span class="built_in">PutSomething</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//烧水</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//冲泡</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//倒入杯中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//加入辅料</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span> <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//烧水</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//冲泡</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//倒入杯中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//加入辅料</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">  drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line">  <span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-7-6-虚析构和纯虚析构"><a href="#4-7-6-虚析构和纯虚析构" class="headerlink" title="4.7.6 虚析构和纯虚析构"></a>4.7.6 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>虚析构和纯虚析构区别：</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code> virtual ~类名() = 0;</code></p>
<p><code>类名::~类名()&#123;&#125;</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Animal</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//虚析构</span></span><br><span class="line">  <span class="comment">//virtual ~Animal() &#123;</span></span><br><span class="line">  <span class="comment">//  cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//纯虚析构（和虚析构有其一即可）</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚析构不仅要有声明，还要有实现，否则在运行时编译器报错</span></span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包含了纯虚析构函数的类也是一个抽象类，不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Cat</span>(string name) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span> m_Name;</span><br><span class="line">      m_Name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">  animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line">  <span class="comment">//父类指针在析构的时候不会调用子类中的析构函数，导致子类如果有堆区的属性，会出现内存泄漏</span></span><br><span class="line">  <span class="comment">//只要把父类的析构改为虚析构/纯虚析构 即可</span></span><br><span class="line">  <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：</p>
<ol>
<li>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</li>
<li>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</li>
<li>拥有纯虚析构函数的类也属于抽象类</li>
</ol>
<h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过<strong>文件可以将数据持久化</strong></p>
<p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p>
<p>文件类型分为两种：</p>
<ol>
<li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li>
<li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li>
</ol>
<p>操作文件的三种流对象:</p>
<ol>
<li>ofstream：写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ol>
<h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>   写文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ofstream ofs;</p>
</li>
<li><p>打开文件</p>
<p>ofs.open(“文件路径”,打开方式);</p>
</li>
<li><p>写数据</p>
<p>ofs &lt;&lt; “写入的数据”;</p>
</li>
<li><p>关闭文件</p>
<p>ofs.close();</p>
</li>
</ol>
<p>其中，2、3可以合并为一步</p>
<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th>打开方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ios::in</td>
<td>为读文件而打开文件</td>
</tr>
<tr>
<td>ios::out</td>
<td>为写文件而打开文件</td>
</tr>
<tr>
<td>ios::ate</td>
<td>初始位置：文件尾</td>
</tr>
<tr>
<td>ios::app</td>
<td>追加方式写文件</td>
</tr>
<tr>
<td>ios::trunc</td>
<td>如果文件存在先删除，再创建</td>
</tr>
<tr>
<td>ios::binary</td>
<td>二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary |  ios:: out</code></p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 少了这句会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ofstream ofs;</span><br><span class="line">  <span class="comment">//只写文件名，则在当前目录下创建文件</span></span><br><span class="line">  ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">  <span class="comment">//ofstream ofs(&quot;test.txt&quot;, ios::out); 等价于以上写法</span></span><br><span class="line">  </span><br><span class="line">  ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">  ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">  ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件操作必须包含头文件 fstream</li>
<li>读文件可以利用 ofstream  ，或者fstream类</li>
<li>打开文件时候需要指定操作文件的路径，以及打开方式</li>
<li>利用&lt;&lt;可以向文件中写数据</li>
<li>操作完毕，要关闭文件</li>
</ul>
<h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件步骤如下：</p>
<ol>
<li><p>包含头文件   </p>
<p>#include &lt;fstream&gt;</p>
</li>
<li><p>创建流对象  </p>
<p>ifstream ifs;</p>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<p>ifs.close();</p>
</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 少了这句会报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ifstream ifs;</span><br><span class="line">  ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一种方式</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二种</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf,<span class="built_in"><span class="keyword">sizeof</span></span>(buf))) &#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第三种</span></span><br><span class="line">  string buf;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf)) &#123;</span><br><span class="line">    cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第四种</span></span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF) &#123;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>读文件可以利用 ifstream  ，或者fstream类</li>
<li>利用is_open函数可以判断文件是否打开成功</li>
<li>close 关闭文件 </li>
</ul>
<h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作，打开方式要指定为 ==ios::binary==</p>
<h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 少了这句会报错</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//2、创建输出流对象</span></span><br><span class="line">  <span class="comment">//可以在这一步就指定打开方式，从而省略open</span></span><br><span class="line">  <span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3、打开文件</span></span><br><span class="line">  <span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">  Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4、写文件</span></span><br><span class="line">  ofs.<span class="built_in">write</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;p, <span class="built_in"><span class="keyword">sizeof</span></span>(p)); <span class="comment">// 第一个参数需要强制类型转换为char *</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//5、关闭文件</span></span><br><span class="line">  ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="1-命名空间"><a href="#1-命名空间" class="headerlink" title="1 命名空间"></a>1 命名空间</h2><h3 id="1-1-命名空间的介绍"><a href="#1-1-命名空间的介绍" class="headerlink" title="1.1 命名空间的介绍"></a>1.1 命名空间的介绍</h3><p>namespace即命名空间，它的目的是解决同一作用域下同名变量或函数的冲突</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> space_1 &#123;</span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// 访问时使用 space_1::num</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> space_2 &#123;</span><br><span class="line">  <span class="keyword">int</span> num; <span class="comment">// 访问时使用 space_2::num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-using-namespace"><a href="#1-2-using-namespace" class="headerlink" title="1.2 using namespace"></a>1.2 using namespace</h3><p>如果每一个同名变量都使用 <code>命名空间::变量名</code>的方式去访问，显得冗余</p>
<p>因此，可以使用 <code>using namespace 命名空间名</code>，指定默认的命名空间，从而当只写变量名时，会访问该命名空间下的变量</p>
<p>不过，如果某一个函数在某一命名空间下声明，在写实现的时候，必须加命名空间名，否则编译器会认为是一个新的全局函数，而不是对已声明函数的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myspace &#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">namespace</span> inner &#123;</span><br><span class="line">    <span class="keyword">int</span> size; <span class="comment">// 不会冲突</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> myspace;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myspace::print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;pi&quot;</span> &lt;&lt; pi &lt;&lt; endl;&#125; <span class="comment">// 必须加命名空间名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  size = <span class="number">100</span>; <span class="comment">// 即myspace::size = 100</span></span><br><span class="line">  inner::size = <span class="number">200</span>; <span class="comment">// 此处不可简写</span></span><br><span class="line">  cout &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; inner::size &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">print</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-std"><a href="#1-3-std" class="headerlink" title="1.3 std"></a>1.3 std</h3><p>常见的cin、cout、endl等对象都定义在std（标准命名空间）中，因此如果不使用<code>using namespace std</code>，访问他们就必须加std::</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"><span class="comment">// using namespace myspace;</span></span><br><span class="line"><span class="comment">// 如果同时使用了这两个命名空间，会出现变量名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myspace &#123;</span><br><span class="line"> <span class="keyword">int</span> cout = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">int</span> endl = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; myspace::cout &lt;&lt; <span class="string">&quot; _This is myspace_ &quot;</span> &lt;&lt; myspace::endl &lt;&lt; std::endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>
