<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《学习JS数据结构与算法》读书笔记</title>
    <url>/2021/06/18/16.%E3%80%8A%E5%AD%A6%E4%B9%A0JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>开始阅读《学习JS数据结构与算法》！</p>
<span id="more"></span>



]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript笔记</title>
    <url>/2021/06/18/15.TS%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>开始学习TypeScript！</p>
<span id="more"></span>

<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>如果在声明变量时赋值，TS可以自动对变量进行<code>类型检测</code>。</p>
<h2 id="any和unknown"><a href="#any和unknown" class="headerlink" title="any和unknown"></a>any和unknown</h2><p>都表示不确定的类型，但unknown比any更安全：</p>
<ul>
<li>any类型的变量可以直接赋给其他值，被赋的变量也会关闭类型检测</li>
<li>unknown类型的变量不能直接被赋给其他变量</li>
</ul>
<p>如果要把它赋值给其他变量，使用断言：</p>
<h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// never 表示永远不会返回结果</span><br><span class="line">function fn(): never&#123;</span><br><span class="line">    throw new Error(&#x27;报错了！&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>对于字面量，如果直接用<code>let a: 1</code>这样的形式，则相当于常量。</p>
<p>使用联合类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 | 来连接多个类型（联合类型）</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;male&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;female&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">boolean</span> | <span class="built_in">string</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line">c = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;&#125; 用来指定对象中可以包含哪些属性</span></span><br><span class="line"><span class="comment">// 语法：&#123;属性名:属性值,属性名:属性值&#125;</span></span><br><span class="line"><span class="comment">// 在属性名后边加上?，表示属性是可选的</span></span><br><span class="line"><span class="keyword">let</span> b: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, age?: <span class="built_in">number</span>&#125;;</span><br><span class="line">b = &#123;<span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [propName: string]: any 表示任意类型的属性</span></span><br><span class="line"><span class="comment">// propName可以改成其他字符串</span></span><br><span class="line"><span class="keyword">let</span> c: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</span><br><span class="line">c = &#123;<span class="attr">name</span>: <span class="string">&#x27;猪八戒&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &amp;表示同时</span></span><br><span class="line"><span class="keyword">let</span> j: &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125; &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">// j = &#123;name: &#x27;孙悟空&#x27;, age: 18&#125;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组的类型声明：</p>
<ul>
<li><pre><code>  类型[]
</code></pre>
</li>
<li><pre><code>  Array&lt;类型&gt;
</code></pre>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string[] 表示字符串数组</span></span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">string</span>[];</span><br><span class="line">e = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// number[] 表示数值数组</span></span><br><span class="line"><span class="keyword">let</span> f: <span class="built_in">number</span>[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">g = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组，元组就是固定长度的数组</p>
<ul>
<li><pre><code>  语法：[类型, 类型, 类型]
</code></pre>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> h: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">h = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">123</span>];</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Gender&#123;</span><br><span class="line">    Male,</span><br><span class="line">    Female</span><br><span class="line">&#125; <span class="comment">// 实际上Male值为0，Female值为1；也可以自己赋不同值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">gender</span>: Gender&#125;;</span><br><span class="line">i = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    <span class="attr">gender</span>: Gender.Male <span class="comment">// &#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型的别名</span></span><br><span class="line"><span class="keyword">type</span> myType = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> k: myType;</span><br><span class="line"><span class="keyword">let</span> l: myType;</span><br><span class="line"><span class="keyword">let</span> m: myType;</span><br><span class="line"></span><br><span class="line">k = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><p>监视模式的开启：<code>tsc -w</code>，include的部分都会被监视，文件修改后自动编译</p>
<h2 id="include、exclude"><a href="#include、exclude" class="headerlink" title="include、exclude"></a>include、exclude</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  tsconfig.json是ts编译器的配置文件，ts编译器可以根据它的信息来对代码进行编译</span></span><br><span class="line"><span class="comment">    &quot;include&quot; 用来指定哪些ts文件需要被编译</span></span><br><span class="line"><span class="comment">      路径：** 表示任意目录</span></span><br><span class="line"><span class="comment">            * 表示任意文件</span></span><br><span class="line"><span class="comment">    &quot;exclude&quot; 不需要被编译的文件目录</span></span><br><span class="line"><span class="comment">        默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;./src/**/*&quot;</span> </span><br><span class="line">    <span class="comment">//可以加逗号，继续写</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;exclude&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;./src/hello/**/*&quot;</span> </span><br><span class="line">    <span class="comment">//一般不用写exclude</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<h2 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// target 用来指定ts被编译为的ES的版本</span></span><br><span class="line">    <span class="comment">// &#x27;es3&#x27;, &#x27;es5&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es2016&#x27;, &#x27;es2017&#x27;, &#x27;es2018&#x27;, &#x27;es2019&#x27;, &#x27;es2020&#x27;, &#x27;esnext&#x27;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// module 指定要使用的模块化的规范</span></span><br><span class="line">    <span class="comment">// &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, &#x27;esnext&#x27;</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;es2015&quot;</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// lib用来指定项目中要使用的库</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#x27;es5&#x27;, &#x27;es6&#x27;, &#x27;es2015&#x27;, &#x27;es7&#x27;, &#x27;es2016&#x27;, &#x27;es2017&#x27;, &#x27;es2018&#x27;, &#x27;es2019&#x27;, &#x27;es2020&#x27;, &#x27;esnext&#x27;, &#x27;dom&#x27;, &#x27;dom.iterable&#x27;,&#x27;webworker&#x27;,&#x27;webworker.importscripts&#x27;,&#x27;webworker.iterable&#x27;,&#x27;scripthost&#x27;,&#x27;es2015.core&#x27;,&#x27;es2015.collection&#x27;,&#x27;es2015.generator&#x27;,&#x27;es2015.iterable&#x27;, &#x27;es2015.promise&#x27;,&#x27;es2015.proxy&#x27;,&#x27;es2015.reflect&#x27;, &#x27;es2015.symbol&#x27;, &#x27;es2015.symbol.wellknown&#x27;,&#x27;es2016.array.include&#x27;,&#x27;es2017.object&#x27;,&#x27;es2017.sharedmemory&#x27;, &#x27;es2017.string&#x27;, &#x27;es2017.intl&#x27;, &#x27;es2017.typedarrays&#x27;, &#x27;es2018.asyncgenerator&#x27;, &#x27;es2018.asynciterable&#x27;, &#x27;es2018.intl&#x27;, &#x27;es2018.promise&#x27;, &#x27;es2018.regexp&#x27;, &#x27;es2019.array&#x27;, &#x27;es2019.object&#x27;, &#x27;es2019.string&#x27;, &#x27;es2019.symbol&#x27;, &#x27;es2020.bigint&#x27;, &#x27;es2020.promise&#x27;, &#x27;es2020.sharedmemory&#x27;, &#x27;es2020.string&#x27;, &#x27;es2020.symbol.wellknown&#x27;, &#x27;es2020.intl&#x27;, &#x27;esnext.array&#x27;, &#x27;esnext.symbol&#x27;, &#x27;esnext.asynciterable&#x27;, &#x27;esnext.intl&#x27;, &#x27;esnext.bigint&#x27;, &#x27;esnext.string&#x27;, &#x27;esnext.promise&#x27;, &#x27;esnext.weakref&#x27;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;es6&quot;</span>, <span class="string">&quot;dom&quot;</span>] <span class="comment">//浏览器运行环境下，一般不作指定</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// outDir 用来指定编译后文件所在的目录</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将代码合并为一个文件</span></span><br><span class="line">    <span class="comment">// 设置outFile后，所有的全局作用域中的代码会合并到同一个文件中</span></span><br><span class="line">    <span class="attr">&quot;outFile&quot;</span>: <span class="string">&quot;./dist/app.js&quot;</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 是否对js文件进行编译，默认是false</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 是否检查js代码是否符合语法规范，默认是false</span></span><br><span class="line">    <span class="attr">&quot;checkJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 是否移除注释</span></span><br><span class="line">    <span class="attr">&quot;removeComments&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 不生成编译后的文件</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当有错误时不生成编译后的文件</span></span><br><span class="line">    <span class="attr">&quot;noEmitOnError&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有严格检查的总开关（设为true时，以下四项都会设为true）</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来设置编译后的文件是否使用严格模式，默认false</span></span><br><span class="line">    <span class="attr">&quot;alwaysStrict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许隐式的any类型</span></span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不允许不明确类型的this</span></span><br><span class="line">    <span class="attr">&quot;noImplicitThis&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严格的检查空值</span></span><br><span class="line">    <span class="attr">&quot;strictNullChecks&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TS与webpack"><a href="#TS与webpack" class="headerlink" title="TS与webpack"></a>TS与webpack</h1><ol>
<li><p><code>npm init -y</code> 生成package.json</p>
</li>
<li><p><code>npm i -D webpack webpack-cli typescript ts-loader html-webpack-plugin webpack-dev-server clean-webpack-plugin</code></p>
<ul>
<li><p>-D 表示开发依赖</p>
</li>
<li><p><code>webpack-cli</code>是webpack的命令行工具</p>
</li>
<li><p><code>html-webpack-plugin</code>用来自动创建html文件</p>
</li>
<li><p><code>webpack-dev-server</code>是webpack的开发服务器</p>
</li>
<li><p><code>clean-webpack-plugin</code>是webpack中的清除插件，每次构建都会先清除目录</p>
</li>
</ul>
</li>
<li><p>编写webpack.config.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入一个包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入html插件</span></span><br><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入clean插件</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack中的所有的配置信息都应该写在module.exports中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/index.ts&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定打包文件所在目录</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="comment">// 打包后文件的文件</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定webpack打包时要使用模块</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定要加载的规则</span></span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// test指定的是规则生效的文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="comment">// 要使用的loader</span></span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">&#x27;ts-loader&#x27;</span></span><br><span class="line">                ],</span><br><span class="line">                <span class="comment">// 要排除的文件</span></span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node-modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置Webpack插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">            <span class="comment">//设置html文件的标题</span></span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;这是一个自定义的title&quot;</span></span><br><span class="line">            <span class="comment">//指定模板</span></span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来设置引用模块，不设置.ts</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">        <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>配置tsconfig.json</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="string">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...略...</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open chrome.exe&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>用class关键字来定义一个类。</p>
<p>注：static和readonly都比较少用。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   直接定义的属性是实例属性，需要通过对象的实例去访问：</span></span><br><span class="line"><span class="comment">*       const per = new Person();</span></span><br><span class="line"><span class="comment">*       per.name</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   使用static开头的属性是静态属性（类属性），可以直接通过类去访问</span></span><br><span class="line"><span class="comment">*       Person.age</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   readonly开头的属性表示一个只读的属性无法修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    name = <span class="string">&#x27;孙悟空&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在属性前使用static关键字可以定义类属性（静态属性）</span></span><br><span class="line">    <span class="keyword">static</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果方法以static开头则方法就是类方法，直接通过类去调用</span></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello 大家好！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(per.name + <span class="string">&#x27; &#x27;</span> +Person.age); <span class="comment">//孙悟空 18</span></span><br><span class="line">per.sayHello();</span><br><span class="line"><span class="comment">// Person.sayHello();</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数、this"><a href="#构造函数、this" class="headerlink" title="构造函数、this"></a>构造函数、this</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor 被称为构造函数</span></span><br><span class="line">    <span class="comment">//  构造函数会在对象创建时调用</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">bark</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;小黑&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> dog2 = <span class="keyword">new</span> Dog(<span class="string">&#x27;小白&#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">dog2.bark();</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>OCP（Open Close Principle ）原则：对变更关闭，对扩展开放。</p>
<p>即：可以添加新的属性和方法，但不要修改他人已有的类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">	age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;动物在叫~&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123; <span class="comment">// 继承</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>在跑~~~`</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪汪！&#x27;</span>); <span class="comment">// 方法重写</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&#x27;喵喵喵喵！&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;咪咪&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(dog);</span><br><span class="line">dog.sayHello();</span><br><span class="line">dog.run();</span><br><span class="line"><span class="built_in">console</span>.log(cat);</span><br><span class="line">cat.sayHello();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>在类的方法中，super就表示当前类的父类。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;动物在叫~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在子类中写了构造函数，在子类构造函数中必须对父类的构造函数进行调用</span></span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪汪！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">dog.sayHello();</span><br></pre></td></tr></table></figure>

<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类就是专门用来被继承的类，以abstract开头</p>
<ul>
<li><pre><code>  抽象类不能用来创建对象
</code></pre>
</li>
<li><pre><code>  抽象类中可以添加抽象方法
</code></pre>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法使用 abstract开头，没有方法体</span></span><br><span class="line">    <span class="comment">// 抽象方法只能定义在抽象类中，子类必须对抽象方法进行重写</span></span><br><span class="line">    <span class="keyword">abstract</span> sayHello():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;汪汪汪汪！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;喵喵喵喵！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;旺财&#x27;</span>);</span><br><span class="line">dog.sayHello();</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口用来定义一个类结构，用来定义一个类中应该包含哪些属性和方法，同时接口也可以当成类型声明去使用</p>
<h3 id="interface和type"><a href="#interface和type" class="headerlink" title="interface和type"></a>interface和type</h3><p>二者都可以当作类型声明来使用，不同点：</p>
<ul>
<li>可以声明相同名称的interface，ts会把它们加在一起；而声明相同名称的type会报错。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> myInterface &#123;</span><br><span class="line">    <span class="attr">gender</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: myInterface = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myType = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj_: myType = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;孙悟空&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口与类"><a href="#接口与类" class="headerlink" title="接口与类"></a>接口与类</h3><ul>
<li>接口可以在定义类的时候去限制类的结构</li>
<li>接口中的所有的属性都不能有实际的值</li>
<li>接口只定义对象的结构，而不考虑实际值</li>
<li>在接口中所有的方法都是抽象方法</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInter&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    sayHello():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类时，可以使类去实现一个接口（使类满足接口的要求）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="title">implements</span> <span class="title">myInter</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;大家好~~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性的封装"><a href="#属性的封装" class="headerlink" title="属性的封装"></a>属性的封装</h2><p>目前现在属性是在对象中设置的，属性可以被任意修改，这导致对象中的数据变得不安全，为了避免这种现象，需要对属性进行封装。</p>
<h3 id="属性修饰符"><a href="#属性修饰符" class="headerlink" title="属性修饰符"></a>属性修饰符</h3><p>TS可以在属性前添加属性的修饰符</p>
<ul>
<li>  public 修饰的属性可以在任意位置访问（修改） 默认值</li>
<li>  private 私有属性，私有属性只能在类内部进行访问（修改），通过在类中添加方法使得私有属性可以被外部访问</li>
<li>  protected 受包含的属性，只能在当前类和当前类的子类中访问（修改）</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> num: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">num: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.num); <span class="comment">// protected修饰符：在子类中可以访问num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B(<span class="number">123</span>);</span><br><span class="line">b.num = <span class="number">321</span>; <span class="comment">// 报错，不能在外部修改num属性</span></span><br></pre></td></tr></table></figure>

<h3 id="get、set"><a href="#get、set" class="headerlink" title="get、set"></a>get、set</h3><p>get方法用来读取属性，set方法用来设置属性，它们被称为属性的存取器。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//此时_name和_age都是私有属性，想要访问/修改必须通过get和set</span></span><br><span class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._name = name;</span><br><span class="line">        <span class="built_in">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>._name = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title">age</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title">age</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="comment">// 使用属性存取器，增强代码健壮性</span></span><br><span class="line">        <span class="keyword">if</span>(value &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>._age = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> per = <span class="keyword">new</span> Person(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用get/set后，还是可以用.的方式，符合我们的习惯</span></span><br><span class="line"></span><br><span class="line">per.name = <span class="string">&#x27;猪八戒&#x27;</span>;</span><br><span class="line">per.age = -<span class="number">33</span>; <span class="comment">// 不满足value &gt;=0，修改不会成功</span></span><br></pre></td></tr></table></figure>

<h3 id="简化写法"><a href="#简化写法" class="headerlink" title="简化写法"></a>简化写法</h3><p>这两种写法是等价的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="comment">// 可以直接将属性定义在构造函数中</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">public</span> age: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>在定义函数或是类时，如果遇到类型不明确就可以使用泛型</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接调用具有泛型的函数</span></span><br><span class="line"><span class="keyword">let</span> result = fn(<span class="number">10</span>); 			   <span class="comment">// 不指定泛型，TS可以自动对类型进行推断</span></span><br><span class="line"><span class="keyword">let</span> result2 = fn&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 指定泛型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型可以同时指定多个</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">a: T, b: K</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">fn2&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">123</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Inter&#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T extends Inter 表示泛型T必须时Inter实现类（子类）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Inter</span>&gt;(<span class="params">a: T</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: T;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: T</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mc = <span class="keyword">new</span> MyClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;孙悟空&#x27;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ts</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>《你不知道的JS》读书笔记</title>
    <url>/2021/05/24/01.%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习方式：一边看书，一边学习他人的博客，把一些关键的部分记录在此，其他的贴出他人博客的链接。此外，本文并非仅是《你不知道的JS》笔记，还额外补充一些内容。</p>
<span id="more"></span>

<h1 id="最佳实践-原则"><a href="#最佳实践-原则" class="headerlink" title="最佳实践/原则"></a>最佳实践/原则</h1><ul>
<li>最小特权原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计</li>
<li>始终给函数表达式命名</li>
<li>对不再必要的全局变量或全局对象的属性，将其设置为null</li>
</ul>
<h1 id="上卷"><a href="#上卷" class="headerlink" title="上卷"></a>上卷</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><a href="https://blog.csdn.net/weixin_44659458/article/details/109356598">1.Javascript引擎，编译器，作用域三者之间的关系及LHS和RHS的区别</a><br><a href="https://www.jianshu.com/p/36f5bfc6b7e6/">2.聊聊JavaScript 编译器，引擎，作用域</a></p>
<h3 id="JS的编译"><a href="#JS的编译" class="headerlink" title="JS的编译"></a>JS的编译</h3><p>JS代码片在执行前要先编译：它的编译过程（通常）是在实际执行前进行的，而且也不会产生可移植的编译结果。</p>
<p>通常的编译步骤：</p>
<ol>
<li><code>分词与词法分析</code>：把输入的字符串分解为一些对编程语言有意义的代码块（词法单元）。</li>
<li><code>解析与语法分析</code>：将上一步的词法单元集合分析并最终转换为一个由元素逐级嵌套所组成的代表了程序语法结构的树，称为<code>抽象语法树</code>（Abstract Syntax Tree，AST）。</li>
<li><code>代码生成</code>：将上一步的AST转换为可执行代码。</li>
</ol>
<p>由于JS编译的特殊性，编译执行效率就要比一般静态语言敏感的多，故而也非常复杂。JS引擎在这一部分做了非常多的优化，一是针对语法分析和代码生成阶段进行优化（例如针对冗余元素进行优化等），目的是提高编译后的执行效率。二是针对编译过程进行优化（如JIT，延迟编译甚至重编译），目的是缩短编译过程，保证性能最佳。</p>
<h4 id="引擎、编译器和作用域"><a href="#引擎、编译器和作用域" class="headerlink" title="引擎、编译器和作用域"></a>引擎、编译器和作用域</h4><p>引擎：   负责整个Javascript程序的编译及执行过程。<br>编译器：负责语法分析及代码生成。<br>作用域：负责收集并维护有所有声明的标识符组成的一系列查询。</p>
<h4 id="var-a-1的编译过程"><a href="#var-a-1的编译过程" class="headerlink" title="var a=1的编译过程"></a>var a=1的编译过程</h4><ol>
<li><code>编译器</code>首先会将这段代码分解成词法单元，然后将词法单元解析成树结构。</li>
<li>对词法单元进行解析，解析到var a时，<code>编译器</code>会询问作用域是否存在一个变量名为a在同一作用域的集合中。如果有，编译器就忽略此声明。反之，在要求的作用域下声明变量。<br>第三步：生成可以运行代码(=1)给<code>引擎</code>执行，生成代码的这个过程就涉及到LHS和RHS两种赋值概念。<br>第四步：<code>引擎</code>运行编译器生成的代码时，会询问<code>作用域</code>是否存在在当前作用域下变量名为a的集合，如果没有，则在向上一级作用域查找变量名a。如果有，引擎则对变量名为a的集合赋值。</li>
</ol>
<h4 id="LHS和RHS"><a href="#LHS和RHS" class="headerlink" title="LHS和RHS"></a>LHS和RHS</h4><p>LHS（left-hand-side）：找到变量的容器本身，从而可以对其赋值<br>RHS（rigjt-hand-side）：查找某个变量的值</p>
<h3 id="函数作用域和块作用域"><a href="#函数作用域和块作用域" class="headerlink" title="函数作用域和块作用域"></a>函数作用域和块作用域</h3><h4 id="最小特权原则"><a href="#最小特权原则" class="headerlink" title="最小特权原则"></a>最小特权原则</h4><p>最小特权原则：在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计</p>
<h4 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h4><h5 id="全局命名空间"><a href="#全局命名空间" class="headerlink" title="全局命名空间"></a>全局命名空间</h5><p>（可以实践）</p>
<p>在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会称为这个对象的属性，而不是将自己的标识符暴露在顶级的词法作用域中。</p>
<h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>把IIFE当作函数调用并传递参数进去，可以改进代码风格</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"><span class="built_in">global</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);	<span class="comment">//3</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">global</span>.a);	<span class="comment">//2</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);	<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>好处：在代码风格上对全局对象的引用，变得比引用一个没有”全局”字样的变量更加清晰</p>
<p>倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去<br>（思考：这种方式或许能在某处派上用场）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params">def</span>) </span>&#123;</span><br><span class="line">	def(<span class="built_in">window</span>);</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"><span class="built_in">global</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);	<span class="comment">//3</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">global</span>.a);	<span class="comment">//2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="with和try-catch（放着）"><a href="#with和try-catch（放着）" class="headerlink" title="with和try/catch（放着）"></a>with和try/catch（放着）</h4><h4 id="垃圾回收（补充）"><a href="#垃圾回收（补充）" class="headerlink" title="垃圾回收（补充）"></a>垃圾回收（补充）</h4><p><a href="https://segmentfault.com/a/1190000018605776">前端面试：谈谈 JS 垃圾回收机制</a><br><a href="https://www.yuque.com/bingyan-studio/isz3cs/up15ft">浏览器垃圾回收与内存管理</a></p>
<p>引用计数法由于循环引用问题而遭到废弃，此处只记录标记清理法：</p>
<ul>
<li>垃圾回收程序运行的时候，会标记内存中存储的所有变量</li>
<li>程序会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉，在此之后再被加上标记的变量就是待删除的，因为任何在上下文中的变量都访问不到它们了</li>
<li>随后垃圾回收程序做一次内存清理，销毁带标记的所有值并回收它们的内存</li>
</ul>
<p>关于垃圾回收更详细的内容，请猛戳第二篇博文</p>
<h5 id="V8垃圾回收"><a href="#V8垃圾回收" class="headerlink" title="V8垃圾回收"></a>V8垃圾回收</h5><p>V8三种回收算法的比较：</p>
<table>
<thead>
<tr>
<th>回收算法</th>
<th>标记清除（Mark-Sweep）</th>
<th>标记整理</th>
<th>Scavange</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（有碎片）</td>
<td>少（无碎片）</td>
<td>双倍空间（无碎片）</td>
</tr>
<tr>
<td>是否移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="模块（放着）"><a href="#模块（放着）" class="headerlink" title="模块（放着）"></a>模块（放着）</h4><p><a href="https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a><br><a href="https://blog.csdn.net/m0_51235736/article/details/116904464">前端模块化详解-笔记</a></p>
<h3 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h3><ul>
<li>词法作用域：在写代码或者说定义时确定，关注函数在何处声明</li>
<li>动态作用域：在运行时确定，关注函数在何处调用，作用域基于调用栈</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="往日结论"><a href="#往日结论" class="headerlink" title="往日结论"></a>往日结论</h3><p>先说以前记的结论：<br>1.以函数形式调用时，this永远都是window<br>2.以方法的形式调用时，this是调用方法的对象<br>3.以构造函数的形式调用时，this是新创建的那个对象<br>4.使用call和apply调用时，this是指定的那个对象</p>
<h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><ul>
<li>this在运行时进行绑定，它的上下文取决于函数调用时的各种条件。</li>
<li>当一个函数被调用时，会创建一个活动记录（执行上下文），它包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。this是执行上下文的一个属性，会在函数执行的过程中用到</li>
</ul>
<h3 id="this全面解析"><a href="#this全面解析" class="headerlink" title="this全面解析"></a>this全面解析</h3><p>显示强制绑定：一旦绑定this后不可以再通过call或apply修改this，比如ES添加的bind</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ol>
<li>new（构造调用）</li>
<li>显示绑定/硬绑定调用（call、apply/bind）</li>
<li>隐式绑定（对象的方法）</li>
<li>默认绑定（全局对象）</li>
</ol>
<p>对默认绑定来说，决定this绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this会被绑定到undefined，否则this会被绑定到全局对象。</p>
<h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><h5 id="将null或undefined作为绑定对象"><a href="#将null或undefined作为绑定对象" class="headerlink" title="将null或undefined作为绑定对象"></a>将null或undefined作为绑定对象</h5><p>这些情况下，函数并不关心this是什么，传入的null仅仅作为占位值</p>
<p>情况一：展开数组；情况二：柯里化（减少返回的函数要求传入参数的个数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span> + a + <span class="string">&quot;, b:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数组展开</span></span><br><span class="line">foo.apply(<span class="literal">null</span>, [<span class="number">2</span>,<span class="number">3</span>]);	<span class="comment">// a: 2, b: 3</span></span><br><span class="line"><span class="comment">//ES6中可以用...操作符来替代</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.bind(<span class="literal">null</span>, <span class="number">2</span>);<span class="comment">//对bar，以后就只用传入b这个参数了</span></span><br><span class="line">bar(<span class="number">3</span>);	<span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>

<p>以上的方式有一定安全隐患，并不推荐</p>
<h5 id="更安全的this"><a href="#更安全的this" class="headerlink" title="更安全的this"></a>更安全的this</h5><p>创建空的非委托对象，即DMZ（非军事区）对象</p>
<blockquote>
<p>Object.create(null)和{}很像，但是并不会创建Object.prototype这个委托，因此比{}更空。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span> + a + <span class="string">&quot;, b&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们的DMZ空对象，使用空集符号可以增强可读性</span></span><br><span class="line"><span class="keyword">let</span> Ø = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数组展开</span></span><br><span class="line">foo.apply(Ø, [<span class="number">2</span>,<span class="number">3</span>]);	<span class="comment">// a: 2, b: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用bind进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.bind(Ø, <span class="number">2</span>);<span class="comment">//对bar，以后就只用传入b这个参数了</span></span><br><span class="line">bar(<span class="number">3</span>);	<span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>
<h5 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h5><p>创建函数的间接引用时，调用该函数会应用默认绑定规则，间接引用最容易在赋值时发生</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="keyword">let</span> p = &#123;<span class="attr">a</span>: <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值表达式p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或o.foo() </span></span><br></pre></td></tr></table></figure>
<h4 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h4><p>由以上可知，硬绑定后隐式绑定或显示绑定会无效</p>
<p>软绑定：可以给默认绑定指定一个全局对象和undefined以外的值，同时保留隐式绑定或者显式绑定修改this的能力</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一段代码，暂时不能完全看懂</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.softBind) &#123;</span><br><span class="line">	<span class="built_in">Function</span>.prototype.softBind = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">let</span> fn = <span class="built_in">this</span>;</span><br><span class="line">		<span class="comment">// 捕获所有curried参数</span></span><br><span class="line">		<span class="keyword">let</span> curried = [].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> fn.apply(</span><br><span class="line">				(!<span class="built_in">this</span> || <span class="built_in">this</span> === (<span class="built_in">window</span> || <span class="built_in">global</span>)) ? </span><br><span class="line">					obj: <span class="built_in">this</span>,</span><br><span class="line">					curried.concat.apply(curried, <span class="built_in">arguments</span>)</span><br><span class="line">			);</span><br><span class="line">		&#125;;</span><br><span class="line">		bound.prototype = <span class="built_in">Object</span>.create(fn.prototype);</span><br><span class="line">		<span class="keyword">return</span> bound;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;name: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>&#125;, obj2 = &#123;<span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>&#125;, obj3 = &#123;<span class="attr">name</span>: <span class="string">&quot;obj3&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fooOBJ = foo.softBind(obj); <span class="comment">//软绑定，此时默认绑定了obj对象</span></span><br><span class="line">fooOBJ(); <span class="comment">// name: obj</span></span><br><span class="line">obj2.foo = foo.softBind(obj); <span class="comment">//软绑定，此时默认绑定了obj对象</span></span><br><span class="line">obj2.foo(); <span class="comment">// name: obj2 此时隐式绑定仍然生效</span></span><br><span class="line">fooOBJ.call(obj3); <span class="comment">// name: obj3 此时显示绑定仍然生效</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj2.foo, <span class="number">10</span>); <span class="comment">// name: obj</span></span><br></pre></td></tr></table></figure>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数不使用this的四种标准规则，而是根据外层作用域来决定this</p>
<p>箭头函数的绑定无法被修改，new也不行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">a</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = foo.call(obj1); </span><br><span class="line"><span class="comment">//foo的this被绑定为obj1，由this词法，bar的this受到foo的影响，也是obj1</span></span><br><span class="line">bar.call(obj2); <span class="comment">// 2， 一旦绑定，就不可被修改</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中卷"><a href="#中卷" class="headerlink" title="中卷"></a>中卷</h1><h1 id="下卷"><a href="#下卷" class="headerlink" title="下卷"></a>下卷</h1>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Some ideas</title>
    <url>/2021/06/15/14.Some%20ideas/</url>
    <content><![CDATA[<p>记录一些我想做的东西：</p>
<span id="more"></span>

<h1 id="长远计划"><a href="#长远计划" class="headerlink" title="长远计划"></a>长远计划</h1><ul>
<li>网页游戏/微信小程序游戏开发</li>
<li>APP开发</li>
</ul>
<h1 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h1><h2 id="补充技术"><a href="#补充技术" class="headerlink" title="补充技术"></a>补充技术</h2><ul>
<li>TypeScript</li>
<li>ES6没学完的部分</li>
<li>webpack</li>
<li>Vue</li>
<li>flutter</li>
<li>Nginx</li>
<li>Axios</li>
<li>打通Git</li>
<li>系统学习Github的使用</li>
<li>熟悉node（npm）</li>
<li>Linux（未来学习）</li>
</ul>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li>完善Lofter，登录/搜索/细节完善/部署上线</li>
<li>完善cMind，修改UI/更多功能</li>
<li>尝试把cMind变成套壳APP，而非只是网页</li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li>阅读《你不知道的JS》</li>
<li>阅读《学习JS数据结构和算法》</li>
<li>阅读《JS设计模式和开发实践》</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>完成洛谷题目，数据结构进阶</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>视频制作教程笔记(影视飓风)</title>
    <url>/2021/06/05/13.%E8%A7%86%E9%A2%91%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0(%E5%BD%B1%E8%A7%86%E9%A3%93%E9%A3%8E)/</url>
    <content><![CDATA[<p>AV25783076：高画质的背后——视频的封装与编码</p>
<p>AV20450727：超级转场的核心——变速 ⭐️</p>
<p>AV18747023：Pr和Ae的无缝衔接大法</p>
<p>AV7301488：小技巧：Pr被低估的10个快捷键</p>
<p>AV7855737：小技巧：LUTS ⭐️</p>
<p>AV7045442：Premiere小技巧：秘传技</p>
<p>AV6936344：无缝转场与轨道蒙版 ⭐️</p>
<p>AV6746166：小技巧：超级转场的制作 ⭐️</p>
<span id="more"></span>



<h1 id="视频的封装与编码"><a href="#视频的封装与编码" class="headerlink" title="视频的封装与编码"></a>视频的封装与编码</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li><p>编码分为：剪辑编码、输出编码、拍摄编码</p>
</li>
<li><p>mov、mp4是封装格式（format），不是编码</p>
</li>
<li><p>常见编码有H.264（帧间编码）和Prores（帧内编码）</p>
</li>
</ul>
<h2 id="帧内-帧间编码的对比"><a href="#帧内-帧间编码的对比" class="headerlink" title="帧内/帧间编码的对比"></a>帧内/帧间编码的对比</h2><h3 id="帧内编码"><a href="#帧内编码" class="headerlink" title="帧内编码"></a>帧内编码</h3><p>特点：针对每一帧的画面，进行单独的分析，就好比压缩一张照片。</p>
<p>优点：</p>
<ul>
<li>电脑在回放的时候比较轻松。</li>
</ul>
<p>缺点：</p>
<ul>
<li>能压缩的大小有限，体积会受到限制（比如说背景没有变化的时候，每一针都会被记录一次，产生了数据上的冗余）。</li>
</ul>
<h3 id="帧间编码"><a href="#帧间编码" class="headerlink" title="帧间编码"></a>帧间编码</h3><p>特点：记录两张完整的画面，只记录中间像素产生的变化，在后期解码时再重新运算出中间的帧，恢复出当时画面。</p>
<p>优点：</p>
<ul>
<li>有效压缩了素材体积。</li>
</ul>
<p>缺点：</p>
<ul>
<li>大了电脑的处理压力。</li>
</ul>
<h2 id="代理和输出编码"><a href="#代理和输出编码" class="headerlink" title="代理和输出编码"></a>代理和输出编码</h2><p>假如相机记录了4k的画面，又正好是帧间编码， 电脑又不够强大，应该选择使用<code>代理</code>，从而可以重新编码出一个分辨率更低，帧内编码的视频文件，使得在剪辑时更加流畅，剪辑完之后可以把它替换成原素材做进一步的处理（以后讲）。</p>
<p>剪辑完成之后，需要输出编码，这直接影响了上传到网上的视频质量，<strong>最佳的网络传播的编码，应该是h264编码，MP4封装。</strong></p>
<h2 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h2><p>码率也会影响画面和文件大小，编码决定了这个大小之下保留着最好的图像。</p>
<p>码率分为<code>恒定码率</code>和<code>可变码率</code>，通常可变码率会更实用一些，因为编码器会分析画面，之后对复杂的画面提供更多的码率，对于更容易压缩的地方，总会减少码率，这样即便文件大小不变，整体画质也会获得提升。</p>
<p>网络视频通常会在上传视频文件后进行二次压缩，可能造成码率降低，更低的码率很容易导致画面翻车，在面对具有大量随机移动的像素的时候，比如下雪或者灰尘，画面质量会迅速下降，因为编码器难以预测像素的运动，而码率不足以支撑画面。</p>
<p><strong>可以通过将视频压到B站限定的码率之下，来规避二次压缩，这样可以针对自己的视频进行编码上的优化，来获得更好的画质</strong>。</p>
<h1 id="变速"><a href="#变速" class="headerlink" title="变速"></a>变速</h1><h2 id="升格"><a href="#升格" class="headerlink" title="升格"></a>升格</h2><p><code>升格</code>是对慢动作比较专业的叫法，很多人直接把素材拖到时间线上，然后Ctrl+R，这个快捷键可以呼出速度控制窗口，然后可以输入25%或者50%，这样就可以实现升格，但是假如变速不是整除，就会遇到<code>跳帧</code>，所以应该使用<code>解释素材</code>来进行慢放，而不是纯粹的速度控制。</p>
<blockquote>
<p>升格：电影摄影中的一种技术手段，电影摄影拍摄标准是每秒24帧，也就是每秒拍摄24张，这样在放映时才能是正常速度的连续性画面，但为了实现一些简单的技巧，比如慢镜头效果，就要改变正常的拍摄速度，比如高于60帧/秒，这就是升格，放映效果就是慢动作。如果降低拍摄速度（低于24帧/秒），就是降格，放映效果就是快动作。</p>
</blockquote>
<blockquote>
<p>跳帧（frameskip），假如显示器设定的刷新率是80Hz，显卡以100FPS循环显示0-9数字，那么，在开始的0.1秒内，显卡显示了10个数字而显示器只刷新了8次，最终你看到的图像很可能是这样的：由于显示器刷新率跟不上游戏的FPS，只能舍弃一部分画面，这种现象表现在游戏里就是跳帧。</p>
</blockquote>
<h2 id="解释素材"><a href="#解释素材" class="headerlink" title="解释素材"></a>解释素材</h2><p>使用解释素材就是，在素材箱右键你的素材→Modify →Interpret footage，然后只需要把帧率修改成想要回放的帧率（比如25），这样就可以一次性处理所有的素材，实现慢放。</p>
<p>不存在整除的问题，因为可以理解成一卷胶片换了一个速度播放，就像以前升格一样，只是把每一帧映射到和之前不同的位置上。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>当有了升格后，通常需要使用变速来强化效果，很多人喜欢直接切一刀画面，然后按一下R键，激活变速工具进行变速，没有渐变，所以看起来会很突兀。</p>
<p>正确做法是右键素材的fx标记，然后选择time remapping（<code>时间重映射</code>），然后按住Ctrl+ALT键，这个键可以帮助快速添加关键帧（任何需要添加关键帧的地方都可以使用这个快捷键），打上关键帧之后可以上下拖动这根线来实现变速，随后可以分开这两个小的关键帧，这样就会有一个具有渐变的变速。也可以拖动拉杆来进一步改变速度曲线，来实现最好的效果。</p>
<p>但是也有一个弊端，PR的速度上限是十倍，假如要突破这个限制，通常会在速度最大值处切一刀，然后单独按R键加速中间这一段，再把三段衔接起来。</p>
<p>如果想要流畅的过渡镜头与镜头之间的连接，就很需要这种变速，通常就是快对快、慢对慢，如果前一个素材的尾部被加速了，那么后一个素材的起始部分也应该要被加速，这样的话，动势就能够被匹配，画面就会比较连贯。</p>
<p><strong>此处需要练习</strong></p>
<h2 id="帧采样、帧混合、光流"><a href="#帧采样、帧混合、光流" class="headerlink" title="帧采样、帧混合、光流"></a>帧采样、帧混合、光流</h2><p>如果画面不连贯，或者想要实现比相机拍摄帧率更高的慢动作，就需要使用不同的时间控制，在Pr的速度窗口里，最下方有三个选项，帧采样、帧混合、光流。</p>
<ul>
<li>帧采样，只是把同一帧展现两次或者更多次。</li>
<li>帧混合也是重复出现同样的画面，但是添加了一点渐变和叠加，在视觉上稍微顺畅一点。</li>
<li>光流是真正意义上添加了新的帧，它通过预测两帧之间的像素运动轨迹，重新运算出了中间的针帧，画面总的帧数增加，比较流畅，但是必须要对比非常大的画面，才能够实现最佳的光流效果，否则会出现畸变。</li>
</ul>
<p>通常在加速之后，突然实现短暂的光流升格，可以实现非常酷炫的画面；帧混合一般用于快放，可以实现类似于动态模糊的感觉。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用带有渐变的变速，选择合适的时间控制模式，能够大大提升整体剪辑的节奏感，也能实现更好的转场，同时也要注意音频。</p>
]]></content>
      <categories>
        <category>视频制作</category>
      </categories>
      <tags>
        <tag>视频制作</tag>
      </tags>
  </entry>
  <entry>
    <title>未来の思考</title>
    <url>/2021/06/04/12.%E6%9C%AA%E6%9D%A5%E3%81%AE%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>一些关于未来的思考：</p>
<span id="more"></span>
<p>考研与工作的抉择：<br><img src="/2021/06/04/12.%E6%9C%AA%E6%9D%A5%E3%81%AE%E6%80%9D%E8%80%83/1.jpg"></p>
<p>未来的打算：<br><img src="/2021/06/04/12.%E6%9C%AA%E6%9D%A5%E3%81%AE%E6%80%9D%E8%80%83/2.jpg"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2020 and Half of 2021</title>
    <url>/2021/05/30/11.2020+2021%E4%B8%8A%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>刚刚无意间看到了某位前辈的博客，我想，既然有了自己的博客，总结还是不要写在qq空间为好。</p>
<p>2020年至今，发生了不少事情，还是记录一下，作为以后的人生经验吧，不知道自己会以什么样的笔调写下这些话。</p>
<span id="more"></span>

<h1 id="挣扎与彷徨"><a href="#挣扎与彷徨" class="headerlink" title="挣扎与彷徨"></a>挣扎与彷徨</h1><h2 id="高三之前"><a href="#高三之前" class="headerlink" title="高三之前"></a>高三之前</h2><p>高中的往事已回忆数次，无非就是这样的开局：不自信/想要变强→怀抱着不切实际要当科学家的妄想→逼迫自己，强迫症/形体化→后悔，无力改变现状。那个时候，基本是个人我都会感到羡慕，我沉沦于无止境的痛苦之中，每天都感觉过得浑浑噩噩，觉得自己的青春和人生就这么被强迫症给废掉了。不论我怎么努力，都感觉自己被限制住了，就是发挥不出来自己的能力，考试也极少进年级前50，比起我初中玩着考入班级前十，现在的我稳在班级前50%都困难。</p>
<p>现在觉得一切不过都是借口，强迫症也并没有那么可怕，虽然它让我的生活变得不太舒服，形体化的后患仍然存在，但并不影响我掌控自己的人生。当时成绩上不去，是我做了太多琐碎的事，摘抄或总结了很多笔记却很少复习且断断续续，自发刷题只坚持了英语，总之没有高效率地学习。顺带一提，这里提到的有些毛病我现在都还没有改掉。</p>
<p>在高二的时候其实我已经认识到（现在我都不知道这种认识是否正确），<strong>自己或许不能专精于任何一个方向</strong>，因为努力学习后也考不到年级顶尖水平。比起某方面的专精，我可能更适合成为全能型庸才（但其实这样我也做不到），所以当时就买了心理学、计算机、美学、音乐的书来看，还读了《混血豺王》和《比尔盖茨传》等。但是这一切在高三到来的时候就又被我抛掷脑后。</p>
<h2 id="疲于奔命"><a href="#疲于奔命" class="headerlink" title="疲于奔命"></a>疲于奔命</h2><p>高二暑假是我此生最短的暑假，短到只有两天。暑假前半段被迫参加每天200块的“名校通”，暑假后半段又要回去补课，回去前的一周我又自愿交钱补习化竞，顺带一提，后期到开学的这段时间我看完《钢之炼金术师》全套漫画。</p>
<p>那个时候，我看到了北大2020的招生简章，简章十分精美，花花绿绿，我们班上放了几本，于是我便热衷于阅读它。那个时候我被北大所深深吸引，开始幻想能不能考上，并且由于自己心态的困境，我特别想去心理学系。其实去不去心理学也无所谓，那时候我觉得读个考古都可以，反正是北大嘛。这样靠着专项计划，我还是得考到680分才可以，而我只有650分的水平，平时的模考只能考580~620区间。</p>
<p>我开始思考着自己如何达到这种“飞跃”，大概是一定要去找自己的节奏，有针对性地提分。前边还是比较顺利，在11月的一次模考中，我同时取得了语文（128，之后再也没达到过）和化学的双班级第一，年级31名，之后一次考试我坐在第一考场，考理综时心态突然崩溃，结果理综考了190，好状态完全止步于这次考试。于是我开始不听讲，不按着学校的复习进度来，自己整些笔记、刷题、网课，这些全都上了。但是随着时间的不断推移，我没觉得自己有什么进步，后边越来越过分。先是伪造病历去办了走读证，在学校旁边租了个小房间便于每天走读回去多学会，也方便刷网课。因为买的网课太多觉得刷不完，然后又跟班主任协商，翘掉四节晚自习。我开始觉得学校老师讲的啥用没有，平时的作业很多都在抄，觉得极其浪费时间，待在学校我都觉得痛苦，我把自己没有进步的错误都归咎于是学校限制了我。一轮复习结束，二轮复习开始，我觉得自己还是老样子。结果这段时间成绩不断下降，位次连着四五次都在一百名开外，老师也在找我谈话。</p>
<p>最后我还是下定决心回家复习去了，结果没走几天撞上疫情，大家都只能在家学习。在家期间我的神经十分紧绷，每天的平均时长在14个小时以上，基本每天就是6点多起床一直学到晚上11点多，除了过年有两三天偷了个懒，三个月没怎么变过。也算是刷完了学校的二轮资料和几本网课资料。但是我仍然觉得自己的学习没有太大起色，从三月起学校开始让学生印模考卷做，我仍然只能考620左右，此时心态十分炸裂，后悔却又无可奈何，那个时候平均两天就会改一次qq签名，正能量的鸡汤背后是深深的负能量。我反思前面做的这一切，终于承认了自己就是普通人的事实，为何要追求680这一虚无缥缈的目标，就这样舒舒服服地苟着不就好了吗？</p>
<h2 id="回归正常"><a href="#回归正常" class="headerlink" title="回归正常"></a>回归正常</h2><p>4月回到学校后我就开始佛系了，不再想着自己去做些什么，而是按部就班地跟着学校。回来的第一次模考，我在数学113血崩的情况下考了年级36，惊艳了一些同学。接下来的一次考试又到了100多名，然后又考了43名，之后就回到以前的段位，考60名左右的水平。事实证明，回家学习的这段时间我大概就物理有了进步，最头疼的数学还是老样子。进步最明显的是心态，我开始没那么在意高考，而且开始对现状持接纳态度，珍惜毕业前的日子。我会趁着晚上走读便利，和同学去吃华莱士、克莱堡、烧烤，甚至有一天住到他家里。考前两周我为全班同学吹奏《追梦赤子心》，高考完我回去给一位尊敬的老师吹奏《离歌》，弥补了高二的一次遗憾。</p>
<p>那段时间，我也常思考未来，不再去追求一时脑热的化学和心理学专业，觉得作为一个普通人就学个计算机专业，到时候出来工作挣钱就行了。看知乎推荐觉得北邮是一所不错的学校，因为就业率非常高，华科也可以，有“北北邮，南华科”之称。我给自己的计算机专业学校排名是：浙大→北航→华科→北邮→西电/西工。虽然佛系，高考我仍旧全力以赴，最后655收场，语文数学略炸，英语正常，理综略超常，总分是正常水平。周围不少平时一般的同学考到了670+，确实还是有点点不甘心吧。</p>
<p>报志愿的时候，这个分数在我省提前批次确实可以冲一冲华科，往年最高分数是656。但是华科CS给的名额很少，又是热门专业，所以心里没底。就这样，提前批我填了华科（只写了三个专业，还不服从调剂，事后后悔了，因为这不是稳进CS的方案），本一批填了北邮。其实这个分数挺合适的，分低一些我会进入华科非CS专业（光电/能动），分高一点（&gt;660）我说不定会冲进浙大的差专业。最后，事实证明我的担心多余，顺利来到华科CS。从结果上看，我的高考是比较顺利的。</p>
<h2 id="一晃而过的暑假"><a href="#一晃而过的暑假" class="headerlink" title="一晃而过的暑假"></a>一晃而过的暑假</h2><p>暑假开始做一些自己想做的事了，比如说学完标日上下册，还背了一些日语单词；口琴继续练；本来说要做视频，还是没有去学，懂了Pr基本操作，在9月初才剪了一个自己勉强满意的视频；骑车上国道，玩了一天多。</p>
<p>知道自己被华科CS录取后，我又开始“蠢蠢欲动”了，因为本质上我不是一个甘于平庸的人。因为高中的“难忘”经历，我果断地认定卷加权不是适合自己的道路，如何把大学生活过得丰富且有意义，是我最为注重的。早在高考之前，我就听说过华科的“三大团队”，抛开一些功利性的东西不谈，单是出于向往“互联网大学”，我就很想加入。于是我加入了秋招群，在自己并不清楚想要选什么方向的情况下，开始准备冲击联创Lab组，至于为什么是Lab，因为Lab的学习指南里有C，在看到招新信息的时候我已经学了一周的C，不想浪费基础（现在看起来有点可笑）。于是暑假的后半段我每天抽很多时间去看C、Linux，但是都是刷视频且浮光掠影；试着啃了一下黑皮《计算机科学导论》，每天刷个十几二十页，也感觉很难吸收其中的知识，看后就忘。</p>
<p><strong>从这里我开始产生一个矛盾：自己有明确想要学的东西（日语、口琴、视频），但是因为我有别的东西要追求，所以没时间做自己喜欢的事。要做的事多和有限的精力之间产生了不可调和的矛盾。</strong>现在思考一下我想加入团队的原因，无非：①因为高中怎么学都考不进年级前列，对卷加权这件事没有信心，想建立自己在其他方向的优势；②不想继续卷，觉得团队能带来有意义和丰富的生活。其他原因都能归咎于这两点上——想变强/想过不同的生活。</p>
<p>但是要加入团队，又不得不经历一个卷的过程，要努力卷进团队，就没有时间去做自己想做的事了。</p>
<h1 id="步入大学"><a href="#步入大学" class="headerlink" title="步入大学"></a>步入大学</h1><h2 id="确定方向"><a href="#确定方向" class="headerlink" title="确定方向"></a>确定方向</h2><p>来华科以后，新鲜感很快就过去，由于疫情，军训只持续了不到两星期，最后一天坐在潮湿的地面导致我感冒了。这段时间最重要的事就是冲击团队。我同时报名了冰岩、联创和Dian，最开始招新的是冰岩，根据我学习的内容，我选择了程序组。</p>
<p>那个时候我的基础，就是C语言能写<code>printf</code>和<code>if</code>、<code>for</code>循环的程度，连指针和数组都不会用。是的，美其名曰我暑假自学了C语言，其实就是刷视频，而且还没刷到指针，自己的代码能力几乎为0。Linux知道一些如<code>ls</code>、<code>cd</code>、<code>pwd</code>等的常用指令，自己配好了Vmware虚拟机。还稍微看了一点HTML和Python，但是几乎不会用。我还记得自己当时报名信息里吹得天花乱坠，把会的东西全部展开说，达到凑字数的目的，显得这个人很厉害。笔试时拿到题目，我几乎完全懵逼，但是还是硬生生的都编上去了，所有代码题和程序设计题都不会，就强行整个思路上去。最后笔试通过，国庆那天去了1006面试，为了试图作出“努力”的样子，我中午不到1点就到了，然后坐在那里为面试复习，拿起黑皮《计算机科学导论》，但是说实话什么都看不进去。那边有一两个学长学姐，我也不知道怎么跟他们寒暄。我当时思路清奇，走过去跟lyt学长说：“虽然笔试题我都不会，但我还是尽了最大努力去编答案”，似乎是想体现自己的顽强意志，结果得到了“不是给时间学了吗”的回复。然后面试开始，自我介绍，然后谈了自己会的东西，我刻意强调了自己会的都是很简单的皮毛。最后lyt学长问到如何用Python来把一个字符串逆序，我自然是承认自己不会。我最后还不忘补了一刀“我也存在一些同学在群里说的问题，就是像高中一样啃书学习，缺乏实践”。面试自然而然是被挂掉了。我认识到了自己的菜，所以后边的联创和Dian就鸽了。</p>
<p>当时我觉得，程序组的题目这么难，我自学一学期后端应该也进不了组，而且我高中数学就不是很好，编程可能比不过一些大佬，还是选一个大家都是零基础的、好入门的方向吧。那时候就在知乎上搜，发现前端学习路线非常明确，好像比较简单，加之我之前有一点点HTML的基础，觉得努力学一学期应该可以冲一冲团队，于是我就立刻决定学前端。那时真的是特别想去团队，不去想自己到底热爱什么，想的是什么方向适合我冲击团队。</p>
<p><strong>其实大学四年的时间很长，完全可以什么方向都学一些，再看看自己到底喜欢什么方向；或许自己不适合搞开发，那么就应该去读研。但我的决定就是做得这么快。</strong></p>
<h2 id="生活与学习"><a href="#生活与学习" class="headerlink" title="生活与学习"></a>生活与学习</h2><p>我的大学，从一开始就放弃参加内卷游戏，选择冲击团队之路后，我还希望自己的生活过得丰富一些。于是加入了车协，去骑东湖、骑八分山、骑到武大。武大百团的时候，我还加入了樱之音口琴社（虽然加入后从没参加过活动）。</p>
<p>不知怎么，现在的我已经没法沉下心来玩很长时间的游戏了，玩的时间一长就会导致做别的事情的时间变少，内心就会产生焦虑。其实我一点也不喜欢这样，初中那时一日十来个小时的游戏生活已经彻底远去。其他时间，就是看一看动漫，比起新番，我倾向于老的经典番剧，名作之壁。暑假看了凉宫、石头门、强风吹拂、排球、轻音、京吹，开学后继续看巨人、狼辛，后来又看了钢炼03、小圆、天元、Fate…</p>
<p>然后谈谈学习吧，为了抽出来更多时间来学技术，学校排的课我都疯狂水过，还翘了不少课。平时简单自学一下，做作业都是面向答案，考前再突击一下，第一学期除了期中线代挂掉，其他的科目都还能看，总加权也算混进了前50%，自己还是比较满意的。</p>
<p>但是技术学习，我还存在很多问题。首先我学习主要靠看视频（视频比较系统，看完了可以大概知道一个东西怎么做），而且对于100多集的视频，我一天也就看3~6集，所以学起来的速度非常慢，学完了还缺乏实践。于是就这样，我花了三个多月才完三剑客基础+Markdown，这种学习速度让我变得更加自卑，我不停地安慰自己：“不可心急，日积月累”。我想冲团队的愿望也影响了寝室的氛围，大家或多或少都在学习技术上的东西。</p>
<p>还有一件不愿提及但是不得不提的事就是摔牙，那时候我也抑郁了一阵子，觉得自己不能啃东西了什么的，但是时间可以冲淡悲伤，现在的我也逐渐接纳了这件事。</p>
<h2 id="忙碌的寒假"><a href="#忙碌的寒假" class="headerlink" title="忙碌的寒假"></a>忙碌的寒假</h2><p>我把寒假当作自己冲击冰岩的关键期，所以依然努力学习前端技术。我深入了一些JS，照着冰岩往年的笔试题来补充知识点，看了不少博客，最后觉得自己的实践能力不足，所以又复刻了一些页面。</p>
<p>因为团队是鞭策我学习的重要因素，有时候我会上网搜索信息，读完以后我就会动力十足，继续学习。一次在Github上搜索冰岩，找到了以前夏令营开的仓库，以此我了解到了gc学姐，一次问她js问题的时候，她向我发了一篇博客，是xiong35学长的。当时我就觉得学长很强，这激励了我花了三天时间，去搞了一个WP博客。然后我也加了学长的好友，稍微聊了一些后他鼓励了我，说我春招很有希望进入冰岩。当时的我，确实也有了一些进入冰岩的自信。</p>
<h2 id="冲冰岩失败"><a href="#冲冰岩失败" class="headerlink" title="冲冰岩失败"></a>冲冰岩失败</h2><p>开学以后，我一直期盼着冰岩的招新信息。这段时间我继续完成寒假的项目，以及看博客补充新的知识。很快招新就来了，因为心里激动，简历我是改了又改，最后我作了个大死，说自己搜冰岩的信息，想借此体现自己的热爱。殊不知，这是给自己挖了个天大的坑。我以为秋招面试被挂能带来一些教训，结果春招时我情商还是老样子。</p>
<p>就这样我一路杀过简历、面试，实习选题时，我不敢给自己选太难的，就还是老老实实复刻网页。因为实习只能通过很少的人，而实习名单里好像有实力很强的大二学长，我就还是不自信。实习期我疯狂翘课抄作业，硬是把所有Level基本完成了，展示时我想让自己说得更有条理一些，于是准备了稿子（作死*2），展示完后我觉得自己稳了。</p>
<p>然后就到了组面，在门外，我开始在脑海中构思着自我介绍。我一进门气氛就冷到冰点，然后就是我自顾自地说了很多（作死*3），接着被xiong35学长问到查资料的事，我也没有作出很好的解释。之后面试官问我还有没有什么问题，我反向让他们继续问我，结果被问到了答不上来的问题，场面继续尴尬。后面结局基本就注定了，组面没有通过。</p>
<h2 id="继续迷茫"><a href="#继续迷茫" class="headerlink" title="继续迷茫"></a>继续迷茫</h2><p>组面结束后的那个下午，我就不带手机绕着主校区走了一圈，以排解心中的苦闷。后来我的舍友A通过了冰岩程序组的考核，舍友B通过了Dian的考核。当时最想进入团队的我就这样落败，而他们怀着试一试的心态参与，就这样顺利进入了，一点都不羡慕是不可能的。</p>
<p>后来xiong35学长找我谈，说我技术很强，但是因为如上列举的原因没有让我通过，自己的风格和团队不符，让我找到适合自己的组织。后来我又联系了欧阳学姐，她说我“痴迷于技术”，“有种理工男呆呆的感觉”，“像个geek”，“忽略了一些情商方面的东西”（当然，我从来不认为自己像个Geek，因为Geek这个词给我一种很强的感觉）。</p>
<p>我开始迷茫了，竟然在技术过关的情况下，因为别的因素被团队挂掉，我不太能接受这个结局。而且说我技术很强，那个时候我还真的相信了，开始考虑换方向，甚至是读研——毕竟学习能力强嘛，又何必局限于“简单”的前端。但是我技术真的强吗，也不强。学了五六个月还是这么点水平。想想xiong35学长充沛的精力和很强的学习能力，从零开始40天就能写博客的前后端，我就觉得自己什么都算不上。最后我还是继续学前端，不想浪费基础，而且还可以继续冲击团队。</p>
<p>可是说实话，我真的喜欢前端吗？不喜欢也不讨厌吧，遇到Bug会抓耳挠腮十分难受，可是解决问题时也会有巨大的成就感。写出赏心悦目的页面也可以给我带来正向反馈，但是也就仅仅是网页而已。现在我最需要的，大概就是要做出一个产品吧？一直孤立地自学，啃厚厚的书籍却什么也不做，又有何乐趣可言呢？总之，我目前还像是停留在“为了学习而学习，为了团队而学习”，而不是“为了需求而学习，一边实践一边学习”。</p>
<p>这学期的课内学习要比上学期拉跨了，一来是课业明显变得繁重，二是难度开始加大。我的态度也比上学期要松懈了许多，作业中有很多没有搞懂的内容，考试前复习得也不充分，就这样，我的微积分期中考试直接挂科。以后必须要改善学习方法了，不想投入时间又不想挂科的话，必须要依赖网上的“速成课”，或者慕课。</p>
<p>现在的我，还是想先坚持前端的路线，体验一下开发到底是什么感觉，后续作出的决定，很大程度上与我有没有进入团队有关。之前我想的是本科毕业就去投前端岗，去大厂996，但是最好还是读一下研究生，去外企955吧。</p>
<p>希望HackDay和暑假的夏令营能带来一些转变吧。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以下记录HackDay经历和带来的一些转变：</p>
<p>那是一节国际金融公选课，抄完大物答案百无聊赖的我打开了微信，看见了联创的最新推文——HackDay Reboot。其实这种比赛，我一般是不敢去想的——奖金丰厚、大佬云集，既然标榜是“极客狂欢”，和我这样的蒟蒻又有什么关系呢。但最后思量着，6月14日结束后应该来得及备考期末，况且可以学到不少东西，我还是决定报名。</p>
<p>进入FAQ群后，我本来决定报名后到现场组队，令我没有想到的是，一个冰岩的同学邀请我加入他们。最后三个冰岩人和我这个野路子组成了“启明好难队”。既然和冰岩同学组队了，我就不敢掉以轻心，生怕拖了他们的后腿。</p>
<p>我开始做知乎的项目练习前后端交互，开始写移动端，学了swiper插件（用于移动端滑动页面），由于发现原生JS的效率实在不高，在参加比赛的前一晚我入门了JQuery。</p>
<p>6月13日很快到来，我们先是在报告厅举办了开幕式，然后来到12楼，我被满眼的饮料和零食惊到了，没见过这种大场面。我们之前储备的idea押到了今年的关键字“择”，于是每个人就开始各搞各的，详细比赛过程就不多言。白嫖蒸功夫、披萨、小龙虾、K记的感觉真是太爽了，明年还来。</p>
<p>这次比赛印证了一点——我的技术确实存在短板，思维也常常跟不上，很多需求没做出来，设计的图也只用到一张。后端帮助了我很多，包括熬夜一整晚帮忙理清部分JS逻辑（惭愧）。命悬一刻的时候，都是后端救了我。没有我的队友，真的连阉割版产品都拿不出来。<br>一轮筛选的嘉宾有思否CEO高阳，有幸通过一轮筛选进入二轮，虽然最终没有获奖，但是已经很满意了。</p>
<p>顺带一提，同房间的大佬做的游戏实在牛逼（Re0从零开始的HUST生活），现场效果爆炸，拔得头筹。听到他们的商量和激烈的辩论，我发现，原来这就是Geek，他们对编程的热爱，是溢于言表的，即便是旁人也能深受感染，不像我遇到Bug时的萎靡无力。</p>
<p>经过HackDay，我认识到，学习编程是为了兴趣而非为了团队，真正的Geek用编程改变世界。几个月以来，在加入团队的室友和我侃侃而谈，以及和冰岩同学组队参加比赛之后，我愈来愈觉得，<strong>加入团队也并非我以前所以为的那样光鲜亮丽，团队人≠人上人。抬高对方，疯狂自贬的行为是错误的。</strong></p>
<p>看见大佬开发游戏的时候，我对游戏开发也产生了一定的兴趣，遂希望以后可以学一些框架去开发网页游戏。并且我认为，只是写网页确实有些普通，尝试客户端APP的开发也是一条可行之路。前端追求的是炫酷的特效和优秀的用户体验，我觉得也不错。当下先继续打好前端基础，<strong>不要把加入团队当作自己前进的动力</strong>，要因为喜欢，所以才用汗水浇灌它，哪怕最终什么团队都没加入，自己也可以在沁苑一隅发光发热。</p>
<p>—————————————————————END———————————————————————</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>json的crud</title>
    <url>/2021/05/30/10.json%E7%9A%84crud/</url>
    <content><![CDATA[<p>说是crud，只有写和查而已</p>
<span id="more"></span>

<p>写：data是index.json中的所有数据，由于data一开始是二进制buffer，先用toString方法转化为字符串，再用JSON.parse转化为对象，把新的数据加入数组（allUser转为对象后是一个数组），把数组转化为字符串，再写入index.json文件</p>
<p>查：用ES6的find方法就好</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeJson</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">    allUser = <span class="built_in">JSON</span>.parse(allUser);  <span class="comment">// 对空字符串不能使用该方法，所以初始情况下json文件不能为空</span></span><br><span class="line">    allUser.push(params);</span><br><span class="line">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(allUser);</span><br><span class="line">    fs.writeFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>, str, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;index.json：新增用户数据成功&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findJson</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          rejected(err)</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">        allUser = <span class="built_in">JSON</span>.parse(allUser);</span><br><span class="line">        user = allUser.find(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> user.id === str;</span><br><span class="line">        &#125;)</span><br><span class="line">        resolved(user);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>前后端交互</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端交互初尝试</title>
    <url>/2021/05/30/09.%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<p>之前对前后端交互的理解一直不够透彻，虽然也搞过模板引擎，但都是照着老师的做，自己懂的确实很有限。这两天搜搞前后端交互让我心力交瘁，但最后还是搞懂了一些</p>
<span id="more"></span>

<p>一图归纳我到目前的理解程度：</p>
<p><img src="/2021/05/30/09.%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92%E5%88%9D%E5%B0%9D%E8%AF%95/1.jpg"></p>
<p>前端：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">  xhr.send(<span class="string">`id=<span class="subst">$&#123;input3.value&#125;</span>&amp;password=<span class="subst">$&#123;input4.value&#125;</span>`</span>);</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">        <span class="keyword">if</span> (data.status == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="built_in">window</span>.location.href = <span class="string">&quot;/&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data.status == <span class="number">499</span>) &#123;</span><br><span class="line">          alert(<span class="string">&#x27;该用户已注册！&#x27;</span>);</span><br><span class="line">          location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后端：get请求页面资源，post处理ajax</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/login&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&#x27;./pc-views/login.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    res.end(data);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;/login&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  findJson(req.body.id).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(user);</span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      writeJson(req.body);</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="number">200</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      res.send(&#123;</span><br><span class="line">        <span class="string">&quot;status&quot;</span>: <span class="number">499</span>,</span><br><span class="line">        <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;user already registered&quot;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>前后端交互</tag>
      </tags>
  </entry>
  <entry>
    <title>原生ajax的req.body为空</title>
    <url>/2021/05/30/08.%E5%8E%9F%E7%94%9Fajax%E7%9A%84req.body%E4%B8%BA%E7%A9%BA/</url>
    <content><![CDATA[<p>原生ajax，很多人都不推荐在实战中使用，因为我别的都不会，只能先凑合着用原生，结果就遇到了发送post请求过去，结果req.body为空对象的情况</p>
<span id="more"></span>

<p>一开始的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> userjson = &#123;</span><br><span class="line">     <span class="comment">// 这里的数据格式不对</span></span><br><span class="line">    <span class="string">&quot;id&quot;</span>: input3.value,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: input4.value</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">  xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">  xhr.send(userjson);</span><br><span class="line"></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(xhr.response);</span><br><span class="line">        <span class="comment">//之后要根据不同的response进行不同的操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要修改两个地方：</p>
<ul>
<li>请求头</li>
<li>数据格式</li>
</ul>
<p>修改后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">regBtn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    </span><br><span class="line">  xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">  xhr.setRequestHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">  <span class="comment">// 修改请求头（没有深入理解）</span></span><br><span class="line">    </span><br><span class="line">  xhr.send(<span class="string">`id=<span class="subst">$&#123;input3.value&#125;</span>&amp;password=<span class="subst">$&#123;input4.value&#125;</span>`</span>);	</span><br><span class="line">  <span class="comment">// 在不配置的情况下，原生ajax发送post请求必须用这个数据格式：&#x27;a=xxx&amp;b=xxx&amp;c=xxx&#x27;</span></span><br><span class="line">    </span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(xhr.response);</span><br><span class="line">        <span class="keyword">if</span> (data.status == <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data.status == <span class="number">499</span>) &#123;</span><br><span class="line">		  <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>返回回调函数中的变量</title>
    <url>/2021/05/30/07.%E8%BF%94%E5%9B%9E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>初次在实践中用到promise，下次学await</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findJson</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// str参数表示用户的账号（手机号）</span></span><br><span class="line">  fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">    allUser = <span class="built_in">JSON</span>.parse(allUser);</span><br><span class="line">    user = allUser.find(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> user.id === str;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 我希望findJson函数可以把user给return出来</span></span><br><span class="line">    <span class="comment">// 直接在这里return是没用的</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>promise改进版：</p>
<p>findJson函数写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findJson</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, rejected</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./public/json/index.json&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          rejected(err)</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> allUser = data.toString();</span><br><span class="line">        allUser = <span class="built_in">JSON</span>.parse(allUser);</span><br><span class="line">        user = allUser.find(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> user.id === str;</span><br><span class="line">        &#125;)</span><br><span class="line">        resolved(user);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调的时候可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">findJson(<span class="string">&#x27;11111111111&#x27;</span>).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(user)</span><br><span class="line"> &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.error(err)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<p>传入参数’11111111111’后，函数已经在index.json中找到了user（或者是undefined），执行resolved(user)，可以把user传入接下来的函数，可以得到user，这样就相当于return出来了。</p>
<p>在我的函数中是这样写的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/login&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  findJson(req.body.id).then(<span class="function"><span class="params">user</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">undefined</span>) &#123;</span><br><span class="line">	  <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的rem布局</title>
    <url>/2021/05/28/06.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84rem%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>移动端的rem布局实践</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> designWidth = <span class="number">375</span>;  		<span class="comment">// 设计稿宽度</span></span><br><span class="line"><span class="keyword">const</span> remPx = <span class="number">100</span>;               <span class="comment">// 在屏幕宽度375px的时候，设置根元素字体大小 100px</span></span><br><span class="line"><span class="keyword">let</span> scale = <span class="built_in">window</span>.innerWidth / designWidth; <span class="comment">// 计算当前屏幕的宽度与设计稿比例</span></span><br><span class="line"><span class="comment">// 根据屏幕宽度动态计算根元素的字体大小</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = scale * remPx + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我为了保险，还在css中设置了根元素字体大小是100px，为了不影因为字体太大而影响布局，我又设置了body字体大小为16px</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，其他元素都用rem即可</p>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>超出后省略剩余部分</title>
    <url>/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>效果如下：</p>
<p><img src="/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/1.jpg"></p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>美国顶级传染病专家福奇称「不确信新冠病毒来自大自然，应该继续调查中国」，他为何突然改口？<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>环球时报 ：我们都知道，自去年新冠肺炎疫情在美国暴发<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2.02rem</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">0.16rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0.2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0.04rem</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.14rem</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*这三个需要一起用*/</span></span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="/2021/05/28/05.%E8%B6%85%E5%87%BA%E5%90%8E%E7%9C%81%E7%95%A5%E5%89%A9%E4%BD%99%E9%83%A8%E5%88%86/2.jpg"></p>
]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端和PC端设置不同页面</title>
    <url>/2021/05/28/04.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%92%8CPC%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>在服务端添加以下代码（以express为例）</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMachine</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> deviceAgent = req.headers[<span class="string">&quot;user-agent&quot;</span>].toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> agentID = deviceAgent.match(<span class="regexp">/(iphone|ipod|ipad|android)/</span>);</span><br><span class="line">  <span class="keyword">if</span> (agentID) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 移动端</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// PC端</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> machine = getMachine(req);</span><br><span class="line">  <span class="keyword">if</span> (machine) &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./pe-views/index.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;./pc-views/index.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      res.end(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>实践</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack笔记</title>
    <url>/2021/05/24/02.webpack%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>一边啃JS和计网的书，一边来学webpack，学习完后就可以学习框架了，实战搞起来，理论补起来</p>
<span id="more"></span>

<h1 id="简介（P2）"><a href="#简介（P2）" class="headerlink" title="简介（P2）"></a>简介（P2）</h1><ul>
<li>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。</li>
<li>在 webpack 看来, 前端的所有资源文件(js/json/css/img/less/…)都会作为模块处理。</li>
<li>它将根据模块的依赖关系进行静态分析，打包生成对应的静态资源(bundle)。</li>
</ul>
<h1 id="五个核心概念（P3）"><a href="#五个核心概念（P3）" class="headerlink" title="五个核心概念（P3）"></a>五个核心概念（P3）</h1><ul>
<li>Entry：指示 webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图</li>
<li>Output：指示 webpack 打包后的资源 bundles 输出到哪里去，以及如何命名</li>
<li>Loader： 让 webpack 能够去处理那些非JavaScript文件（翻译）</li>
<li>Plugins：可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，<br>一直到重新定义环境中的变量等。</li>
<li>Mode：指示 webpack 使用相应模式的配置，分为development和production</li>
</ul>
<h1 id="初体验（P4）"><a href="#初体验（P4）" class="headerlink" title="初体验（P4）"></a>初体验（P4）</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>新建文件夹：webpack初体验</li>
<li>npm init</li>
<li>npm i webpack webpack-cli -g</li>
<li>npm i webpack webpack-cli -D</li>
</ul>
<h2 id="打包应用"><a href="#打包应用" class="headerlink" title="打包应用"></a>打包应用</h2><h3 id="设置powershell"><a href="#设置powershell" class="headerlink" title="设置powershell"></a>设置powershell</h3><p>在执行以下指令以前，先设置powershell：<a href="https://blog.csdn.net/Piconjo/article/details/105716451">解决webpack : 无法加载文件 C:\Users\XXX\AppData\Roaming\npm\webpack.ps1因为在此系统上禁止运行脚本</a></p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><img src="https://img-blog.csdnimg.cn/20210509105459275.jpg#pic_center"></p>
<h3 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h3><ul>
<li>开发环境指令：webpack src/index.js -o ./build/built.js –mode=development<br>功能：webpack 能够编译打包 js 和 json 文件，并且能将 es6 的模块化语法转换成<br>浏览器能识别的语法。</li>
<li>生产环境指令：webpack src/index.js -o ./build/built.js –mode=production<br>功能：在开发配置功能上多一个功能，压缩代码。</li>
</ul>
<blockquote>
<p>备注：老师执行完开发环境指令后，在build目录下生成了built.js文件，而我执行完指令后，在build目录下生成了built.js目录，在该目录下有main.js文件，我猜测是配置方面的问题，因此我使用的指令是webpack src/index.js -o ./build –mode=development</p>
</blockquote>
<h3 id="实践（js）"><a href="#实践（js）" class="headerlink" title="实践（js）"></a>实践（js）</h3><p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>main.js(development):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ATTENTION: The &quot;eval&quot; devtool has been used (maybe by default in mode: &quot;development&quot;).</span></span><br><span class="line"><span class="comment"> * This devtool is neither made for production nor for readable output files.</span></span><br><span class="line"><span class="comment"> * It uses &quot;eval()&quot; calls to create a separate source file in the browser devtools.</span></span><br><span class="line"><span class="comment"> * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span></span><br><span class="line"><span class="comment"> * or disable the default devtool with &quot;devtool: false&quot;.</span></span><br><span class="line"><span class="comment"> * If you are looking for production-ready output files, see mode: &quot;production&quot; (https://webpack.js.org/configuration/mode/).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/******/</span> (<span class="function">() =&gt;</span> &#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> __webpack_modules__ = (&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/***/</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&quot;function add(x,y)&#123;\r\n  return x+y;\r\n&#125;\r\nconsole.log(add(1,2));\n\n//# sourceURL=webpack://webpack_test/./src/index.js?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/***/</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/******/</span> 	&#125;);</span><br><span class="line"><span class="comment">/************************************************************************/</span></span><br><span class="line"><span class="comment">/******/</span> 	</span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// startup</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// Load entry module and return exports</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="comment">// This entry module can&#x27;t be inlined because the eval devtool is used.</span></span><br><span class="line"><span class="comment">/******/</span> 	<span class="keyword">var</span> __webpack_exports__ = &#123;&#125;;</span><br><span class="line"><span class="comment">/******/</span> 	__webpack_modules__[<span class="string">&quot;./src/index.js&quot;</span>]();</span><br><span class="line"><span class="comment">/******/</span> 	</span><br><span class="line"><span class="comment">/******/</span> &#125;)()</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>main.js(production):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//这里和老师的也不一样</span></span><br></pre></td></tr></table></figure>
<p>无论是开发环境产生的main.js，还是生产环境产生的main.js，都可以运行（node或浏览器内）：<br><img src="https://img-blog.csdnimg.cn/20210509104516739.jpg#pic_center"></p>
<h3 id="实践（json）"><a href="#实践（json）" class="headerlink" title="实践（json）"></a>实践（json）</h3><p>data.json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;jack&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改index.js，再打包生成main.js文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&#x27;./data.json&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20210509105129855.jpg#pic_center"><br>还是可以正常执行，说明webpack可以处理json</p>
<h1 id="打包样式资源（P5）"><a href="#打包样式资源（P5）" class="headerlink" title="打包样式资源（P5）"></a>打包样式资源（P5）</h1><p>注意，所有loader都需要用npm下载</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>webpack.config.js是webpack的配置文件</li>
<li>作用: 指示 webpack 干哪些活（当运行 webpack 指令时，会加载里面的配置）</li>
</ul>
<p>所有构建工具都是基于nodejs平台运行的，模块化默认采用commonjs。<br>（模块化分为ES6模块和commonjs）</p>
<p><img src="https://img-blog.csdnimg.cn/20210509163511553.jpg#pic_center"><br>配置文件和src目录在同一层级</p>
<p>配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// resolve用来拼接绝对路径的方法（不懂照做，以后深入学node）</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// webpack配置</span></span><br><span class="line">  <span class="comment">// 入口起点</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="comment">// 输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    <span class="comment">// __dirname nodejs的变量，代表当前文件的目录绝对路径（不懂照做）</span></span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader的配置</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 详细loader配置</span></span><br><span class="line">      <span class="comment">// 不同文件必须配置不同loader处理</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 匹配哪些文件（正则表达式）</span></span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 使用哪些loader进行处理</span></span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// use数组中loader执行顺序：从右到左，从下到上 依次执行（很重要）</span></span><br><span class="line">          <span class="comment">// 创建style标签，将js中的样式资源插入进行，添加到head中生效</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将css文件变成commonjs模块加载js中，里面内容是样式字符串</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将less文件编译成css文件</span></span><br><span class="line">          <span class="comment">// 需要下载 less-loader和less</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// plugins的配置</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 详细plugins的配置</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  <span class="comment">// mode: &#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h2><p>此处以css为主，就不写less文件了</p>
<p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入样式资源</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.less&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.css:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="加载顺序"><a href="#加载顺序" class="headerlink" title="加载顺序"></a>加载顺序</h2><ul>
<li>首先通过entry加载index.js</li>
<li>加载index.js后，发现它依赖了index.css</li>
<li>现在有js和css两个资源，每个资源都要经过rules中的loader处理</li>
<li>根据test，css资源匹配，会使用其中的loader对css资源进行处理</li>
<li>loader从下往上进行处理</li>
<li>css-loader将css文件变成commonjs模块加载js中，里面内容是样式字符串，可以在输出的built.js文件中检查到</li>
<li>style-loader在页面打开时，创建style标签，将js中的样式资源插入style标签，再添加到head中生效</li>
</ul>
<p>想要查看效果，只需把built.js文件引入html即可</p>
<h1 id="打包html资源"><a href="#打包html资源" class="headerlink" title="打包html资源"></a>打包html资源</h1><p>重点是配置plugins，记得下载和引用plugins</p>
<p>下载：npm i html-webpack-plugin -D</p>
<p>config:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  loader: 1. 下载   2. 使用（配置loader）</span></span><br><span class="line"><span class="comment">  plugins: 1. 下载  2. 引入  3. 使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;built.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: resolve(__dirname, <span class="string">&#x27;build&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// loader的配置</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// plugins的配置</span></span><br><span class="line">    <span class="comment">// html-webpack-plugin</span></span><br><span class="line">    <span class="comment">// 功能：默认会创建一个空的HTML，自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">    <span class="comment">// 需求：需要有结构的HTML文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 复制 &#x27;./src/index.html&#x27; 文件，并自动引入打包输出的所有资源（JS/CSS）</span></span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>index.html:（没有引入index.js）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>hello html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打包后，在build目录下生成了index.html:<br>（这里老师直接在终端输入webpack就可以打包了，我也不知道为什么）</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化详解笔记</title>
    <url>/2021/05/24/03.%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%A6%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>参考博客：<a href="https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a></p>
<span id="more"></span>


<h1 id="模块化理解"><a href="#模块化理解" class="headerlink" title="模块化理解"></a>模块化理解</h1><h2 id="IIFE模式"><a href="#IIFE模式" class="headerlink" title="IIFE模式"></a>IIFE模式</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">window</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> data = <span class="string">&#x27;www.baidu.com&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//操作数据的函数</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//用于暴露有函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`foo() <span class="subst">$&#123;data&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//用于暴露有函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`bar() <span class="subst">$&#123;data&#125;</span>`</span>)</span></span><br><span class="line"><span class="javascript">        otherFun() <span class="comment">//内部调用</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">otherFun</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//内部私有的函数</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;otherFun()&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//暴露行为</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.myModule = &#123;foo,bar&#125; <span class="comment">//ES6写法</span></span></span><br><span class="line"><span class="javascript">    &#125;)(<span class="built_in">window</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    myModule.foo()</span></span><br><span class="line"><span class="javascript">    myModule.bar()</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(myModule.data) <span class="comment">//undefined 不能访问模块内部数据</span></span></span><br><span class="line"><span class="javascript">    myModule.data = <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">//不是修改的模块内部的data</span></span></span><br><span class="line"><span class="javascript">    myModule.foo() <span class="comment">//没有改变</span></span></span><br><span class="line"><span class="javascript">    myModule.foo = <span class="string">&#x27;xxxx&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    myModule.foo(); <span class="comment">//myModule.foo is not a function</span></span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>起初看到这一段代码，不理解为什么修改data后再调用myModule.foo()，输出没有改变，以下是心路历程：</p>
<ul>
<li>应该是在return中没有暴露data吧，我暴露试试</li>
<li>暴露data之后，console.log(myModule.data)可以正确输出了，不是undefined，但是myModule.foo()的输出依然没有改变，为什么？</li>
<li>修改myModule.data后再console.log没有问题，修改myModule.foo后也可以修改成功，为什么会出现上一条的状况？</li>
<li>因为IIFE只执行一次，执行的时候闭包（foo和bar）就已经确定好了对原始的data（即’<a href="http://www.baidu.com&/#39;%EF%BC%89%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E6%89%80%E4%BB%A5%E8%B0%83myModule.foo()%E5%B0%B1%E4%BC%9A%E8%BE%93%E5%87%BA%E5%8E%9Fdata%EF%BC%8C%E5%86%8D%E6%94%B9data%E4%B9%9F%E6%97%A0%E7%94%A8">www.baidu.com&#39;）的引用，所以调myModule.foo()就会输出原data，再改data也无用</a></li>
<li>以上的实践表明，使用该方法，由于闭包的特性，外部不可以直接修改内部的数据</li>
</ul>
<h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦把模块内的一个值赋值给一个变量，模块内部的变化就影响不到这个变量的值，除非写成一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node1.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(counter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">  <span class="attr">printCounter</span>: printCounter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//node2.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).counter;</span><br><span class="line"><span class="comment">// 从赋值之后开始 counter 变量的任何变化都与导出对象的 counter 属性毫无关系</span></span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).incCounter;</span><br><span class="line"><span class="keyword">var</span> printCounter = <span class="built_in">require</span>(<span class="string">&#x27;./node1&#x27;</span>).printCounter;</span><br><span class="line"></span><br><span class="line">printCounter(); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line">printCounter(); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>其他的以后再记</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
</search>
